
/*!
 * jQuery JavaScript Library v3.6.3
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-12-20T21:28Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.9
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2022-12-19
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {

					// `qSA` may not throw for unrecognized parts using forgiving parsing:
					// https://drafts.csswg.org/selectors/#forgiving-selector
					// like the `:has()` pseudo-class:
					// https://drafts.csswg.org/selectors/#relational
					// `CSS.supports` is still expected to return `false` then:
					// https://drafts.csswg.org/css-conditional-4/#typedef-supports-selector-fn
					// https://drafts.csswg.org/css-conditional-4/#dfn-support-selector
					if ( support.cssSupportsSelector &&

						// eslint-disable-next-line no-undef
						!CSS.supports( "selector(:is(" + newSelector + "))" ) ) {

						// Support: IE 11+
						// Throw to get to the same code path as an error directly in qSA.
						// Note: once we only support browser supporting
						// `CSS.supports('selector(...)')`, we can most likely drop
						// the `try-catch`. IE doesn't implement the API.
						throw new Error();
					}

					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	// Support: Chrome 105+, Firefox 104+, Safari 15.4+
	// Make sure forgiving mode is not used in `CSS.supports( "selector(...)" )`.
	//
	// `:is()` uses a forgiving selector list as an argument and is widely
	// implemented, so it's a good one to test against.
	support.cssSupportsSelector = assert( function() {
		/* eslint-disable no-undef */

		return CSS.supports( "selector(*)" ) &&

			// Support: Firefox 78-81 only
			// In old Firefox, `:is()` didn't use forgiving parsing. In that case,
			// fail this test as there's no selector to test against that.
			// `CSS.supports` uses unforgiving parsing
			document.querySelectorAll( ":is(:jqfake)" ) &&

			// `*` is needed as Safari & newer Chrome implemented something in between
			// for `:has()` - it throws in `qSA` if it only contains an unsupported
			// argument but multiple ones, one of which is supported, are fine.
			// We want to play safe in case `:is()` gets the same treatment.
			!CSS.supports( "selector(:is(*,:jqfake))" );

		/* eslint-enable */
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	if ( !support.cssSupportsSelector ) {

		// Support: Chrome 105+, Safari 15.4+
		// `:has()` uses a forgiving selector list as an argument so our regular
		// `try-catch` mechanism fails to catch `:has()` with arguments not supported
		// natively like `:has(:contains("Foo"))`. Where supported & spec-compliant,
		// we now use `CSS.supports("selector(:is(SELECTOR_TO_BE_TESTED))")`, but
		// outside that we mark `:has` as buggy.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {

			// Support: IE <9 only
			// IE doesn't have `contains` on `document` so we need to check for
			// `documentElement` presence.
			// We need to fall back to `a` when `documentElement` is missing
			// as `ownerDocument` of elements within `<template/>` may have
			// a null one - a default behavior of all modern browsers.
			var adown = a.nodeType === 9 && a.documentElement || a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );

var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.window = global.window || {}));
  }(this, (function (exports) { 'use strict';
  
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
  
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
  
      return self;
    }
  
    /*!
     * GSAP 3.11.4
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var _config = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    },
        _defaults = {
      duration: .5,
      overwrite: false,
      delay: 0
    },
        _suppressOverwrites,
        _reverting,
        _context,
        _bigNum = 1e8,
        _tinyNum = 1 / _bigNum,
        _2PI = Math.PI * 2,
        _HALF_PI = _2PI / 4,
        _gsID = 0,
        _sqrt = Math.sqrt,
        _cos = Math.cos,
        _sin = Math.sin,
        _isString = function _isString(value) {
      return typeof value === "string";
    },
        _isFunction = function _isFunction(value) {
      return typeof value === "function";
    },
        _isNumber = function _isNumber(value) {
      return typeof value === "number";
    },
        _isUndefined = function _isUndefined(value) {
      return typeof value === "undefined";
    },
        _isObject = function _isObject(value) {
      return typeof value === "object";
    },
        _isNotFalse = function _isNotFalse(value) {
      return value !== false;
    },
        _windowExists = function _windowExists() {
      return typeof window !== "undefined";
    },
        _isFuncOrString = function _isFuncOrString(value) {
      return _isFunction(value) || _isString(value);
    },
        _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
        _isArray = Array.isArray,
        _strictNumExp = /(?:-?\.?\d|\.)+/gi,
        _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        _relExp = /[+-]=-?[.\d]+/,
        _delimitedValueExp = /[^,'"\[\]\s]+/gi,
        _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        _globalTimeline,
        _win,
        _coreInitted,
        _doc,
        _globals = {},
        _installScope = {},
        _coreReady,
        _install = function _install(scope) {
      return (_installScope = _merge(scope, _globals)) && gsap;
    },
        _missingPlugin = function _missingPlugin(property, value) {
      return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
    },
        _warn = function _warn(message, suppress) {
      return !suppress && console.warn(message);
    },
        _addGlobal = function _addGlobal(name, obj) {
      return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
    },
        _emptyFunc = function _emptyFunc() {
      return 0;
    },
        _startAtRevertConfig = {
      suppressEvents: true,
      isStart: true,
      kill: false
    },
        _revertConfigNoKill = {
      suppressEvents: true,
      kill: false
    },
        _revertConfig = {
      suppressEvents: true
    },
        _reservedProps = {},
        _lazyTweens = [],
        _lazyLookup = {},
        _lastRenderedFrame,
        _plugins = {},
        _effects = {},
        _nextGCFrame = 30,
        _harnessPlugins = [],
        _callbackNames = "",
        _harness = function _harness(targets) {
      var target = targets[0],
          harnessPlugin,
          i;
      _isObject(target) || _isFunction(target) || (targets = [targets]);
  
      if (!(harnessPlugin = (target._gsap || {}).harness)) {
        i = _harnessPlugins.length;
  
        while (i-- && !_harnessPlugins[i].targetTest(target)) {}
  
        harnessPlugin = _harnessPlugins[i];
      }
  
      i = targets.length;
  
      while (i--) {
        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
      }
  
      return targets;
    },
        _getCache = function _getCache(target) {
      return target._gsap || _harness(toArray(target))[0]._gsap;
    },
        _getProperty = function _getProperty(target, property, v) {
      return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
    },
        _forEachName = function _forEachName(names, func) {
      return (names = names.split(",")).forEach(func) || names;
    },
        _round = function _round(value) {
      return Math.round(value * 100000) / 100000 || 0;
    },
        _roundPrecise = function _roundPrecise(value) {
      return Math.round(value * 10000000) / 10000000 || 0;
    },
        _parseRelative = function _parseRelative(start, value) {
      var operator = value.charAt(0),
          end = parseFloat(value.substr(2));
      start = parseFloat(start);
      return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
    },
        _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
      var l = toFind.length,
          i = 0;
  
      for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
  
      return i < l;
    },
        _lazyRender = function _lazyRender() {
      var l = _lazyTweens.length,
          a = _lazyTweens.slice(0),
          i,
          tween;
  
      _lazyLookup = {};
      _lazyTweens.length = 0;
  
      for (i = 0; i < l; i++) {
        tween = a[i];
        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
      }
    },
        _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
      _lazyTweens.length && !_reverting && _lazyRender();
      animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
      _lazyTweens.length && !_reverting && _lazyRender();
    },
        _numericIfPossible = function _numericIfPossible(value) {
      var n = parseFloat(value);
      return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
    },
        _passThrough = function _passThrough(p) {
      return p;
    },
        _setDefaults = function _setDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || (obj[p] = defaults[p]);
      }
  
      return obj;
    },
        _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
      return function (obj, defaults) {
        for (var p in defaults) {
          p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
        }
      };
    },
        _merge = function _merge(base, toMerge) {
      for (var p in toMerge) {
        base[p] = toMerge[p];
      }
  
      return base;
    },
        _mergeDeep = function _mergeDeep(base, toMerge) {
      for (var p in toMerge) {
        p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
      }
  
      return base;
    },
        _copyExcluding = function _copyExcluding(obj, excluding) {
      var copy = {},
          p;
  
      for (p in obj) {
        p in excluding || (copy[p] = obj[p]);
      }
  
      return copy;
    },
        _inheritDefaults = function _inheritDefaults(vars) {
      var parent = vars.parent || _globalTimeline,
          func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
  
      if (_isNotFalse(vars.inherit)) {
        while (parent) {
          func(vars, parent.vars.defaults);
          parent = parent.parent || parent._dp;
        }
      }
  
      return vars;
    },
        _arraysMatch = function _arraysMatch(a1, a2) {
      var i = a1.length,
          match = i === a2.length;
  
      while (match && i-- && a1[i] === a2[i]) {}
  
      return i < 0;
    },
        _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
  
      if (lastProp === void 0) {
        lastProp = "_last";
      }
  
      var prev = parent[lastProp],
          t;
  
      if (sortBy) {
        t = child[sortBy];
  
        while (prev && prev[sortBy] > t) {
          prev = prev._prev;
        }
      }
  
      if (prev) {
        child._next = prev._next;
        prev._next = child;
      } else {
        child._next = parent[firstProp];
        parent[firstProp] = child;
      }
  
      if (child._next) {
        child._next._prev = child;
      } else {
        parent[lastProp] = child;
      }
  
      child._prev = prev;
      child.parent = child._dp = parent;
      return child;
    },
        _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
  
      if (lastProp === void 0) {
        lastProp = "_last";
      }
  
      var prev = child._prev,
          next = child._next;
  
      if (prev) {
        prev._next = next;
      } else if (parent[firstProp] === child) {
        parent[firstProp] = next;
      }
  
      if (next) {
        next._prev = prev;
      } else if (parent[lastProp] === child) {
        parent[lastProp] = prev;
      }
  
      child._next = child._prev = child.parent = null;
    },
        _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
      child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
      child._act = 0;
    },
        _uncache = function _uncache(animation, child) {
      if (animation && (!child || child._end > animation._dur || child._start < 0)) {
        var a = animation;
  
        while (a) {
          a._dirty = 1;
          a = a.parent;
        }
      }
  
      return animation;
    },
        _recacheAncestors = function _recacheAncestors(animation) {
      var parent = animation.parent;
  
      while (parent && parent.parent) {
        parent._dirty = 1;
        parent.totalDuration();
        parent = parent.parent;
      }
  
      return animation;
    },
        _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
      return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
    },
        _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
      return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
    },
        _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
      return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
    },
        _animationCycle = function _animationCycle(tTime, cycleDuration) {
      var whole = Math.floor(tTime /= cycleDuration);
      return tTime && whole === tTime ? whole - 1 : whole;
    },
        _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
      return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
    },
        _setEnd = function _setEnd(animation) {
      return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
    },
        _alignPlayhead = function _alignPlayhead(animation, totalTime) {
      var parent = animation._dp;
  
      if (parent && parent.smoothChildTiming && animation._ts) {
        animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
  
        _setEnd(animation);
  
        parent._dirty || _uncache(parent, animation);
      }
  
      return animation;
    },
        _postAddChecks = function _postAddChecks(timeline, child) {
      var t;
  
      if (child._time || child._initted && !child._dur) {
        t = _parentToChildTotalTime(timeline.rawTime(), child);
  
        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
          child.render(t, true);
        }
      }
  
      if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
        if (timeline._dur < timeline.duration()) {
          t = timeline;
  
          while (t._dp) {
            t.rawTime() >= 0 && t.totalTime(t._tTime);
            t = t._dp;
          }
        }
  
        timeline._zTime = -_tinyNum;
      }
    },
        _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
      child.parent && _removeFromParent(child);
      child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
      child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
  
      _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
  
      _isFromOrFromStart(child) || (timeline._recent = child);
      skipChecks || _postAddChecks(timeline, child);
      timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
      return timeline;
    },
        _scrollTrigger = function _scrollTrigger(animation, trigger) {
      return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
    },
        _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
      _initTween(tween, time, tTime);
  
      if (!tween._initted) {
        return 1;
      }
  
      if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
        _lazyTweens.push(tween);
  
        tween._lazy = [tTime, suppressEvents];
        return 1;
      }
    },
        _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
      var parent = _ref.parent;
      return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
    },
        _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
      var data = _ref2.data;
      return data === "isFromStart" || data === "isStart";
    },
        _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
      var prevRatio = tween.ratio,
          ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
          repeatDelay = tween._rDelay,
          tTime = 0,
          pt,
          iteration,
          prevIteration;
  
      if (repeatDelay && tween._repeat) {
        tTime = _clamp(0, tween._tDur, totalTime);
        iteration = _animationCycle(tTime, repeatDelay);
        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
  
        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
          prevRatio = 1 - ratio;
          tween.vars.repeatRefresh && tween._initted && tween.invalidate();
        }
      }
  
      if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
          return;
        }
  
        prevIteration = tween._zTime;
        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
        suppressEvents || (suppressEvents = totalTime && !prevIteration);
        tween.ratio = ratio;
        tween._from && (ratio = 1 - ratio);
        tween._time = 0;
        tween._tTime = tTime;
        pt = tween._pt;
  
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
  
        totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
        tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
  
        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
          ratio && _removeFromParent(tween, 1);
  
          if (!suppressEvents && !_reverting) {
            _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
  
            tween._prom && tween._prom();
          }
        }
      } else if (!tween._zTime) {
        tween._zTime = totalTime;
      }
    },
        _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
      var child;
  
      if (time > prevTime) {
        child = animation._first;
  
        while (child && child._start <= time) {
          if (child.data === "isPause" && child._start > prevTime) {
            return child;
          }
  
          child = child._next;
        }
      } else {
        child = animation._last;
  
        while (child && child._start >= time) {
          if (child.data === "isPause" && child._start < prevTime) {
            return child;
          }
  
          child = child._prev;
        }
      }
    },
        _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
      var repeat = animation._repeat,
          dur = _roundPrecise(duration) || 0,
          totalProgress = animation._tTime / animation._tDur;
      totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
      animation._dur = dur;
      animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
      totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
      animation.parent && _setEnd(animation);
      skipUncache || _uncache(animation.parent, animation);
      return animation;
    },
        _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
      return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
    },
        _zeroPosition = {
      _start: 0,
      endTime: _emptyFunc,
      totalDuration: _emptyFunc
    },
        _parsePosition = function _parsePosition(animation, position, percentAnimation) {
      var labels = animation.labels,
          recent = animation._recent || _zeroPosition,
          clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
          i,
          offset,
          isPercent;
  
      if (_isString(position) && (isNaN(position) || position in labels)) {
        offset = position.charAt(0);
        isPercent = position.substr(-1) === "%";
        i = position.indexOf("=");
  
        if (offset === "<" || offset === ">") {
          i >= 0 && (position = position.replace(/=/, ""));
          return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
        }
  
        if (i < 0) {
          position in labels || (labels[position] = clippedDuration);
          return labels[position];
        }
  
        offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
  
        if (isPercent && percentAnimation) {
          offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
        }
  
        return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
      }
  
      return position == null ? clippedDuration : +position;
    },
        _createTweenType = function _createTweenType(type, params, timeline) {
      var isLegacy = _isNumber(params[1]),
          varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
          vars = params[varsIndex],
          irVars,
          parent;
  
      isLegacy && (vars.duration = params[1]);
      vars.parent = timeline;
  
      if (type) {
        irVars = vars;
        parent = timeline;
  
        while (parent && !("immediateRender" in irVars)) {
          irVars = parent.vars.defaults || {};
          parent = _isNotFalse(parent.vars.inherit) && parent.parent;
        }
  
        vars.immediateRender = _isNotFalse(irVars.immediateRender);
        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
      }
  
      return new Tween(params[0], vars, params[varsIndex + 1]);
    },
        _conditionalReturn = function _conditionalReturn(value, func) {
      return value || value === 0 ? func(value) : func;
    },
        _clamp = function _clamp(min, max, value) {
      return value < min ? min : value > max ? max : value;
    },
        getUnit = function getUnit(value, v) {
      return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
    },
        clamp = function clamp(min, max, value) {
      return _conditionalReturn(value, function (v) {
        return _clamp(min, max, v);
      });
    },
        _slice = [].slice,
        _isArrayLike = function _isArrayLike(value, nonEmpty) {
      return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
    },
        _flatten = function _flatten(ar, leaveStrings, accumulator) {
      if (accumulator === void 0) {
        accumulator = [];
      }
  
      return ar.forEach(function (value) {
        var _accumulator;
  
        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
      }) || accumulator;
    },
        toArray = function toArray(value, scope, leaveStrings) {
      return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
    },
        selector = function selector(value) {
      value = toArray(value)[0] || _warn("Invalid scope") || {};
      return function (v) {
        var el = value.current || value.nativeElement || value;
        return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
      };
    },
        shuffle = function shuffle(a) {
      return a.sort(function () {
        return .5 - Math.random();
      });
    },
        distribute = function distribute(v) {
      if (_isFunction(v)) {
        return v;
      }
  
      var vars = _isObject(v) ? v : {
        each: v
      },
          ease = _parseEase(vars.ease),
          from = vars.from || 0,
          base = parseFloat(vars.base) || 0,
          cache = {},
          isDecimal = from > 0 && from < 1,
          ratios = isNaN(from) || isDecimal,
          axis = vars.axis,
          ratioX = from,
          ratioY = from;
  
      if (_isString(from)) {
        ratioX = ratioY = {
          center: .5,
          edges: .5,
          end: 1
        }[from] || 0;
      } else if (!isDecimal && ratios) {
        ratioX = from[0];
        ratioY = from[1];
      }
  
      return function (i, target, a) {
        var l = (a || vars).length,
            distances = cache[l],
            originX,
            originY,
            x,
            y,
            d,
            j,
            max,
            min,
            wrapAt;
  
        if (!distances) {
          wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
  
          if (!wrapAt) {
            max = -_bigNum;
  
            while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
  
            wrapAt--;
          }
  
          distances = cache[l] = [];
          originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
          originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
          max = 0;
          min = _bigNum;
  
          for (j = 0; j < l; j++) {
            x = j % wrapAt - originX;
            y = originY - (j / wrapAt | 0);
            distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
            d > max && (max = d);
            d < min && (min = d);
          }
  
          from === "random" && shuffle(distances);
          distances.max = max - min;
          distances.min = min;
          distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
          distances.b = l < 0 ? base - l : base;
          distances.u = getUnit(vars.amount || vars.each) || 0;
          ease = ease && l < 0 ? _invertEase(ease) : ease;
        }
  
        l = (distances[i] - distances.min) / distances.max || 0;
        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
      };
    },
        _roundModifier = function _roundModifier(v) {
      var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
      return function (raw) {
        var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
  
        return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
      };
    },
        snap = function snap(snapTo, value) {
      var isArray = _isArray(snapTo),
          radius,
          is2D;
  
      if (!isArray && _isObject(snapTo)) {
        radius = isArray = snapTo.radius || _bigNum;
  
        if (snapTo.values) {
          snapTo = toArray(snapTo.values);
  
          if (is2D = !_isNumber(snapTo[0])) {
            radius *= radius;
          }
        } else {
          snapTo = _roundModifier(snapTo.increment);
        }
      }
  
      return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
        is2D = snapTo(raw);
        return Math.abs(is2D - raw) <= radius ? is2D : raw;
      } : function (raw) {
        var x = parseFloat(is2D ? raw.x : raw),
            y = parseFloat(is2D ? raw.y : 0),
            min = _bigNum,
            closest = 0,
            i = snapTo.length,
            dx,
            dy;
  
        while (i--) {
          if (is2D) {
            dx = snapTo[i].x - x;
            dy = snapTo[i].y - y;
            dx = dx * dx + dy * dy;
          } else {
            dx = Math.abs(snapTo[i] - x);
          }
  
          if (dx < min) {
            min = dx;
            closest = i;
          }
        }
  
        closest = !radius || min <= radius ? snapTo[closest] : raw;
        return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
      });
    },
        random = function random(min, max, roundingIncrement, returnFunction) {
      return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
        return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
      });
    },
        pipe = function pipe() {
      for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
        functions[_key] = arguments[_key];
      }
  
      return function (value) {
        return functions.reduce(function (v, f) {
          return f(v);
        }, value);
      };
    },
        unitize = function unitize(func, unit) {
      return function (value) {
        return func(parseFloat(value)) + (unit || getUnit(value));
      };
    },
        normalize = function normalize(min, max, value) {
      return mapRange(min, max, 0, 1, value);
    },
        _wrapArray = function _wrapArray(a, wrapper, value) {
      return _conditionalReturn(value, function (index) {
        return a[~~wrapper(index)];
      });
    },
        wrap = function wrap(min, max, value) {
      var range = max - min;
      return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
        return (range + (value - min) % range) % range + min;
      });
    },
        wrapYoyo = function wrapYoyo(min, max, value) {
      var range = max - min,
          total = range * 2;
      return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
        value = (total + (value - min) % total) % total || 0;
        return min + (value > range ? total - value : value);
      });
    },
        _replaceRandom = function _replaceRandom(value) {
      var prev = 0,
          s = "",
          i,
          nums,
          end,
          isArray;
  
      while (~(i = value.indexOf("random(", prev))) {
        end = value.indexOf(")", i);
        isArray = value.charAt(i + 7) === "[";
        nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
        s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
        prev = end + 1;
      }
  
      return s + value.substr(prev, value.length - prev);
    },
        mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
      var inRange = inMax - inMin,
          outRange = outMax - outMin;
      return _conditionalReturn(value, function (value) {
        return outMin + ((value - inMin) / inRange * outRange || 0);
      });
    },
        interpolate = function interpolate(start, end, progress, mutate) {
      var func = isNaN(start + end) ? 0 : function (p) {
        return (1 - p) * start + p * end;
      };
  
      if (!func) {
        var isString = _isString(start),
            master = {},
            p,
            i,
            interpolators,
            l,
            il;
  
        progress === true && (mutate = 1) && (progress = null);
  
        if (isString) {
          start = {
            p: start
          };
          end = {
            p: end
          };
        } else if (_isArray(start) && !_isArray(end)) {
          interpolators = [];
          l = start.length;
          il = l - 2;
  
          for (i = 1; i < l; i++) {
            interpolators.push(interpolate(start[i - 1], start[i]));
          }
  
          l--;
  
          func = function func(p) {
            p *= l;
            var i = Math.min(il, ~~p);
            return interpolators[i](p - i);
          };
  
          progress = end;
        } else if (!mutate) {
          start = _merge(_isArray(start) ? [] : {}, start);
        }
  
        if (!interpolators) {
          for (p in end) {
            _addPropTween.call(master, start, p, "get", end[p]);
          }
  
          func = function func(p) {
            return _renderPropTweens(p, master) || (isString ? start.p : start);
          };
        }
      }
  
      return _conditionalReturn(progress, func);
    },
        _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
      var labels = timeline.labels,
          min = _bigNum,
          p,
          distance,
          label;
  
      for (p in labels) {
        distance = labels[p] - fromTime;
  
        if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
          label = p;
          min = distance;
        }
      }
  
      return label;
    },
        _callback = function _callback(animation, type, executeLazyFirst) {
      var v = animation.vars,
          callback = v[type],
          prevContext = _context,
          context = animation._ctx,
          params,
          scope,
          result;
  
      if (!callback) {
        return;
      }
  
      params = v[type + "Params"];
      scope = v.callbackScope || animation;
      executeLazyFirst && _lazyTweens.length && _lazyRender();
      context && (_context = context);
      result = params ? callback.apply(scope, params) : callback.call(scope);
      _context = prevContext;
      return result;
    },
        _interrupt = function _interrupt(animation) {
      _removeFromParent(animation);
  
      animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
      animation.progress() < 1 && _callback(animation, "onInterrupt");
      return animation;
    },
        _quickTween,
        _createPlugin = function _createPlugin(config) {
      config = !config.name && config["default"] || config;
  
      var name = config.name,
          isFunc = _isFunction(config),
          Plugin = name && !isFunc && config.init ? function () {
        this._props = [];
      } : config,
          instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      },
          statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
  
      _wake();
  
      if (config !== Plugin) {
        if (_plugins[name]) {
          return;
        }
  
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
  
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
  
        _plugins[Plugin.prop = name] = Plugin;
  
        if (config.targetTest) {
          _harnessPlugins.push(Plugin);
  
          _reservedProps[name] = 1;
        }
  
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
  
      _addGlobal(name, Plugin);
  
      config.register && config.register(gsap, Plugin, PropTween);
    },
        _255 = 255,
        _colorLookup = {
      aqua: [0, _255, _255],
      lime: [0, _255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, _255],
      navy: [0, 0, 128],
      white: [_255, _255, _255],
      olive: [128, 128, 0],
      yellow: [_255, _255, 0],
      orange: [_255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [_255, 0, 0],
      pink: [_255, 192, 203],
      cyan: [0, _255, _255],
      transparent: [_255, _255, _255, 0]
    },
        _hue = function _hue(h, m1, m2) {
      h += h < 0 ? 1 : h > 1 ? -1 : 0;
      return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
    },
        splitColor = function splitColor(v, toHSL, forceAlpha) {
      var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
          r,
          g,
          b,
          h,
          s,
          l,
          max,
          min,
          d,
          wasHSL;
  
      if (!a) {
        if (v.substr(-1) === ",") {
          v = v.substr(0, v.length - 1);
        }
  
        if (_colorLookup[v]) {
          a = _colorLookup[v];
        } else if (v.charAt(0) === "#") {
          if (v.length < 6) {
            r = v.charAt(1);
            g = v.charAt(2);
            b = v.charAt(3);
            v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
          }
  
          if (v.length === 9) {
            a = parseInt(v.substr(1, 6), 16);
            return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
          }
  
          v = parseInt(v.substr(1), 16);
          a = [v >> 16, v >> 8 & _255, v & _255];
        } else if (v.substr(0, 3) === "hsl") {
          a = wasHSL = v.match(_strictNumExp);
  
          if (!toHSL) {
            h = +a[0] % 360 / 360;
            s = +a[1] / 100;
            l = +a[2] / 100;
            g = l <= .5 ? l * (s + 1) : l + s - l * s;
            r = l * 2 - g;
            a.length > 3 && (a[3] *= 1);
            a[0] = _hue(h + 1 / 3, r, g);
            a[1] = _hue(h, r, g);
            a[2] = _hue(h - 1 / 3, r, g);
          } else if (~v.indexOf("=")) {
            a = v.match(_numExp);
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
          }
        } else {
          a = v.match(_strictNumExp) || _colorLookup.transparent;
        }
  
        a = a.map(Number);
      }
  
      if (toHSL && !wasHSL) {
        r = a[0] / _255;
        g = a[1] / _255;
        b = a[2] / _255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        l = (max + min) / 2;
  
        if (max === min) {
          h = s = 0;
        } else {
          d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
          h *= 60;
        }
  
        a[0] = ~~(h + .5);
        a[1] = ~~(s * 100 + .5);
        a[2] = ~~(l * 100 + .5);
      }
  
      forceAlpha && a.length < 4 && (a[3] = 1);
      return a;
    },
        _colorOrderData = function _colorOrderData(v) {
      var values = [],
          c = [],
          i = -1;
      v.split(_colorExp).forEach(function (v) {
        var a = v.match(_numWithUnitExp) || [];
        values.push.apply(values, a);
        c.push(i += a.length + 1);
      });
      values.c = c;
      return values;
    },
        _formatColors = function _formatColors(s, toHSL, orderMatchData) {
      var result = "",
          colors = (s + result).match(_colorExp),
          type = toHSL ? "hsla(" : "rgba(",
          i = 0,
          c,
          shell,
          d,
          l;
  
      if (!colors) {
        return s;
      }
  
      colors = colors.map(function (color) {
        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
      });
  
      if (orderMatchData) {
        d = _colorOrderData(s);
        c = orderMatchData.c;
  
        if (c.join(result) !== d.c.join(result)) {
          shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
          l = shell.length - 1;
  
          for (; i < l; i++) {
            result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
          }
        }
      }
  
      if (!shell) {
        shell = s.split(_colorExp);
        l = shell.length - 1;
  
        for (; i < l; i++) {
          result += shell[i] + colors[i];
        }
      }
  
      return result + shell[l];
    },
        _colorExp = function () {
      var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
          p;
  
      for (p in _colorLookup) {
        s += "|" + p + "\\b";
      }
  
      return new RegExp(s + ")", "gi");
    }(),
        _hslExp = /hsl[a]?\(/,
        _colorStringFilter = function _colorStringFilter(a) {
      var combined = a.join(" "),
          toHSL;
      _colorExp.lastIndex = 0;
  
      if (_colorExp.test(combined)) {
        toHSL = _hslExp.test(combined);
        a[1] = _formatColors(a[1], toHSL);
        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
        return true;
      }
    },
        _tickerActive,
        _ticker = function () {
      var _getTime = Date.now,
          _lagThreshold = 500,
          _adjustedLag = 33,
          _startTime = _getTime(),
          _lastUpdate = _startTime,
          _gap = 1000 / 240,
          _nextTime = _gap,
          _listeners = [],
          _id,
          _req,
          _raf,
          _self,
          _delta,
          _i,
          _tick = function _tick(v) {
        var elapsed = _getTime() - _lastUpdate,
            manual = v === true,
            overlap,
            dispatch,
            time,
            frame;
  
        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;
  
        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1000;
          _self.time = time = time / 1000;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }
  
        manual || (_id = _req(_tick));
  
        if (dispatch) {
          for (_i = 0; _i < _listeners.length; _i++) {
            _listeners[_i](time, _delta, frame, v);
          }
        }
      };
  
      _self = {
        time: 0,
        frame: 0,
        tick: function tick() {
          _tick(true);
        },
        deltaRatio: function deltaRatio(fps) {
          return _delta / (1000 / (fps || 60));
        },
        wake: function wake() {
          if (_coreReady) {
            if (!_coreInitted && _windowExists()) {
              _win = _coreInitted = window;
              _doc = _win.document || {};
              _globals.gsap = gsap;
              (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
  
              _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
  
              _raf = _win.requestAnimationFrame;
            }
  
            _id && _self.sleep();
  
            _req = _raf || function (f) {
              return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
            };
  
            _tickerActive = 1;
  
            _tick(2);
          }
        },
        sleep: function sleep() {
          (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
          _tickerActive = 0;
          _req = _emptyFunc;
        },
        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
          _lagThreshold = threshold || Infinity;
          _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
        },
        fps: function fps(_fps) {
          _gap = 1000 / (_fps || 240);
          _nextTime = _self.time * 1000 + _gap;
        },
        add: function add(callback, once, prioritize) {
          var func = once ? function (t, d, f, v) {
            callback(t, d, f, v);
  
            _self.remove(func);
          } : callback;
  
          _self.remove(callback);
  
          _listeners[prioritize ? "unshift" : "push"](func);
  
          _wake();
  
          return func;
        },
        remove: function remove(callback, i) {
          ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
        },
        _listeners: _listeners
      };
      return _self;
    }(),
        _wake = function _wake() {
      return !_tickerActive && _ticker.wake();
    },
        _easeMap = {},
        _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
        _quotesExp = /["']/g,
        _parseObjectInString = function _parseObjectInString(value) {
      var obj = {},
          split = value.substr(1, value.length - 3).split(":"),
          key = split[0],
          i = 1,
          l = split.length,
          index,
          val,
          parsedVal;
  
      for (; i < l; i++) {
        val = split[i];
        index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
        parsedVal = val.substr(0, index);
        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
        key = val.substr(index + 1).trim();
      }
  
      return obj;
    },
        _valueInParentheses = function _valueInParentheses(value) {
      var open = value.indexOf("(") + 1,
          close = value.indexOf(")"),
          nested = value.indexOf("(", open);
      return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
    },
        _configEaseFromString = function _configEaseFromString(name) {
      var split = (name + "").split("("),
          ease = _easeMap[split[0]];
      return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
    },
        _invertEase = function _invertEase(ease) {
      return function (p) {
        return 1 - ease(1 - p);
      };
    },
        _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
      var child = timeline._first,
          ease;
  
      while (child) {
        if (child instanceof Timeline) {
          _propagateYoyoEase(child, isYoyo);
        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
          if (child.timeline) {
            _propagateYoyoEase(child.timeline, isYoyo);
          } else {
            ease = child._ease;
            child._ease = child._yEase;
            child._yEase = ease;
            child._yoyo = isYoyo;
          }
        }
  
        child = child._next;
      }
    },
        _parseEase = function _parseEase(ease, defaultEase) {
      return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
    },
        _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
      if (easeOut === void 0) {
        easeOut = function easeOut(p) {
          return 1 - easeIn(1 - p);
        };
      }
  
      if (easeInOut === void 0) {
        easeInOut = function easeInOut(p) {
          return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
        };
      }
  
      var ease = {
        easeIn: easeIn,
        easeOut: easeOut,
        easeInOut: easeInOut
      },
          lowercaseName;
  
      _forEachName(names, function (name) {
        _easeMap[name] = _globals[name] = ease;
        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
  
        for (var p in ease) {
          _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
        }
      });
  
      return ease;
    },
        _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
      return function (p) {
        return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
      };
    },
        _configElastic = function _configElastic(type, amplitude, period) {
      var p1 = amplitude >= 1 ? amplitude : 1,
          p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
          p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
          easeOut = function easeOut(p) {
        return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
      },
          ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
  
      p2 = _2PI / p2;
  
      ease.config = function (amplitude, period) {
        return _configElastic(type, amplitude, period);
      };
  
      return ease;
    },
        _configBack = function _configBack(type, overshoot) {
      if (overshoot === void 0) {
        overshoot = 1.70158;
      }
  
      var easeOut = function easeOut(p) {
        return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
      },
          ease = type === "out" ? easeOut : type === "in" ? function (p) {
        return 1 - easeOut(1 - p);
      } : _easeInOutFromOut(easeOut);
  
      ease.config = function (overshoot) {
        return _configBack(type, overshoot);
      };
  
      return ease;
    };
  
    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
      var power = i < 5 ? i + 1 : i;
  
      _insertEase(name + ",Power" + (power - 1), i ? function (p) {
        return Math.pow(p, power);
      } : function (p) {
        return p;
      }, function (p) {
        return 1 - Math.pow(1 - p, power);
      }, function (p) {
        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
      });
    });
  
    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  
    _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  
    (function (n, c) {
      var n1 = 1 / c,
          n2 = 2 * n1,
          n3 = 2.5 * n1,
          easeOut = function easeOut(p) {
        return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
      };
  
      _insertEase("Bounce", function (p) {
        return 1 - easeOut(1 - p);
      }, easeOut);
    })(7.5625, 2.75);
  
    _insertEase("Expo", function (p) {
      return p ? Math.pow(2, 10 * (p - 1)) : 0;
    });
  
    _insertEase("Circ", function (p) {
      return -(_sqrt(1 - p * p) - 1);
    });
  
    _insertEase("Sine", function (p) {
      return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
    });
  
    _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  
    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
      config: function config(steps, immediateStart) {
        if (steps === void 0) {
          steps = 1;
        }
  
        var p1 = 1 / steps,
            p2 = steps + (immediateStart ? 0 : 1),
            p3 = immediateStart ? 1 : 0,
            max = 1 - _tinyNum;
        return function (p) {
          return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
        };
      }
    };
    _defaults.ease = _easeMap["quad.out"];
  
    _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
      return _callbackNames += name + "," + name + "Params,";
    });
  
    var GSCache = function GSCache(target, harness) {
      this.id = _gsID++;
      target._gsap = this;
      this.target = target;
      this.harness = harness;
      this.get = harness ? harness.get : _getProperty;
      this.set = harness ? harness.getSetter : _getSetter;
    };
    var Animation = function () {
      function Animation(vars) {
        this.vars = vars;
        this._delay = +vars.delay || 0;
  
        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
          this._rDelay = vars.repeatDelay || 0;
          this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
        }
  
        this._ts = 1;
  
        _setDuration(this, +vars.duration, 1, 1);
  
        this.data = vars.data;
  
        if (_context) {
          this._ctx = _context;
  
          _context.data.push(this);
        }
  
        _tickerActive || _ticker.wake();
      }
  
      var _proto = Animation.prototype;
  
      _proto.delay = function delay(value) {
        if (value || value === 0) {
          this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
          this._delay = value;
          return this;
        }
  
        return this._delay;
      };
  
      _proto.duration = function duration(value) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
      };
  
      _proto.totalDuration = function totalDuration(value) {
        if (!arguments.length) {
          return this._tDur;
        }
  
        this._dirty = 0;
        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
      };
  
      _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
        _wake();
  
        if (!arguments.length) {
          return this._tTime;
        }
  
        var parent = this._dp;
  
        if (parent && parent.smoothChildTiming && this._ts) {
          _alignPlayhead(this, _totalTime);
  
          !parent._dp || parent.parent || _postAddChecks(parent, this);
  
          while (parent && parent.parent) {
            if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
              parent.totalTime(parent._tTime, true);
            }
  
            parent = parent.parent;
          }
  
          if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
            _addToTimeline(this._dp, this, this._start - this._delay);
          }
        }
  
        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
          this._ts || (this._pTime = _totalTime);
  
          _lazySafeRender(this, _totalTime, suppressEvents);
        }
  
        return this;
      };
  
      _proto.time = function time(value, suppressEvents) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
      };
  
      _proto.totalProgress = function totalProgress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
      };
  
      _proto.progress = function progress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
      };
  
      _proto.iteration = function iteration(value, suppressEvents) {
        var cycleDuration = this.duration() + this._rDelay;
  
        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
      };
  
      _proto.timeScale = function timeScale(value) {
        if (!arguments.length) {
          return this._rts === -_tinyNum ? 0 : this._rts;
        }
  
        if (this._rts === value) {
          return this;
        }
  
        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
        this._rts = +value || 0;
        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
        this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);
  
        _setEnd(this);
  
        return _recacheAncestors(this);
      };
  
      _proto.paused = function paused(value) {
        if (!arguments.length) {
          return this._ps;
        }
  
        if (this._ps !== value) {
          this._ps = value;
  
          if (value) {
            this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
            this._ts = this._act = 0;
          } else {
            _wake();
  
            this._ts = this._rts;
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
          }
        }
  
        return this;
      };
  
      _proto.startTime = function startTime(value) {
        if (arguments.length) {
          this._start = value;
          var parent = this.parent || this._dp;
          parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
          return this;
        }
  
        return this._start;
      };
  
      _proto.endTime = function endTime(includeRepeats) {
        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
      };
  
      _proto.rawTime = function rawTime(wrapRepeats) {
        var parent = this.parent || this._dp;
        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
      };
  
      _proto.revert = function revert(config) {
        if (config === void 0) {
          config = _revertConfig;
        }
  
        var prevIsReverting = _reverting;
        _reverting = config;
  
        if (this._initted || this._startAt) {
          this.timeline && this.timeline.revert(config);
          this.totalTime(-0.01, config.suppressEvents);
        }
  
        this.data !== "nested" && config.kill !== false && this.kill();
        _reverting = prevIsReverting;
        return this;
      };
  
      _proto.globalTime = function globalTime(rawTime) {
        var animation = this,
            time = arguments.length ? rawTime : animation.rawTime();
  
        while (animation) {
          time = animation._start + time / (animation._ts || 1);
          animation = animation._dp;
        }
  
        return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(rawTime) : time;
      };
  
      _proto.repeat = function repeat(value) {
        if (arguments.length) {
          this._repeat = value === Infinity ? -2 : value;
          return _onUpdateTotalDuration(this);
        }
  
        return this._repeat === -2 ? Infinity : this._repeat;
      };
  
      _proto.repeatDelay = function repeatDelay(value) {
        if (arguments.length) {
          var time = this._time;
          this._rDelay = value;
  
          _onUpdateTotalDuration(this);
  
          return time ? this.time(time) : this;
        }
  
        return this._rDelay;
      };
  
      _proto.yoyo = function yoyo(value) {
        if (arguments.length) {
          this._yoyo = value;
          return this;
        }
  
        return this._yoyo;
      };
  
      _proto.seek = function seek(position, suppressEvents) {
        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
      };
  
      _proto.restart = function restart(includeDelay, suppressEvents) {
        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      };
  
      _proto.play = function play(from, suppressEvents) {
        from != null && this.seek(from, suppressEvents);
        return this.reversed(false).paused(false);
      };
  
      _proto.reverse = function reverse(from, suppressEvents) {
        from != null && this.seek(from || this.totalDuration(), suppressEvents);
        return this.reversed(true).paused(false);
      };
  
      _proto.pause = function pause(atTime, suppressEvents) {
        atTime != null && this.seek(atTime, suppressEvents);
        return this.paused(true);
      };
  
      _proto.resume = function resume() {
        return this.paused(false);
      };
  
      _proto.reversed = function reversed(value) {
        if (arguments.length) {
          !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
          return this;
        }
  
        return this._rts < 0;
      };
  
      _proto.invalidate = function invalidate() {
        this._initted = this._act = 0;
        this._zTime = -_tinyNum;
        return this;
      };
  
      _proto.isActive = function isActive() {
        var parent = this.parent || this._dp,
            start = this._start,
            rawTime;
        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
      };
  
      _proto.eventCallback = function eventCallback(type, callback, params) {
        var vars = this.vars;
  
        if (arguments.length > 1) {
          if (!callback) {
            delete vars[type];
          } else {
            vars[type] = callback;
            params && (vars[type + "Params"] = params);
            type === "onUpdate" && (this._onUpdate = callback);
          }
  
          return this;
        }
  
        return vars[type];
      };
  
      _proto.then = function then(onFulfilled) {
        var self = this;
        return new Promise(function (resolve) {
          var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
              _resolve = function _resolve() {
            var _then = self.then;
            self.then = null;
            _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
            resolve(f);
            self.then = _then;
          };
  
          if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
            _resolve();
          } else {
            self._prom = _resolve;
          }
        });
      };
  
      _proto.kill = function kill() {
        _interrupt(this);
      };
  
      return Animation;
    }();
  
    _setDefaults(Animation.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -_tinyNum,
      _prom: 0,
      _ps: false,
      _rts: 1
    });
  
    var Timeline = function (_Animation) {
      _inheritsLoose(Timeline, _Animation);
  
      function Timeline(vars, position) {
        var _this;
  
        if (vars === void 0) {
          vars = {};
        }
  
        _this = _Animation.call(this, vars) || this;
        _this.labels = {};
        _this.smoothChildTiming = !!vars.smoothChildTiming;
        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
        _this._sort = _isNotFalse(vars.sortChildren);
        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
        vars.reversed && _this.reverse();
        vars.paused && _this.paused(true);
        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
        return _this;
      }
  
      var _proto2 = Timeline.prototype;
  
      _proto2.to = function to(targets, vars, position) {
        _createTweenType(0, arguments, this);
  
        return this;
      };
  
      _proto2.from = function from(targets, vars, position) {
        _createTweenType(1, arguments, this);
  
        return this;
      };
  
      _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
        _createTweenType(2, arguments, this);
  
        return this;
      };
  
      _proto2.set = function set(targets, vars, position) {
        vars.duration = 0;
        vars.parent = this;
        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
        vars.immediateRender = !!vars.immediateRender;
        new Tween(targets, vars, _parsePosition(this, position), 1);
        return this;
      };
  
      _proto2.call = function call(callback, params, position) {
        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
      };
  
      _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.duration = duration;
        vars.stagger = vars.stagger || stagger;
        vars.onComplete = onCompleteAll;
        vars.onCompleteParams = onCompleteAllParams;
        vars.parent = this;
        new Tween(targets, vars, _parsePosition(this, position));
        return this;
      };
  
      _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.runBackwards = 1;
        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
  
      _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
        toVars.startAt = fromVars;
        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
  
      _proto2.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time,
            tDur = this._dirty ? this.totalDuration() : this._tDur,
            dur = this._dur,
            tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
            crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
            time,
            child,
            next,
            iteration,
            cycleDuration,
            prevPaused,
            pauseTween,
            timeScale,
            prevStart,
            prevIteration,
            yoyo,
            isYoyo;
        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
  
        if (tTime !== this._tTime || force || crossingStart) {
          if (prevTime !== this._time && dur) {
            tTime += this._time - prevTime;
            totalTime += this._time - prevTime;
          }
  
          time = tTime;
          prevStart = this._start;
          timeScale = this._ts;
          prevPaused = !timeScale;
  
          if (crossingStart) {
            dur || (prevTime = this._zTime);
            (totalTime || !suppressEvents) && (this._zTime = totalTime);
          }
  
          if (this._repeat) {
            yoyo = this._yoyo;
            cycleDuration = dur + this._rDelay;
  
            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
  
            time = _roundPrecise(tTime % cycleDuration);
  
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
  
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
  
              time > dur && (time = dur);
            }
  
            prevIteration = _animationCycle(this._tTime, cycleDuration);
            !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration);
  
            if (yoyo && iteration & 1) {
              time = dur - time;
              isYoyo = 1;
            }
  
            if (iteration !== prevIteration && !this._lock) {
              var rewinding = yoyo && prevIteration & 1,
                  doesWrap = rewinding === (yoyo && iteration & 1);
              iteration < prevIteration && (rewinding = !rewinding);
              prevTime = rewinding ? 0 : dur;
              this._lock = 1;
              this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
              this._tTime = tTime;
              !suppressEvents && this.parent && _callback(this, "onRepeat");
              this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
  
              if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                return this;
              }
  
              dur = this._dur;
              tDur = this._tDur;
  
              if (doesWrap) {
                this._lock = 2;
                prevTime = rewinding ? dur : -0.0001;
                this.render(prevTime, true);
                this.vars.repeatRefresh && !isYoyo && this.invalidate();
              }
  
              this._lock = 0;
  
              if (!this._ts && !prevPaused) {
                return this;
              }
  
              _propagateYoyoEase(this, isYoyo);
            }
          }
  
          if (this._hasPause && !this._forcing && this._lock < 2) {
            pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
  
            if (pauseTween) {
              tTime -= time - (time = pauseTween._start);
            }
          }
  
          this._tTime = tTime;
          this._time = time;
          this._act = !timeScale;
  
          if (!this._initted) {
            this._onUpdate = this.vars.onUpdate;
            this._initted = 1;
            this._zTime = totalTime;
            prevTime = 0;
          }
  
          if (!prevTime && time && !suppressEvents) {
            _callback(this, "onStart");
  
            if (this._tTime !== tTime) {
              return this;
            }
          }
  
          if (time >= prevTime && totalTime >= 0) {
            child = this._first;
  
            while (child) {
              next = child._next;
  
              if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
  
                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
  
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next && (tTime += this._zTime = -_tinyNum);
                  break;
                }
              }
  
              child = next;
            }
          } else {
            child = this._last;
            var adjustedTime = totalTime < 0 ? totalTime : time;
  
            while (child) {
              next = child._prev;
  
              if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
  
                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
  
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                  break;
                }
              }
  
              child = next;
            }
          }
  
          if (pauseTween && !suppressEvents) {
            this.pause();
            pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
  
            if (this._ts) {
              this._start = prevStart;
  
              _setEnd(this);
  
              return this.render(totalTime, suppressEvents, force);
            }
          }
  
          this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
          if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
  
            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
              _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
  
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
  
        return this;
      };
  
      _proto2.add = function add(child, position) {
        var _this2 = this;
  
        _isNumber(position) || (position = _parsePosition(this, position, child));
  
        if (!(child instanceof Animation)) {
          if (_isArray(child)) {
            child.forEach(function (obj) {
              return _this2.add(obj, position);
            });
            return this;
          }
  
          if (_isString(child)) {
            return this.addLabel(child, position);
          }
  
          if (_isFunction(child)) {
            child = Tween.delayedCall(0, child);
          } else {
            return this;
          }
        }
  
        return this !== child ? _addToTimeline(this, child, position) : this;
      };
  
      _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
        if (nested === void 0) {
          nested = true;
        }
  
        if (tweens === void 0) {
          tweens = true;
        }
  
        if (timelines === void 0) {
          timelines = true;
        }
  
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = -_bigNum;
        }
  
        var a = [],
            child = this._first;
  
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            if (child instanceof Tween) {
              tweens && a.push(child);
            } else {
              timelines && a.push(child);
              nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
            }
          }
  
          child = child._next;
        }
  
        return a;
      };
  
      _proto2.getById = function getById(id) {
        var animations = this.getChildren(1, 1, 1),
            i = animations.length;
  
        while (i--) {
          if (animations[i].vars.id === id) {
            return animations[i];
          }
        }
      };
  
      _proto2.remove = function remove(child) {
        if (_isString(child)) {
          return this.removeLabel(child);
        }
  
        if (_isFunction(child)) {
          return this.killTweensOf(child);
        }
  
        _removeLinkedListItem(this, child);
  
        if (child === this._recent) {
          this._recent = this._last;
        }
  
        return _uncache(this);
      };
  
      _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
        if (!arguments.length) {
          return this._tTime;
        }
  
        this._forcing = 1;
  
        if (!this._dp && this._ts) {
          this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
        }
  
        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
  
        this._forcing = 0;
        return this;
      };
  
      _proto2.addLabel = function addLabel(label, position) {
        this.labels[label] = _parsePosition(this, position);
        return this;
      };
  
      _proto2.removeLabel = function removeLabel(label) {
        delete this.labels[label];
        return this;
      };
  
      _proto2.addPause = function addPause(position, callback, params) {
        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
        t.data = "isPause";
        this._hasPause = 1;
        return _addToTimeline(this, t, _parsePosition(this, position));
      };
  
      _proto2.removePause = function removePause(position) {
        var child = this._first;
        position = _parsePosition(this, position);
  
        while (child) {
          if (child._start === position && child.data === "isPause") {
            _removeFromParent(child);
          }
  
          child = child._next;
        }
      };
  
      _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        var tweens = this.getTweensOf(targets, onlyActive),
            i = tweens.length;
  
        while (i--) {
          _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
        }
  
        return this;
      };
  
      _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
        var a = [],
            parsedTargets = toArray(targets),
            child = this._first,
            isGlobalTime = _isNumber(onlyActive),
            children;
  
        while (child) {
          if (child instanceof Tween) {
            if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
              a.push(child);
            }
          } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
            a.push.apply(a, children);
          }
  
          child = child._next;
        }
  
        return a;
      };
  
      _proto2.tweenTo = function tweenTo(position, vars) {
        vars = vars || {};
  
        var tl = this,
            endTime = _parsePosition(tl, position),
            _vars = vars,
            startAt = _vars.startAt,
            _onStart = _vars.onStart,
            onStartParams = _vars.onStartParams,
            immediateRender = _vars.immediateRender,
            initted,
            tween = Tween.to(tl, _setDefaults({
          ease: vars.ease || "none",
          lazy: false,
          immediateRender: false,
          time: endTime,
          overwrite: "auto",
          duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
          onStart: function onStart() {
            tl.pause();
  
            if (!initted) {
              var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
              tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
              initted = 1;
            }
  
            _onStart && _onStart.apply(tween, onStartParams || []);
          }
        }, vars));
  
        return immediateRender ? tween.render(0) : tween;
      };
  
      _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
        return this.tweenTo(toPosition, _setDefaults({
          startAt: {
            time: _parsePosition(this, fromPosition)
          }
        }, vars));
      };
  
      _proto2.recent = function recent() {
        return this._recent;
      };
  
      _proto2.nextLabel = function nextLabel(afterTime) {
        if (afterTime === void 0) {
          afterTime = this._time;
        }
  
        return _getLabelInDirection(this, _parsePosition(this, afterTime));
      };
  
      _proto2.previousLabel = function previousLabel(beforeTime) {
        if (beforeTime === void 0) {
          beforeTime = this._time;
        }
  
        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
      };
  
      _proto2.currentLabel = function currentLabel(value) {
        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
      };
  
      _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = 0;
        }
  
        var child = this._first,
            labels = this.labels,
            p;
  
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            child._start += amount;
            child._end += amount;
          }
  
          child = child._next;
        }
  
        if (adjustLabels) {
          for (p in labels) {
            if (labels[p] >= ignoreBeforeTime) {
              labels[p] += amount;
            }
          }
        }
  
        return _uncache(this);
      };
  
      _proto2.invalidate = function invalidate(soft) {
        var child = this._first;
        this._lock = 0;
  
        while (child) {
          child.invalidate(soft);
          child = child._next;
        }
  
        return _Animation.prototype.invalidate.call(this, soft);
      };
  
      _proto2.clear = function clear(includeLabels) {
        if (includeLabels === void 0) {
          includeLabels = true;
        }
  
        var child = this._first,
            next;
  
        while (child) {
          next = child._next;
          this.remove(child);
          child = next;
        }
  
        this._dp && (this._time = this._tTime = this._pTime = 0);
        includeLabels && (this.labels = {});
        return _uncache(this);
      };
  
      _proto2.totalDuration = function totalDuration(value) {
        var max = 0,
            self = this,
            child = self._last,
            prevStart = _bigNum,
            prev,
            start,
            parent;
  
        if (arguments.length) {
          return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
        }
  
        if (self._dirty) {
          parent = self.parent;
  
          while (child) {
            prev = child._prev;
            child._dirty && child.totalDuration();
            start = child._start;
  
            if (start > prevStart && self._sort && child._ts && !self._lock) {
              self._lock = 1;
              _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
            } else {
              prevStart = start;
            }
  
            if (start < 0 && child._ts) {
              max -= start;
  
              if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                self._start += start / self._ts;
                self._time -= start;
                self._tTime -= start;
              }
  
              self.shiftChildren(-start, false, -1e999);
              prevStart = 0;
            }
  
            child._end > max && child._ts && (max = child._end);
            child = prev;
          }
  
          _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
  
          self._dirty = 0;
        }
  
        return self._tDur;
      };
  
      Timeline.updateRoot = function updateRoot(time) {
        if (_globalTimeline._ts) {
          _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
  
          _lastRenderedFrame = _ticker.frame;
        }
  
        if (_ticker.frame >= _nextGCFrame) {
          _nextGCFrame += _config.autoSleep || 120;
          var child = _globalTimeline._first;
          if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
  
            child || _ticker.sleep();
          }
        }
      };
  
      return Timeline;
    }(Animation);
  
    _setDefaults(Timeline.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
    });
  
    var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
      var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
          index = 0,
          matchIndex = 0,
          result,
          startNums,
          color,
          endNum,
          chunk,
          startNum,
          hasRandom,
          a;
      pt.b = start;
      pt.e = end;
      start += "";
      end += "";
  
      if (hasRandom = ~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
  
      if (stringFilter) {
        a = [start, end];
        stringFilter(a, target, prop);
        start = a[0];
        end = a[1];
      }
  
      startNums = start.match(_complexStringNumExp) || [];
  
      while (result = _complexStringNumExp.exec(end)) {
        endNum = result[0];
        chunk = end.substring(index, result.index);
  
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(") {
          color = 1;
        }
  
        if (endNum !== startNums[matchIndex++]) {
          startNum = parseFloat(startNums[matchIndex - 1]) || 0;
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            s: startNum,
            c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
            m: color && color < 4 ? Math.round : 0
          };
          index = _complexStringNumExp.lastIndex;
        }
      }
  
      pt.c = index < end.length ? end.substring(index, end.length) : "";
      pt.fp = funcParam;
  
      if (_relExp.test(end) || hasRandom) {
        pt.e = 0;
      }
  
      this._pt = pt;
      return pt;
    },
        _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
      _isFunction(end) && (end = end(index || 0, target, targets));
      var currentValue = target[prop],
          parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
          setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
          pt;
  
      if (_isString(end)) {
        if (~end.indexOf("random(")) {
          end = _replaceRandom(end);
        }
  
        if (end.charAt(1) === "=") {
          pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
  
          if (pt || pt === 0) {
            end = pt;
          }
        }
      }
  
      if (!optional || parsedStart !== end || _forceAllPropTweens) {
        if (!isNaN(parsedStart * end) && end !== "") {
          pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
          funcParam && (pt.fp = funcParam);
          modifier && pt.modifier(modifier, this, target);
          return this._pt = pt;
        }
  
        !currentValue && !(prop in target) && _missingPlugin(prop, end);
        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
      }
    },
        _processVars = function _processVars(vars, index, target, targets, tween) {
      _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
  
      if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
        return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
      }
  
      var copy = {},
          p;
  
      for (p in vars) {
        copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
      }
  
      return copy;
    },
        _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
      var plugin, pt, ptLookup, i;
  
      if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
  
        if (tween !== _quickTween) {
          ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
          i = plugin._props.length;
  
          while (i--) {
            ptLookup[plugin._props[i]] = pt;
          }
        }
      }
  
      return plugin;
    },
        _overwritingTween,
        _forceAllPropTweens,
        _initTween = function _initTween(tween, time, tTime) {
      var vars = tween.vars,
          ease = vars.ease,
          startAt = vars.startAt,
          immediateRender = vars.immediateRender,
          lazy = vars.lazy,
          onUpdate = vars.onUpdate,
          onUpdateParams = vars.onUpdateParams,
          callbackScope = vars.callbackScope,
          runBackwards = vars.runBackwards,
          yoyoEase = vars.yoyoEase,
          keyframes = vars.keyframes,
          autoRevert = vars.autoRevert,
          dur = tween._dur,
          prevStartAt = tween._startAt,
          targets = tween._targets,
          parent = tween.parent,
          fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
          autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
          tl = tween.timeline,
          cleanVars,
          i,
          p,
          pt,
          target,
          hasPriority,
          gsData,
          harness,
          plugin,
          ptLookup,
          index,
          harnessVars,
          overwritten;
      tl && (!keyframes || !ease) && (ease = "none");
      tween._ease = _parseEase(ease, _defaults.ease);
      tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
  
      if (yoyoEase && tween._yoyo && !tween._repeat) {
        yoyoEase = tween._yEase;
        tween._yEase = tween._ease;
        tween._ease = yoyoEase;
      }
  
      tween._from = !tl && !!vars.runBackwards;
  
      if (!tl || keyframes && !vars.stagger) {
        harness = targets[0] ? _getCache(targets[0]).harness : 0;
        harnessVars = harness && vars[harness.prop];
        cleanVars = _copyExcluding(vars, _reservedProps);
  
        if (prevStartAt) {
          prevStartAt._zTime < 0 && prevStartAt.progress(1);
          time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
          prevStartAt._lazy = 0;
        }
  
        if (startAt) {
          _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
            data: "isStart",
            overwrite: false,
            parent: parent,
            immediateRender: true,
            lazy: !prevStartAt && _isNotFalse(lazy),
            startAt: null,
            delay: 0,
            onUpdate: onUpdate,
            onUpdateParams: onUpdateParams,
            callbackScope: callbackScope,
            stagger: 0
          }, startAt)));
  
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
  
          if (immediateRender) {
            if (dur && time <= 0 && tTime <= 0) {
              time && (tween._zTime = time);
              return;
            }
          }
        } else if (runBackwards && dur) {
          if (!prevStartAt) {
            time && (immediateRender = false);
            p = _setDefaults({
              overwrite: false,
              data: "isFromStart",
              lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
              immediateRender: immediateRender,
              stagger: 0,
              parent: parent
            }, cleanVars);
            harnessVars && (p[harness.prop] = harnessVars);
  
            _removeFromParent(tween._startAt = Tween.set(targets, p));
  
            tween._startAt._dp = 0;
            tween._startAt._sat = tween;
            time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
            tween._zTime = time;
  
            if (!immediateRender) {
              _initTween(tween._startAt, _tinyNum, _tinyNum);
            } else if (!time) {
              return;
            }
          }
        }
  
        tween._pt = tween._ptCache = 0;
        lazy = dur && _isNotFalse(lazy) || lazy && !dur;
  
        for (i = 0; i < targets.length; i++) {
          target = targets[i];
          gsData = target._gsap || _harness(targets)[i]._gsap;
          tween._ptLookup[i] = ptLookup = {};
          _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
          index = fullTargets === targets ? i : fullTargets.indexOf(target);
  
          if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
            tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
  
            plugin._props.forEach(function (name) {
              ptLookup[name] = pt;
            });
  
            plugin.priority && (hasPriority = 1);
          }
  
          if (!harness || harnessVars) {
            for (p in cleanVars) {
              if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
                plugin.priority && (hasPriority = 1);
              } else {
                ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
              }
            }
          }
  
          tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
  
          if (autoOverwrite && tween._pt) {
            _overwritingTween = tween;
  
            _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
  
            overwritten = !tween.parent;
            _overwritingTween = 0;
          }
  
          tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
        }
  
        hasPriority && _sortPropTweensByPriority(tween);
        tween._onInit && tween._onInit(tween);
      }
  
      tween._onUpdate = onUpdate;
      tween._initted = (!tween._op || tween._pt) && !overwritten;
      keyframes && time <= 0 && tl.render(_bigNum, true, true);
    },
        _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
      var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
          pt,
          rootPT,
          lookup,
          i;
  
      if (!ptCache) {
        ptCache = tween._ptCache[property] = [];
        lookup = tween._ptLookup;
        i = tween._targets.length;
  
        while (i--) {
          pt = lookup[i][property];
  
          if (pt && pt.d && pt.d._pt) {
            pt = pt.d._pt;
  
            while (pt && pt.p !== property && pt.fp !== property) {
              pt = pt._next;
            }
          }
  
          if (!pt) {
            _forceAllPropTweens = 1;
            tween.vars[property] = "+=0";
  
            _initTween(tween, time);
  
            _forceAllPropTweens = 0;
            return 1;
          }
  
          ptCache.push(pt);
        }
      }
  
      i = ptCache.length;
  
      while (i--) {
        rootPT = ptCache[i];
        pt = rootPT._pt || rootPT;
        pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
        pt.c = value - pt.s;
        rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
        rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
      }
    },
        _addAliasesToVars = function _addAliasesToVars(targets, vars) {
      var harness = targets[0] ? _getCache(targets[0]).harness : 0,
          propertyAliases = harness && harness.aliases,
          copy,
          p,
          i,
          aliases;
  
      if (!propertyAliases) {
        return vars;
      }
  
      copy = _merge({}, vars);
  
      for (p in propertyAliases) {
        if (p in copy) {
          aliases = propertyAliases[p].split(",");
          i = aliases.length;
  
          while (i--) {
            copy[aliases[i]] = copy[p];
          }
        }
      }
  
      return copy;
    },
        _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
      var ease = obj.ease || easeEach || "power1.inOut",
          p,
          a;
  
      if (_isArray(obj)) {
        a = allProps[prop] || (allProps[prop] = []);
        obj.forEach(function (value, i) {
          return a.push({
            t: i / (obj.length - 1) * 100,
            v: value,
            e: ease
          });
        });
      } else {
        for (p in obj) {
          a = allProps[p] || (allProps[p] = []);
          p === "ease" || a.push({
            t: parseFloat(prop),
            v: obj[p],
            e: ease
          });
        }
      }
    },
        _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
      return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
    },
        _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        _staggerPropsToSkip = {};
  
    _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
      return _staggerPropsToSkip[name] = 1;
    });
  
    var Tween = function (_Animation2) {
      _inheritsLoose(Tween, _Animation2);
  
      function Tween(targets, vars, position, skipInherit) {
        var _this3;
  
        if (typeof vars === "number") {
          position.duration = vars;
          vars = position;
          position = null;
        }
  
        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
        var _this3$vars = _this3.vars,
            duration = _this3$vars.duration,
            delay = _this3$vars.delay,
            immediateRender = _this3$vars.immediateRender,
            stagger = _this3$vars.stagger,
            overwrite = _this3$vars.overwrite,
            keyframes = _this3$vars.keyframes,
            defaults = _this3$vars.defaults,
            scrollTrigger = _this3$vars.scrollTrigger,
            yoyoEase = _this3$vars.yoyoEase,
            parent = vars.parent || _globalTimeline,
            parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
            tl,
            i,
            copy,
            l,
            p,
            curTarget,
            staggerFunc,
            staggerVarsToMerge;
        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
        _this3._ptLookup = [];
        _this3._overwrite = overwrite;
  
        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          vars = _this3.vars;
          tl = _this3.timeline = new Timeline({
            data: "nested",
            defaults: defaults || {},
            targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
          });
          tl.kill();
          tl.parent = tl._dp = _assertThisInitialized(_this3);
          tl._start = 0;
  
          if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
            l = parsedTargets.length;
            staggerFunc = stagger && distribute(stagger);
  
            if (_isObject(stagger)) {
              for (p in stagger) {
                if (~_staggerTweenProps.indexOf(p)) {
                  staggerVarsToMerge || (staggerVarsToMerge = {});
                  staggerVarsToMerge[p] = stagger[p];
                }
              }
            }
  
            for (i = 0; i < l; i++) {
              copy = _copyExcluding(vars, _staggerPropsToSkip);
              copy.stagger = 0;
              yoyoEase && (copy.yoyoEase = yoyoEase);
              staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
              curTarget = parsedTargets[i];
              copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
              copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
  
              if (!stagger && l === 1 && copy.delay) {
                _this3._delay = delay = copy.delay;
                _this3._start += delay;
                copy.delay = 0;
              }
  
              tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
              tl._ease = _easeMap.none;
            }
  
            tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
          } else if (keyframes) {
            _inheritDefaults(_setDefaults(tl.vars.defaults, {
              ease: "none"
            }));
  
            tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
            var time = 0,
                a,
                kf,
                v;
  
            if (_isArray(keyframes)) {
              keyframes.forEach(function (frame) {
                return tl.to(parsedTargets, frame, ">");
              });
              tl.duration();
            } else {
              copy = {};
  
              for (p in keyframes) {
                p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
              }
  
              for (p in copy) {
                a = copy[p].sort(function (a, b) {
                  return a.t - b.t;
                });
                time = 0;
  
                for (i = 0; i < a.length; i++) {
                  kf = a[i];
                  v = {
                    ease: kf.e,
                    duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                  };
                  v[p] = kf.v;
                  tl.to(parsedTargets, v, time);
                  time += v.duration;
                }
              }
  
              tl.duration() < duration && tl.to({}, {
                duration: duration - tl.duration()
              });
            }
          }
  
          duration || _this3.duration(duration = tl.duration());
        } else {
          _this3.timeline = 0;
        }
  
        if (overwrite === true && !_suppressOverwrites) {
          _overwritingTween = _assertThisInitialized(_this3);
  
          _globalTimeline.killTweensOf(parsedTargets);
  
          _overwritingTween = 0;
        }
  
        _addToTimeline(parent, _assertThisInitialized(_this3), position);
  
        vars.reversed && _this3.reverse();
        vars.paused && _this3.paused(true);
  
        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
          _this3._tTime = -_tinyNum;
  
          _this3.render(Math.max(0, -delay) || 0);
        }
  
        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
        return _this3;
      }
  
      var _proto3 = Tween.prototype;
  
      _proto3.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time,
            tDur = this._tDur,
            dur = this._dur,
            isNegative = totalTime < 0,
            tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
            time,
            pt,
            iteration,
            cycleDuration,
            prevIteration,
            isYoyo,
            ratio,
            timeline,
            yoyoEase;
  
        if (!dur) {
          _renderZeroDurationTween(this, totalTime, suppressEvents, force);
        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
          time = tTime;
          timeline = this.timeline;
  
          if (this._repeat) {
            cycleDuration = dur + this._rDelay;
  
            if (this._repeat < -1 && isNegative) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
  
            time = _roundPrecise(tTime % cycleDuration);
  
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
  
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
  
              time > dur && (time = dur);
            }
  
            isYoyo = this._yoyo && iteration & 1;
  
            if (isYoyo) {
              yoyoEase = this._yEase;
              time = dur - time;
            }
  
            prevIteration = _animationCycle(this._tTime, cycleDuration);
  
            if (time === prevTime && !force && this._initted) {
              this._tTime = tTime;
              return this;
            }
  
            if (iteration !== prevIteration) {
              timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
  
              if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                this._lock = force = 1;
                this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
              }
            }
          }
  
          if (!this._initted) {
            if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
              this._tTime = 0;
              return this;
            }
  
            if (prevTime !== this._time) {
              return this;
            }
  
            if (dur !== this._dur) {
              return this.render(totalTime, suppressEvents, force);
            }
          }
  
          this._tTime = tTime;
          this._time = time;
  
          if (!this._act && this._ts) {
            this._act = 1;
            this._lazy = 0;
          }
  
          this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
  
          if (this._from) {
            this.ratio = ratio = 1 - ratio;
          }
  
          if (time && !prevTime && !suppressEvents) {
            _callback(this, "onStart");
  
            if (this._tTime !== tTime) {
              return this;
            }
          }
  
          pt = this._pt;
  
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
  
          timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
  
          if (this._onUpdate && !suppressEvents) {
            isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
  
            _callback(this, "onUpdate");
          }
  
          this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
  
          if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
            isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
            (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
  
            if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
              _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
  
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
  
        return this;
      };
  
      _proto3.targets = function targets() {
        return this._targets;
      };
  
      _proto3.invalidate = function invalidate(soft) {
        (!soft || !this.vars.runBackwards) && (this._startAt = 0);
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
        this._ptLookup = [];
        this.timeline && this.timeline.invalidate(soft);
        return _Animation2.prototype.invalidate.call(this, soft);
      };
  
      _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
        _tickerActive || _ticker.wake();
        this._ts || this.play();
        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
            ratio;
        this._initted || _initTween(this, time);
        ratio = this._ease(time / this._dur);
  
        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
          return this.resetTo(property, value, start, startIsRelative);
        }
  
        _alignPlayhead(this, 0);
  
        this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
        return this.render(0);
      };
  
      _proto3.kill = function kill(targets, vars) {
        if (vars === void 0) {
          vars = "all";
        }
  
        if (!targets && (!vars || vars === "all")) {
          this._lazy = this._pt = 0;
          return this.parent ? _interrupt(this) : this;
        }
  
        if (this.timeline) {
          var tDur = this.timeline.totalDuration();
          this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
          this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
          return this;
        }
  
        var parsedTargets = this._targets,
            killingTargets = targets ? toArray(targets) : parsedTargets,
            propTweenLookup = this._ptLookup,
            firstPT = this._pt,
            overwrittenProps,
            curLookup,
            curOverwriteProps,
            props,
            p,
            pt,
            i;
  
        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
          vars === "all" && (this._pt = 0);
          return _interrupt(this);
        }
  
        overwrittenProps = this._op = this._op || [];
  
        if (vars !== "all") {
          if (_isString(vars)) {
            p = {};
  
            _forEachName(vars, function (name) {
              return p[name] = 1;
            });
  
            vars = p;
          }
  
          vars = _addAliasesToVars(parsedTargets, vars);
        }
  
        i = parsedTargets.length;
  
        while (i--) {
          if (~killingTargets.indexOf(parsedTargets[i])) {
            curLookup = propTweenLookup[i];
  
            if (vars === "all") {
              overwrittenProps[i] = vars;
              props = curLookup;
              curOverwriteProps = {};
            } else {
              curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
              props = vars;
            }
  
            for (p in props) {
              pt = curLookup && curLookup[p];
  
              if (pt) {
                if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                  _removeLinkedListItem(this, pt, "_pt");
                }
  
                delete curLookup[p];
              }
  
              if (curOverwriteProps !== "all") {
                curOverwriteProps[p] = 1;
              }
            }
          }
        }
  
        this._initted && !this._pt && firstPT && _interrupt(this);
        return this;
      };
  
      Tween.to = function to(targets, vars) {
        return new Tween(targets, vars, arguments[2]);
      };
  
      Tween.from = function from(targets, vars) {
        return _createTweenType(1, arguments);
      };
  
      Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
        return new Tween(callback, 0, {
          immediateRender: false,
          lazy: false,
          overwrite: false,
          delay: delay,
          onComplete: callback,
          onReverseComplete: callback,
          onCompleteParams: params,
          onReverseCompleteParams: params,
          callbackScope: scope
        });
      };
  
      Tween.fromTo = function fromTo(targets, fromVars, toVars) {
        return _createTweenType(2, arguments);
      };
  
      Tween.set = function set(targets, vars) {
        vars.duration = 0;
        vars.repeatDelay || (vars.repeat = 0);
        return new Tween(targets, vars);
      };
  
      Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        return _globalTimeline.killTweensOf(targets, props, onlyActive);
      };
  
      return Tween;
    }(Animation);
  
    _setDefaults(Tween.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    });
  
    _forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
      Tween[name] = function () {
        var tl = new Timeline(),
            params = _slice.call(arguments, 0);
  
        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
        return tl[name].apply(tl, params);
      };
    });
  
    var _setterPlain = function _setterPlain(target, property, value) {
      return target[property] = value;
    },
        _setterFunc = function _setterFunc(target, property, value) {
      return target[property](value);
    },
        _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
      return target[property](data.fp, value);
    },
        _setterAttribute = function _setterAttribute(target, property, value) {
      return target.setAttribute(property, value);
    },
        _getSetter = function _getSetter(target, property) {
      return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
    },
        _renderPlain = function _renderPlain(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
    },
        _renderBoolean = function _renderBoolean(ratio, data) {
      return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
    },
        _renderComplexString = function _renderComplexString(ratio, data) {
      var pt = data._pt,
          s = "";
  
      if (!ratio && data.b) {
        s = data.b;
      } else if (ratio === 1 && data.e) {
        s = data.e;
      } else {
        while (pt) {
          s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s;
          pt = pt._next;
        }
  
        s += data.c;
      }
  
      data.set(data.t, data.p, s, data);
    },
        _renderPropTweens = function _renderPropTweens(ratio, data) {
      var pt = data._pt;
  
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    },
        _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
      var pt = this._pt,
          next;
  
      while (pt) {
        next = pt._next;
        pt.p === property && pt.modifier(modifier, tween, target);
        pt = next;
      }
    },
        _killPropTweensOf = function _killPropTweensOf(property) {
      var pt = this._pt,
          hasNonDependentRemaining,
          next;
  
      while (pt) {
        next = pt._next;
  
        if (pt.p === property && !pt.op || pt.op === property) {
          _removeLinkedListItem(this, pt, "_pt");
        } else if (!pt.dep) {
          hasNonDependentRemaining = 1;
        }
  
        pt = next;
      }
  
      return !hasNonDependentRemaining;
    },
        _setterWithModifier = function _setterWithModifier(target, property, value, data) {
      data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
    },
        _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
      var pt = parent._pt,
          next,
          pt2,
          first,
          last;
  
      while (pt) {
        next = pt._next;
        pt2 = first;
  
        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
  
        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
  
        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
  
        pt = next;
      }
  
      parent._pt = first;
    };
  
    var PropTween = function () {
      function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
        this.t = target;
        this.s = start;
        this.c = change;
        this.p = prop;
        this.r = renderer || _renderPlain;
        this.d = data || this;
        this.set = setter || _setterPlain;
        this.pr = priority || 0;
        this._next = next;
  
        if (next) {
          next._prev = this;
        }
      }
  
      var _proto4 = PropTween.prototype;
  
      _proto4.modifier = function modifier(func, tween, target) {
        this.mSet = this.mSet || this.set;
        this.set = _setterWithModifier;
        this.m = func;
        this.mt = target;
        this.tween = tween;
      };
  
      return PropTween;
    }();
  
    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
      return _reservedProps[name] = 1;
    });
  
    _globals.TweenMax = _globals.TweenLite = Tween;
    _globals.TimelineLite = _globals.TimelineMax = Timeline;
    _globalTimeline = new Timeline({
      sortChildren: false,
      defaults: _defaults,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
    });
    _config.stringFilter = _colorStringFilter;
  
    var _media = [],
        _listeners = {},
        _emptyArray = [],
        _lastMediaTime = 0,
        _dispatch = function _dispatch(type) {
      return (_listeners[type] || _emptyArray).map(function (f) {
        return f();
      });
    },
        _onMediaChange = function _onMediaChange() {
      var time = Date.now(),
          matches = [];
  
      if (time - _lastMediaTime > 2) {
        _dispatch("matchMediaInit");
  
        _media.forEach(function (c) {
          var queries = c.queries,
              conditions = c.conditions,
              match,
              p,
              anyMatch,
              toggled;
  
          for (p in queries) {
            match = _win.matchMedia(queries[p]).matches;
            match && (anyMatch = 1);
  
            if (match !== conditions[p]) {
              conditions[p] = match;
              toggled = 1;
            }
          }
  
          if (toggled) {
            c.revert();
            anyMatch && matches.push(c);
          }
        });
  
        _dispatch("matchMediaRevert");
  
        matches.forEach(function (c) {
          return c.onMatch(c);
        });
        _lastMediaTime = time;
  
        _dispatch("matchMedia");
      }
    };
  
    var Context = function () {
      function Context(func, scope) {
        this.selector = scope && selector(scope);
        this.data = [];
        this._r = [];
        this.isReverted = false;
        func && this.add(func);
      }
  
      var _proto5 = Context.prototype;
  
      _proto5.add = function add(name, func, scope) {
        if (_isFunction(name)) {
          scope = func;
          func = name;
          name = _isFunction;
        }
  
        var self = this,
            f = function f() {
          var prev = _context,
              prevSelector = self.selector,
              result;
          prev && prev !== self && prev.data.push(self);
          scope && (self.selector = selector(scope));
          _context = self;
          result = func.apply(self, arguments);
          _isFunction(result) && self._r.push(result);
          _context = prev;
          self.selector = prevSelector;
          self.isReverted = false;
          return result;
        };
  
        self.last = f;
        return name === _isFunction ? f(self) : name ? self[name] = f : f;
      };
  
      _proto5.ignore = function ignore(func) {
        var prev = _context;
        _context = null;
        func(this);
        _context = prev;
      };
  
      _proto5.getTweens = function getTweens() {
        var a = [];
        this.data.forEach(function (e) {
          return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
        });
        return a;
      };
  
      _proto5.clear = function clear() {
        this._r.length = this.data.length = 0;
      };
  
      _proto5.kill = function kill(revert, matchMedia) {
        var _this4 = this;
  
        if (revert) {
          var tweens = this.getTweens();
          this.data.forEach(function (t) {
            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function (tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          });
          tweens.map(function (t) {
            return {
              g: t.globalTime(0),
              t: t
            };
          }).sort(function (a, b) {
            return b.g - a.g || -1;
          }).forEach(function (o) {
            return o.t.revert(revert);
          });
          this.data.forEach(function (e) {
            return !(e instanceof Animation) && e.revert && e.revert(revert);
          });
  
          this._r.forEach(function (f) {
            return f(revert, _this4);
          });
  
          this.isReverted = true;
        } else {
          this.data.forEach(function (e) {
            return e.kill && e.kill();
          });
        }
  
        this.clear();
  
        if (matchMedia) {
          var i = _media.indexOf(this);
  
          !!~i && _media.splice(i, 1);
        }
      };
  
      _proto5.revert = function revert(config) {
        this.kill(config || {});
      };
  
      return Context;
    }();
  
    var MatchMedia = function () {
      function MatchMedia(scope) {
        this.contexts = [];
        this.scope = scope;
      }
  
      var _proto6 = MatchMedia.prototype;
  
      _proto6.add = function add(conditions, func, scope) {
        _isObject(conditions) || (conditions = {
          matches: conditions
        });
        var context = new Context(0, scope || this.scope),
            cond = context.conditions = {},
            mq,
            p,
            active;
        this.contexts.push(context);
        func = context.add("onMatch", func);
        context.queries = conditions;
  
        for (p in conditions) {
          if (p === "all") {
            active = 1;
          } else {
            mq = _win.matchMedia(conditions[p]);
  
            if (mq) {
              _media.indexOf(context) < 0 && _media.push(context);
              (cond[p] = mq.matches) && (active = 1);
              mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
            }
          }
        }
  
        active && func(context);
        return this;
      };
  
      _proto6.revert = function revert(config) {
        this.kill(config || {});
      };
  
      _proto6.kill = function kill(revert) {
        this.contexts.forEach(function (c) {
          return c.kill(revert, true);
        });
      };
  
      return MatchMedia;
    }();
  
    var _gsap = {
      registerPlugin: function registerPlugin() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
  
        args.forEach(function (config) {
          return _createPlugin(config);
        });
      },
      timeline: function timeline(vars) {
        return new Timeline(vars);
      },
      getTweensOf: function getTweensOf(targets, onlyActive) {
        return _globalTimeline.getTweensOf(targets, onlyActive);
      },
      getProperty: function getProperty(target, property, unit, uncache) {
        _isString(target) && (target = toArray(target)[0]);
  
        var getter = _getCache(target || {}).get,
            format = unit ? _passThrough : _numericIfPossible;
  
        unit === "native" && (unit = "");
        return !target ? target : !property ? function (property, unit, uncache) {
          return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      },
      quickSetter: function quickSetter(target, property, unit) {
        target = toArray(target);
  
        if (target.length > 1) {
          var setters = target.map(function (t) {
            return gsap.quickSetter(t, property, unit);
          }),
              l = setters.length;
          return function (value) {
            var i = l;
  
            while (i--) {
              setters[i](value);
            }
          };
        }
  
        target = target[0] || {};
  
        var Plugin = _plugins[property],
            cache = _getCache(target),
            p = cache.harness && (cache.harness.aliases || {})[property] || property,
            setter = Plugin ? function (value) {
          var p = new Plugin();
          _quickTween._pt = 0;
          p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
          p.render(1, p);
          _quickTween._pt && _renderPropTweens(1, _quickTween);
        } : cache.set(target, p);
  
        return Plugin ? setter : function (value) {
          return setter(target, p, unit ? value + unit : value, cache, 1);
        };
      },
      quickTo: function quickTo(target, property, vars) {
        var _merge2;
  
        var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
            func = function func(value, start, startIsRelative) {
          return tween.resetTo(property, value, start, startIsRelative);
        };
  
        func.tween = tween;
        return func;
      },
      isTweening: function isTweening(targets) {
        return _globalTimeline.getTweensOf(targets, true).length > 0;
      },
      defaults: function defaults(value) {
        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
        return _mergeDeep(_defaults, value || {});
      },
      config: function config(value) {
        return _mergeDeep(_config, value || {});
      },
      registerEffect: function registerEffect(_ref3) {
        var name = _ref3.name,
            effect = _ref3.effect,
            plugins = _ref3.plugins,
            defaults = _ref3.defaults,
            extendTimeline = _ref3.extendTimeline;
        (plugins || "").split(",").forEach(function (pluginName) {
          return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
        });
  
        _effects[name] = function (targets, vars, tl) {
          return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
        };
  
        if (extendTimeline) {
          Timeline.prototype[name] = function (targets, vars, position) {
            return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
          };
        }
      },
      registerEase: function registerEase(name, ease) {
        _easeMap[name] = _parseEase(ease);
      },
      parseEase: function parseEase(ease, defaultEase) {
        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
      },
      getById: function getById(id) {
        return _globalTimeline.getById(id);
      },
      exportRoot: function exportRoot(vars, includeDelayedCalls) {
        if (vars === void 0) {
          vars = {};
        }
  
        var tl = new Timeline(vars),
            child,
            next;
        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
  
        _globalTimeline.remove(tl);
  
        tl._dp = 0;
        tl._time = tl._tTime = _globalTimeline._time;
        child = _globalTimeline._first;
  
        while (child) {
          next = child._next;
  
          if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
            _addToTimeline(tl, child, child._start - child._delay);
          }
  
          child = next;
        }
  
        _addToTimeline(_globalTimeline, tl, 0);
  
        return tl;
      },
      context: function context(func, scope) {
        return func ? new Context(func, scope) : _context;
      },
      matchMedia: function matchMedia(scope) {
        return new MatchMedia(scope);
      },
      matchMediaRefresh: function matchMediaRefresh() {
        return _media.forEach(function (c) {
          var cond = c.conditions,
              found,
              p;
  
          for (p in cond) {
            if (cond[p]) {
              cond[p] = false;
              found = 1;
            }
          }
  
          found && c.revert();
        }) || _onMediaChange();
      },
      addEventListener: function addEventListener(type, callback) {
        var a = _listeners[type] || (_listeners[type] = []);
        ~a.indexOf(callback) || a.push(callback);
      },
      removeEventListener: function removeEventListener(type, callback) {
        var a = _listeners[type],
            i = a && a.indexOf(callback);
        i >= 0 && a.splice(i, 1);
      },
      utils: {
        wrap: wrap,
        wrapYoyo: wrapYoyo,
        distribute: distribute,
        random: random,
        snap: snap,
        normalize: normalize,
        getUnit: getUnit,
        clamp: clamp,
        splitColor: splitColor,
        toArray: toArray,
        selector: selector,
        mapRange: mapRange,
        pipe: pipe,
        unitize: unitize,
        interpolate: interpolate,
        shuffle: shuffle
      },
      install: _install,
      effects: _effects,
      ticker: _ticker,
      updateRoot: Timeline.updateRoot,
      plugins: _plugins,
      globalTimeline: _globalTimeline,
      core: {
        PropTween: PropTween,
        globals: _addGlobal,
        Tween: Tween,
        Timeline: Timeline,
        Animation: Animation,
        getCache: _getCache,
        _removeLinkedListItem: _removeLinkedListItem,
        reverting: function reverting() {
          return _reverting;
        },
        context: function context(toAdd) {
          if (toAdd && _context) {
            _context.data.push(toAdd);
  
            toAdd._ctx = _context;
          }
  
          return _context;
        },
        suppressOverwrites: function suppressOverwrites(value) {
          return _suppressOverwrites = value;
        }
      }
    };
  
    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
      return _gsap[name] = Tween[name];
    });
  
    _ticker.add(Timeline.updateRoot);
  
    _quickTween = _gsap.to({}, {
      duration: 0
    });
  
    var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
      var pt = plugin._pt;
  
      while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
        pt = pt._next;
      }
  
      return pt;
    },
        _addModifiers = function _addModifiers(tween, modifiers) {
      var targets = tween._targets,
          p,
          i,
          pt;
  
      for (p in modifiers) {
        i = targets.length;
  
        while (i--) {
          pt = tween._ptLookup[i][p];
  
          if (pt && (pt = pt.d)) {
            if (pt._pt) {
              pt = _getPluginPropTween(pt, p);
            }
  
            pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
          }
        }
      }
    },
        _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
      return {
        name: name,
        rawVars: 1,
        init: function init(target, vars, tween) {
          tween._onInit = function (tween) {
            var temp, p;
  
            if (_isString(vars)) {
              temp = {};
  
              _forEachName(vars, function (name) {
                return temp[name] = 1;
              });
  
              vars = temp;
            }
  
            if (modifier) {
              temp = {};
  
              for (p in vars) {
                temp[p] = modifier(vars[p]);
              }
  
              vars = temp;
            }
  
            _addModifiers(tween, vars);
          };
        }
      };
    };
  
    var gsap = _gsap.registerPlugin({
      name: "attr",
      init: function init(target, vars, tween, index, targets) {
        var p, pt, v;
        this.tween = tween;
  
        for (p in vars) {
          v = target.getAttribute(p) || "";
          pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
          pt.op = p;
          pt.b = v;
  
          this._props.push(p);
        }
      },
      render: function render(ratio, data) {
        var pt = data._pt;
  
        while (pt) {
          _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
          pt = pt._next;
        }
      }
    }, {
      name: "endArray",
      init: function init(target, value) {
        var i = value.length;
  
        while (i--) {
          this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
        }
      }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
    Tween.version = Timeline.version = gsap.version = "3.11.4";
    _coreReady = 1;
    _windowExists() && _wake();
    var Power0 = _easeMap.Power0,
        Power1 = _easeMap.Power1,
        Power2 = _easeMap.Power2,
        Power3 = _easeMap.Power3,
        Power4 = _easeMap.Power4,
        Linear = _easeMap.Linear,
        Quad = _easeMap.Quad,
        Cubic = _easeMap.Cubic,
        Quart = _easeMap.Quart,
        Quint = _easeMap.Quint,
        Strong = _easeMap.Strong,
        Elastic = _easeMap.Elastic,
        Back = _easeMap.Back,
        SteppedEase = _easeMap.SteppedEase,
        Bounce = _easeMap.Bounce,
        Sine = _easeMap.Sine,
        Expo = _easeMap.Expo,
        Circ = _easeMap.Circ;
  
    var _win$1,
        _doc$1,
        _docElement,
        _pluginInitted,
        _tempDiv,
        _tempDivStyler,
        _recentSetterPlugin,
        _reverting$1,
        _windowExists$1 = function _windowExists() {
      return typeof window !== "undefined";
    },
        _transformProps = {},
        _RAD2DEG = 180 / Math.PI,
        _DEG2RAD = Math.PI / 180,
        _atan2 = Math.atan2,
        _bigNum$1 = 1e8,
        _capsExp = /([A-Z])/g,
        _horizontalExp = /(left|right|width|margin|padding|x)/i,
        _complexExp = /[\s,\(]\S/,
        _propertyAliases = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    },
        _renderCSSProp = function _renderCSSProp(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
    },
        _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
      return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
    },
        _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
      return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
    },
        _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
      var value = data.s + data.c * ratio;
      data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
    },
        _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
      return data.set(data.t, data.p, ratio ? data.e : data.b, data);
    },
        _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
      return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
    },
        _setterCSSStyle = function _setterCSSStyle(target, property, value) {
      return target.style[property] = value;
    },
        _setterCSSProp = function _setterCSSProp(target, property, value) {
      return target.style.setProperty(property, value);
    },
        _setterTransform = function _setterTransform(target, property, value) {
      return target._gsap[property] = value;
    },
        _setterScale = function _setterScale(target, property, value) {
      return target._gsap.scaleX = target._gsap.scaleY = value;
    },
        _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache.scaleX = cache.scaleY = value;
      cache.renderTransform(ratio, cache);
    },
        _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache[property] = value;
      cache.renderTransform(ratio, cache);
    },
        _transformProp = "transform",
        _transformOriginProp = _transformProp + "Origin",
        _saveStyle = function _saveStyle(property, isNotCSS) {
      var _this = this;
  
      var target = this.target,
          style = target.style;
  
      if (property in _transformProps) {
        this.tfm = this.tfm || {};
  
        if (property !== "transform") {
          property = _propertyAliases[property] || property;
          ~property.indexOf(",") ? property.split(",").forEach(function (a) {
            return _this.tfm[a] = _get(target, a);
          }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property);
        }
  
        if (this.props.indexOf(_transformProp) >= 0) {
          return;
        }
  
        if (target._gsap.svg) {
          this.svgo = target.getAttribute("data-svg-origin");
          this.props.push(_transformOriginProp, isNotCSS, "");
        }
  
        property = _transformProp;
      }
  
      (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
    },
        _removeIndependentTransforms = function _removeIndependentTransforms(style) {
      if (style.translate) {
        style.removeProperty("translate");
        style.removeProperty("scale");
        style.removeProperty("rotate");
      }
    },
        _revertStyle = function _revertStyle() {
      var props = this.props,
          target = this.target,
          style = target.style,
          cache = target._gsap,
          i,
          p;
  
      for (i = 0; i < props.length; i += 3) {
        props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].replace(_capsExp, "-$1").toLowerCase());
      }
  
      if (this.tfm) {
        for (p in this.tfm) {
          cache[p] = this.tfm[p];
        }
  
        if (cache.svg) {
          cache.renderTransform();
          target.setAttribute("data-svg-origin", this.svgo || "");
        }
  
        i = _reverting$1();
  
        if (i && !i.isStart && !style[_transformProp]) {
          _removeIndependentTransforms(style);
  
          cache.uncache = 1;
        }
      }
    },
        _getStyleSaver = function _getStyleSaver(target, properties) {
      var saver = {
        target: target,
        props: [],
        revert: _revertStyle,
        save: _saveStyle
      };
      properties && properties.split(",").forEach(function (p) {
        return saver.save(p);
      });
      return saver;
    },
        _supports3D,
        _createElement = function _createElement(type, ns) {
      var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type);
      return e.style ? e : _doc$1.createElement(type);
    },
        _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
      var cs = getComputedStyle(target);
      return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || "";
    },
        _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
        _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
      var e = element || _tempDiv,
          s = e.style,
          i = 5;
  
      if (property in s && !preferPrefix) {
        return property;
      }
  
      property = property.charAt(0).toUpperCase() + property.substr(1);
  
      while (i-- && !(_prefixes[i] + property in s)) {}
  
      return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
    },
        _initCore = function _initCore() {
      if (_windowExists$1() && window.document) {
        _win$1 = window;
        _doc$1 = _win$1.document;
        _docElement = _doc$1.documentElement;
        _tempDiv = _createElement("div") || {
          style: {}
        };
        _tempDivStyler = _createElement("div");
        _transformProp = _checkPropPrefix(_transformProp);
        _transformOriginProp = _transformProp + "Origin";
        _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
        _supports3D = !!_checkPropPrefix("perspective");
        _reverting$1 = gsap.core.reverting;
        _pluginInitted = 1;
      }
    },
        _getBBoxHack = function _getBBoxHack(swapIfPossible) {
      var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
          oldParent = this.parentNode,
          oldSibling = this.nextSibling,
          oldCSS = this.style.cssText,
          bbox;
  
      _docElement.appendChild(svg);
  
      svg.appendChild(this);
      this.style.display = "block";
  
      if (swapIfPossible) {
        try {
          bbox = this.getBBox();
          this._gsapBBox = this.getBBox;
          this.getBBox = _getBBoxHack;
        } catch (e) {}
      } else if (this._gsapBBox) {
        bbox = this._gsapBBox();
      }
  
      if (oldParent) {
        if (oldSibling) {
          oldParent.insertBefore(this, oldSibling);
        } else {
          oldParent.appendChild(this);
        }
      }
  
      _docElement.removeChild(svg);
  
      this.style.cssText = oldCSS;
      return bbox;
    },
        _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
      var i = attributesArray.length;
  
      while (i--) {
        if (target.hasAttribute(attributesArray[i])) {
          return target.getAttribute(attributesArray[i]);
        }
      }
    },
        _getBBox = function _getBBox(target) {
      var bounds;
  
      try {
        bounds = target.getBBox();
      } catch (error) {
        bounds = _getBBoxHack.call(target, true);
      }
  
      bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
      return bounds && !bounds.width && !bounds.x && !bounds.y ? {
        x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
        y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      } : bounds;
    },
        _isSVG = function _isSVG(e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
    },
        _removeProperty = function _removeProperty(target, property) {
      if (property) {
        var style = target.style;
  
        if (property in _transformProps && property !== _transformOriginProp) {
          property = _transformProp;
        }
  
        if (style.removeProperty) {
          if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
            property = "-" + property;
          }
  
          style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
        } else {
          style.removeAttribute(property);
        }
      }
    },
        _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
      var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
      plugin._pt = pt;
      pt.b = beginning;
      pt.e = end;
  
      plugin._props.push(property);
  
      return pt;
    },
        _nonConvertibleUnits = {
      deg: 1,
      rad: 1,
      turn: 1
    },
        _nonStandardLayouts = {
      grid: 1,
      flex: 1
    },
        _convertToUnit = function _convertToUnit(target, property, value, unit) {
      var curValue = parseFloat(value) || 0,
          curUnit = (value + "").trim().substr((curValue + "").length) || "px",
          style = _tempDiv.style,
          horizontal = _horizontalExp.test(property),
          isRootSVG = target.tagName.toLowerCase() === "svg",
          measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
          amount = 100,
          toPixels = unit === "px",
          toPercent = unit === "%",
          px,
          parent,
          cache,
          isSVG;
  
      if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
        return curValue;
      }
  
      curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
      isSVG = target.getCTM && _isSVG(target);
  
      if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
        px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
        return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
      }
  
      style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
      parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
  
      if (isSVG) {
        parent = (target.ownerSVGElement || {}).parentNode;
      }
  
      if (!parent || parent === _doc$1 || !parent.appendChild) {
        parent = _doc$1.body;
      }
  
      cache = parent._gsap;
  
      if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
        return _round(curValue / cache.width * amount);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
  
        if (horizontal && toPercent) {
          cache = _getCache(parent);
          cache.time = _ticker.time;
          cache.width = parent[measureProperty];
        }
      }
  
      return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
    },
        _get = function _get(target, property, unit, uncache) {
      var value;
      _pluginInitted || _initCore();
  
      if (property in _propertyAliases && property !== "transform") {
        property = _propertyAliases[property];
  
        if (~property.indexOf(",")) {
          property = property.split(",")[0];
        }
      }
  
      if (_transformProps[property] && property !== "transform") {
        value = _parseTransform(target, uncache);
        value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
      } else {
        value = target.style[property];
  
        if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
          value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
        }
      }
  
      return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
    },
        _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
      if (!start || start === "none") {
        var p = _checkPropPrefix(prop, target, 1),
            s = p && _getComputedProperty(target, p, 1);
  
        if (s && s !== start) {
          prop = p;
          start = s;
        } else if (prop === "borderColor") {
          start = _getComputedProperty(target, "borderTopColor");
        }
      }
  
      var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
          index = 0,
          matchIndex = 0,
          a,
          result,
          startValues,
          startNum,
          color,
          startValue,
          endValue,
          endNum,
          chunk,
          endUnit,
          startUnit,
          endValues;
      pt.b = start;
      pt.e = end;
      start += "";
      end += "";
  
      if (end === "auto") {
        target.style[prop] = end;
        end = _getComputedProperty(target, prop) || end;
        target.style[prop] = start;
      }
  
      a = [start, end];
  
      _colorStringFilter(a);
  
      start = a[0];
      end = a[1];
      startValues = start.match(_numWithUnitExp) || [];
      endValues = end.match(_numWithUnitExp) || [];
  
      if (endValues.length) {
        while (result = _numWithUnitExp.exec(end)) {
          endValue = result[0];
          chunk = end.substring(index, result.index);
  
          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
            color = 1;
          }
  
          if (endValue !== (startValue = startValues[matchIndex++] || "")) {
            startNum = parseFloat(startValue) || 0;
            startUnit = startValue.substr((startNum + "").length);
            endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
            endNum = parseFloat(endValue);
            endUnit = endValue.substr((endNum + "").length);
            index = _numWithUnitExp.lastIndex - endUnit.length;
  
            if (!endUnit) {
              endUnit = endUnit || _config.units[prop] || startUnit;
  
              if (index === end.length) {
                end += endUnit;
                pt.e += endUnit;
              }
            }
  
            if (startUnit !== endUnit) {
              startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
            }
  
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              s: startNum,
              c: endNum - startNum,
              m: color && color < 4 || prop === "zIndex" ? Math.round : 0
            };
          }
        }
  
        pt.c = index < end.length ? end.substring(index, end.length) : "";
      } else {
        pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
      }
  
      _relExp.test(end) && (pt.e = 0);
      this._pt = pt;
      return pt;
    },
        _keywordToPercent = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    },
        _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
      var split = value.split(" "),
          x = split[0],
          y = split[1] || "50%";
  
      if (x === "top" || x === "bottom" || y === "left" || y === "right") {
        value = x;
        x = y;
        y = value;
      }
  
      split[0] = _keywordToPercent[x] || x;
      split[1] = _keywordToPercent[y] || y;
      return split.join(" ");
    },
        _renderClearProps = function _renderClearProps(ratio, data) {
      if (data.tween && data.tween._time === data.tween._dur) {
        var target = data.t,
            style = target.style,
            props = data.u,
            cache = target._gsap,
            prop,
            clearTransforms,
            i;
  
        if (props === "all" || props === true) {
          style.cssText = "";
          clearTransforms = 1;
        } else {
          props = props.split(",");
          i = props.length;
  
          while (--i > -1) {
            prop = props[i];
  
            if (_transformProps[prop]) {
              clearTransforms = 1;
              prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
            }
  
            _removeProperty(target, prop);
          }
        }
  
        if (clearTransforms) {
          _removeProperty(target, _transformProp);
  
          if (cache) {
            cache.svg && target.removeAttribute("transform");
  
            _parseTransform(target, 1);
  
            cache.uncache = 1;
  
            _removeIndependentTransforms(style);
          }
        }
      }
    },
        _specialProps = {
      clearProps: function clearProps(plugin, target, property, endValue, tween) {
        if (tween.data !== "isFromStart") {
          var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
          pt.u = endValue;
          pt.pr = -10;
          pt.tween = tween;
  
          plugin._props.push(property);
  
          return 1;
        }
      }
    },
        _identity2DMatrix = [1, 0, 0, 1, 0, 0],
        _rotationalProperties = {},
        _isNullTransform = function _isNullTransform(value) {
      return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
    },
        _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
      var matrixString = _getComputedProperty(target, _transformProp);
  
      return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
    },
        _getMatrix = function _getMatrix(target, force2D) {
      var cache = target._gsap || _getCache(target),
          style = target.style,
          matrix = _getComputedTransformMatrixAsArray(target),
          parent,
          nextSibling,
          temp,
          addedToDOM;
  
      if (cache.svg && target.getAttribute("transform")) {
        temp = target.transform.baseVal.consolidate().matrix;
        matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
        return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
      } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
        temp = style.display;
        style.display = "block";
        parent = target.parentNode;
  
        if (!parent || !target.offsetParent) {
          addedToDOM = 1;
          nextSibling = target.nextElementSibling;
  
          _docElement.appendChild(target);
        }
  
        matrix = _getComputedTransformMatrixAsArray(target);
        temp ? style.display = temp : _removeProperty(target, "display");
  
        if (addedToDOM) {
          nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
        }
      }
  
      return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
    },
        _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
      var cache = target._gsap,
          matrix = matrixArray || _getMatrix(target, true),
          xOriginOld = cache.xOrigin || 0,
          yOriginOld = cache.yOrigin || 0,
          xOffsetOld = cache.xOffset || 0,
          yOffsetOld = cache.yOffset || 0,
          a = matrix[0],
          b = matrix[1],
          c = matrix[2],
          d = matrix[3],
          tx = matrix[4],
          ty = matrix[5],
          originSplit = origin.split(" "),
          xOrigin = parseFloat(originSplit[0]) || 0,
          yOrigin = parseFloat(originSplit[1]) || 0,
          bounds,
          determinant,
          x,
          y;
  
      if (!originIsAbsolute) {
        bounds = _getBBox(target);
        xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
      } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
        xOrigin = x;
        yOrigin = y;
      }
  
      if (smooth || smooth !== false && cache.smooth) {
        tx = xOrigin - xOriginOld;
        ty = yOrigin - yOriginOld;
        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
      } else {
        cache.xOffset = cache.yOffset = 0;
      }
  
      cache.xOrigin = xOrigin;
      cache.yOrigin = yOrigin;
      cache.smooth = !!smooth;
      cache.origin = origin;
      cache.originIsAbsolute = !!originIsAbsolute;
      target.style[_transformOriginProp] = "0px 0px";
  
      if (pluginToAddPropTweensTo) {
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
  
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
  
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
  
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
      }
  
      target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
    },
        _parseTransform = function _parseTransform(target, uncache) {
      var cache = target._gsap || new GSCache(target);
  
      if ("x" in cache && !uncache && !cache.uncache) {
        return cache;
      }
  
      var style = target.style,
          invertedScaleX = cache.scaleX < 0,
          px = "px",
          deg = "deg",
          cs = getComputedStyle(target),
          origin = _getComputedProperty(target, _transformOriginProp) || "0",
          x,
          y,
          z,
          scaleX,
          scaleY,
          rotation,
          rotationX,
          rotationY,
          skewX,
          skewY,
          perspective,
          xOrigin,
          yOrigin,
          matrix,
          angle,
          cos,
          sin,
          a,
          b,
          c,
          d,
          a12,
          a22,
          t1,
          t2,
          t3,
          a13,
          a23,
          a33,
          a42,
          a43,
          a32;
      x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
      scaleX = scaleY = 1;
      cache.svg = !!(target.getCTM && _isSVG(target));
  
      if (cs.translate) {
        if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
          style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
        }
  
        style.scale = style.rotate = style.translate = "none";
      }
  
      matrix = _getMatrix(target, cache.svg);
  
      if (cache.svg) {
        if (cache.uncache) {
          t2 = target.getBBox();
          origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
          t1 = "";
        } else {
          t1 = !uncache && target.getAttribute("data-svg-origin");
        }
  
        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
      }
  
      xOrigin = cache.xOrigin || 0;
      yOrigin = cache.yOrigin || 0;
  
      if (matrix !== _identity2DMatrix) {
        a = matrix[0];
        b = matrix[1];
        c = matrix[2];
        d = matrix[3];
        x = a12 = matrix[4];
        y = a22 = matrix[5];
  
        if (matrix.length === 6) {
          scaleX = Math.sqrt(a * a + b * b);
          scaleY = Math.sqrt(d * d + c * c);
          rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
          skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
          skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
  
          if (cache.svg) {
            x -= xOrigin - (xOrigin * a + yOrigin * c);
            y -= yOrigin - (xOrigin * b + yOrigin * d);
          }
        } else {
          a32 = matrix[6];
          a42 = matrix[7];
          a13 = matrix[8];
          a23 = matrix[9];
          a33 = matrix[10];
          a43 = matrix[11];
          x = matrix[12];
          y = matrix[13];
          z = matrix[14];
          angle = _atan2(a32, a33);
          rotationX = angle * _RAD2DEG;
  
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a12 * cos + a13 * sin;
            t2 = a22 * cos + a23 * sin;
            t3 = a32 * cos + a33 * sin;
            a13 = a12 * -sin + a13 * cos;
            a23 = a22 * -sin + a23 * cos;
            a33 = a32 * -sin + a33 * cos;
            a43 = a42 * -sin + a43 * cos;
            a12 = t1;
            a22 = t2;
            a32 = t3;
          }
  
          angle = _atan2(-c, a33);
          rotationY = angle * _RAD2DEG;
  
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a * cos - a13 * sin;
            t2 = b * cos - a23 * sin;
            t3 = c * cos - a33 * sin;
            a43 = d * sin + a43 * cos;
            a = t1;
            b = t2;
            c = t3;
          }
  
          angle = _atan2(b, a);
          rotation = angle * _RAD2DEG;
  
          if (angle) {
            cos = Math.cos(angle);
            sin = Math.sin(angle);
            t1 = a * cos + b * sin;
            t2 = a12 * cos + a22 * sin;
            b = b * cos - a * sin;
            a22 = a22 * cos - a12 * sin;
            a = t1;
            a12 = t2;
          }
  
          if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
            rotationX = rotation = 0;
            rotationY = 180 - rotationY;
          }
  
          scaleX = _round(Math.sqrt(a * a + b * b + c * c));
          scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
          angle = _atan2(a12, a22);
          skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
          perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
        }
  
        if (cache.svg) {
          t1 = target.getAttribute("transform");
          cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
          t1 && target.setAttribute("transform", t1);
        }
      }
  
      if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
        if (invertedScaleX) {
          scaleX *= -1;
          skewX += rotation <= 0 ? 180 : -180;
          rotation += rotation <= 0 ? 180 : -180;
        } else {
          scaleY *= -1;
          skewX += skewX <= 0 ? 180 : -180;
        }
      }
  
      uncache = uncache || cache.uncache;
      cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
      cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
      cache.z = z + px;
      cache.scaleX = _round(scaleX);
      cache.scaleY = _round(scaleY);
      cache.rotation = _round(rotation) + deg;
      cache.rotationX = _round(rotationX) + deg;
      cache.rotationY = _round(rotationY) + deg;
      cache.skewX = skewX + deg;
      cache.skewY = skewY + deg;
      cache.transformPerspective = perspective + px;
  
      if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
        style[_transformOriginProp] = _firstTwoOnly(origin);
      }
  
      cache.xOffset = cache.yOffset = 0;
      cache.force3D = _config.force3D;
      cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
      cache.uncache = 0;
      return cache;
    },
        _firstTwoOnly = function _firstTwoOnly(value) {
      return (value = value.split(" "))[0] + " " + value[1];
    },
        _addPxTranslate = function _addPxTranslate(target, start, value) {
      var unit = getUnit(start);
      return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
    },
        _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
      cache.z = "0px";
      cache.rotationY = cache.rotationX = "0deg";
      cache.force3D = 0;
  
      _renderCSSTransforms(ratio, cache);
    },
        _zeroDeg = "0deg",
        _zeroPx = "0px",
        _endParenthesis = ") ",
        _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
      var _ref = cache || this,
          xPercent = _ref.xPercent,
          yPercent = _ref.yPercent,
          x = _ref.x,
          y = _ref.y,
          z = _ref.z,
          rotation = _ref.rotation,
          rotationY = _ref.rotationY,
          rotationX = _ref.rotationX,
          skewX = _ref.skewX,
          skewY = _ref.skewY,
          scaleX = _ref.scaleX,
          scaleY = _ref.scaleY,
          transformPerspective = _ref.transformPerspective,
          force3D = _ref.force3D,
          target = _ref.target,
          zOrigin = _ref.zOrigin,
          transforms = "",
          use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
  
      if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
        var angle = parseFloat(rotationY) * _DEG2RAD,
            a13 = Math.sin(angle),
            a33 = Math.cos(angle),
            cos;
  
        angle = parseFloat(rotationX) * _DEG2RAD;
        cos = Math.cos(angle);
        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
      }
  
      if (transformPerspective !== _zeroPx) {
        transforms += "perspective(" + transformPerspective + _endParenthesis;
      }
  
      if (xPercent || yPercent) {
        transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
      }
  
      if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
        transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
      }
  
      if (rotation !== _zeroDeg) {
        transforms += "rotate(" + rotation + _endParenthesis;
      }
  
      if (rotationY !== _zeroDeg) {
        transforms += "rotateY(" + rotationY + _endParenthesis;
      }
  
      if (rotationX !== _zeroDeg) {
        transforms += "rotateX(" + rotationX + _endParenthesis;
      }
  
      if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
        transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
      }
  
      if (scaleX !== 1 || scaleY !== 1) {
        transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
      }
  
      target.style[_transformProp] = transforms || "translate(0, 0)";
    },
        _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
      var _ref2 = cache || this,
          xPercent = _ref2.xPercent,
          yPercent = _ref2.yPercent,
          x = _ref2.x,
          y = _ref2.y,
          rotation = _ref2.rotation,
          skewX = _ref2.skewX,
          skewY = _ref2.skewY,
          scaleX = _ref2.scaleX,
          scaleY = _ref2.scaleY,
          target = _ref2.target,
          xOrigin = _ref2.xOrigin,
          yOrigin = _ref2.yOrigin,
          xOffset = _ref2.xOffset,
          yOffset = _ref2.yOffset,
          forceCSS = _ref2.forceCSS,
          tx = parseFloat(x),
          ty = parseFloat(y),
          a11,
          a21,
          a12,
          a22,
          temp;
  
      rotation = parseFloat(rotation);
      skewX = parseFloat(skewX);
      skewY = parseFloat(skewY);
  
      if (skewY) {
        skewY = parseFloat(skewY);
        skewX += skewY;
        rotation += skewY;
      }
  
      if (rotation || skewX) {
        rotation *= _DEG2RAD;
        skewX *= _DEG2RAD;
        a11 = Math.cos(rotation) * scaleX;
        a21 = Math.sin(rotation) * scaleX;
        a12 = Math.sin(rotation - skewX) * -scaleY;
        a22 = Math.cos(rotation - skewX) * scaleY;
  
        if (skewX) {
          skewY *= _DEG2RAD;
          temp = Math.tan(skewX - skewY);
          temp = Math.sqrt(1 + temp * temp);
          a12 *= temp;
          a22 *= temp;
  
          if (skewY) {
            temp = Math.tan(skewY);
            temp = Math.sqrt(1 + temp * temp);
            a11 *= temp;
            a21 *= temp;
          }
        }
  
        a11 = _round(a11);
        a21 = _round(a21);
        a12 = _round(a12);
        a22 = _round(a22);
      } else {
        a11 = scaleX;
        a22 = scaleY;
        a21 = a12 = 0;
      }
  
      if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
        tx = _convertToUnit(target, "x", x, "px");
        ty = _convertToUnit(target, "y", y, "px");
      }
  
      if (xOrigin || yOrigin || xOffset || yOffset) {
        tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
        ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
      }
  
      if (xPercent || yPercent) {
        temp = target.getBBox();
        tx = _round(tx + xPercent / 100 * temp.width);
        ty = _round(ty + yPercent / 100 * temp.height);
      }
  
      temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
      target.setAttribute("transform", temp);
      forceCSS && (target.style[_transformProp] = temp);
    },
        _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
      var cap = 360,
          isString = _isString(endValue),
          endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
          change = endNum - startNum,
          finalValue = startNum + change + "deg",
          direction,
          pt;
  
      if (isString) {
        direction = endValue.split("_")[1];
  
        if (direction === "short") {
          change %= cap;
  
          if (change !== change % (cap / 2)) {
            change += change < 0 ? cap : -cap;
          }
        }
  
        if (direction === "cw" && change < 0) {
          change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap;
        } else if (direction === "ccw" && change > 0) {
          change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;
        }
      }
  
      plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
      pt.e = finalValue;
      pt.u = "deg";
  
      plugin._props.push(property);
  
      return pt;
    },
        _assign = function _assign(target, source) {
      for (var p in source) {
        target[p] = source[p];
      }
  
      return target;
    },
        _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
      var startCache = _assign({}, target._gsap),
          exclude = "perspective,force3D,transformOrigin,svgOrigin",
          style = target.style,
          endCache,
          p,
          startValue,
          endValue,
          startNum,
          endNum,
          startUnit,
          endUnit;
  
      if (startCache.svg) {
        startValue = target.getAttribute("transform");
        target.setAttribute("transform", "");
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
  
        _removeProperty(target, _transformProp);
  
        target.setAttribute("transform", startValue);
      } else {
        startValue = getComputedStyle(target)[_transformProp];
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
        style[_transformProp] = startValue;
      }
  
      for (p in _transformProps) {
        startValue = startCache[p];
        endValue = endCache[p];
  
        if (startValue !== endValue && exclude.indexOf(p) < 0) {
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
          startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
          endNum = parseFloat(endValue);
          plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
          plugin._pt.u = endUnit || 0;
  
          plugin._props.push(p);
        }
      }
  
      _assign(endCache, startCache);
    };
  
    _forEachName("padding,margin,Width,Radius", function (name, index) {
      var t = "Top",
          r = "Right",
          b = "Bottom",
          l = "Left",
          props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
        return index < 2 ? name + side : "border" + side + name;
      });
  
      _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
        var a, vars;
  
        if (arguments.length < 4) {
          a = props.map(function (prop) {
            return _get(plugin, prop, property);
          });
          vars = a.join(" ");
          return vars.split(a[0]).length === 5 ? a[0] : vars;
        }
  
        a = (endValue + "").split(" ");
        vars = {};
        props.forEach(function (prop, i) {
          return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
        });
        plugin.init(target, vars, tween);
      };
    });
  
    var CSSPlugin = {
      name: "css",
      register: _initCore,
      targetTest: function targetTest(target) {
        return target.style && target.nodeType;
      },
      init: function init(target, vars, tween, index, targets) {
        var props = this._props,
            style = target.style,
            startAt = tween.vars.startAt,
            startValue,
            endValue,
            endNum,
            startNum,
            type,
            specialProp,
            p,
            startUnit,
            endUnit,
            relative,
            isTransformRelated,
            transformPropTween,
            cache,
            smooth,
            hasPriority,
            inlineProps;
        _pluginInitted || _initCore();
        this.styles = this.styles || _getStyleSaver(target);
        inlineProps = this.styles.props;
        this.tween = tween;
  
        for (p in vars) {
          if (p === "autoRound") {
            continue;
          }
  
          endValue = vars[p];
  
          if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
            continue;
          }
  
          type = typeof endValue;
          specialProp = _specialProps[p];
  
          if (type === "function") {
            endValue = endValue.call(tween, index, target, targets);
            type = typeof endValue;
          }
  
          if (type === "string" && ~endValue.indexOf("random(")) {
            endValue = _replaceRandom(endValue);
          }
  
          if (specialProp) {
            specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
          } else if (p.substr(0, 2) === "--") {
            startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
            endValue += "";
            _colorExp.lastIndex = 0;
  
            if (!_colorExp.test(startValue)) {
              startUnit = getUnit(startValue);
              endUnit = getUnit(endValue);
            }
  
            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
            this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
            props.push(p);
            inlineProps.push(p, 0, style[p]);
          } else if (type !== "undefined") {
            if (startAt && p in startAt) {
              startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
              _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
              getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
              (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
            } else {
              startValue = _get(target, p);
            }
  
            startNum = parseFloat(startValue);
            relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
            relative && (endValue = endValue.substr(2));
            endNum = parseFloat(endValue);
  
            if (p in _propertyAliases) {
              if (p === "autoAlpha") {
                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                  startNum = 0;
                }
  
                inlineProps.push("visibility", 0, style.visibility);
  
                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
              }
  
              if (p !== "scale" && p !== "transform") {
                p = _propertyAliases[p];
                ~p.indexOf(",") && (p = p.split(",")[0]);
              }
            }
  
            isTransformRelated = p in _transformProps;
  
            if (isTransformRelated) {
              this.styles.save(p);
  
              if (!transformPropTween) {
                cache = target._gsap;
                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                smooth = vars.smoothOrigin !== false && cache.smooth;
                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                transformPropTween.dep = 1;
              }
  
              if (p === "scale") {
                this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                this._pt.u = 0;
                props.push("scaleY", p);
                p += "X";
              } else if (p === "transformOrigin") {
                inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                endValue = _convertKeywordsToPercentages(endValue);
  
                if (cache.svg) {
                  _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                } else {
                  endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                  endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
  
                  _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                }
  
                continue;
              } else if (p === "svgOrigin") {
                _applySVGOrigin(target, endValue, 1, smooth, 0, this);
  
                continue;
              } else if (p in _rotationalProperties) {
                _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
  
                continue;
              } else if (p === "smoothOrigin") {
                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
  
                continue;
              } else if (p === "force3D") {
                cache[p] = endValue;
                continue;
              } else if (p === "transform") {
                _addRawTransformPTs(this, endValue, target);
  
                continue;
              }
            } else if (!(p in style)) {
              p = _checkPropPrefix(p) || p;
            }
  
            if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
              startUnit = (startValue + "").substr((startNum + "").length);
              endNum || (endNum = 0);
              endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
              startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
              this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
              this._pt.u = endUnit || 0;
  
              if (startUnit !== endUnit && endUnit !== "%") {
                this._pt.b = startValue;
                this._pt.r = _renderCSSPropWithBeginning;
              }
            } else if (!(p in style)) {
              if (p in target) {
                this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
              } else if (p !== "parseTransform") {
                _missingPlugin(p, endValue);
  
                continue;
              }
            } else {
              _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
            }
  
            isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
            props.push(p);
          }
        }
  
        hasPriority && _sortPropTweensByPriority(this);
      },
      render: function render(ratio, data) {
        if (data.tween._time || !_reverting$1()) {
          var pt = data._pt;
  
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
        } else {
          data.styles.revert();
        }
      },
      get: _get,
      aliases: _propertyAliases,
      getSetter: function getSetter(target, property, plugin) {
        var p = _propertyAliases[property];
        p && p.indexOf(",") < 0 && (property = p);
        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
      },
      core: {
        _removeProperty: _removeProperty,
        _getMatrix: _getMatrix
      }
    };
    gsap.utils.checkPrefix = _checkPropPrefix;
    gsap.core.getStyleSaver = _getStyleSaver;
  
    (function (positionAndScale, rotation, others, aliases) {
      var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
        _transformProps[name] = 1;
      });
  
      _forEachName(rotation, function (name) {
        _config.units[name] = "deg";
        _rotationalProperties[name] = 1;
      });
  
      _propertyAliases[all[13]] = positionAndScale + "," + rotation;
  
      _forEachName(aliases, function (name) {
        var split = name.split(":");
        _propertyAliases[split[1]] = all[split[0]];
      });
    })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  
    _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
      _config.units[name] = "px";
    });
  
    gsap.registerPlugin(CSSPlugin);
  
    var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
        TweenMaxWithCSS = gsapWithCSS.core.Tween;
  
    exports.Back = Back;
    exports.Bounce = Bounce;
    exports.CSSPlugin = CSSPlugin;
    exports.Circ = Circ;
    exports.Cubic = Cubic;
    exports.Elastic = Elastic;
    exports.Expo = Expo;
    exports.Linear = Linear;
    exports.Power0 = Power0;
    exports.Power1 = Power1;
    exports.Power2 = Power2;
    exports.Power3 = Power3;
    exports.Power4 = Power4;
    exports.Quad = Quad;
    exports.Quart = Quart;
    exports.Quint = Quint;
    exports.Sine = Sine;
    exports.SteppedEase = SteppedEase;
    exports.Strong = Strong;
    exports.TimelineLite = Timeline;
    exports.TimelineMax = Timeline;
    exports.TweenLite = Tween;
    exports.TweenMax = TweenMaxWithCSS;
    exports.default = gsapWithCSS;
    exports.gsap = gsapWithCSS;
  
    if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}
  
  })));
  
/**
 * Skipped minification because the original files appears to be already minified.
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
 !function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t=t||self).barba=n()}(this,(function(){function t(t,n){for(var r=0;r<n.length;r++){var e=n[r];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(t,e.key,e)}}function n(n,r,e){return r&&t(n.prototype,r),e&&t(n,e),n}function r(){return(r=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e])}return t}).apply(this,arguments)}function e(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n}function i(t){return(i=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function o(t,n){return(o=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function u(t,n,r){return(u=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}()?Reflect.construct:function(t,n,r){var e=[null];e.push.apply(e,n);var i=new(Function.bind.apply(t,e));return r&&o(i,r.prototype),i}).apply(null,arguments)}function f(t){var n="function"==typeof Map?new Map:void 0;return(f=function(t){if(null===t||-1===Function.toString.call(t).indexOf("[native code]"))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(t))return n.get(t);n.set(t,r)}function r(){return u(t,arguments,i(this).constructor)}return r.prototype=Object.create(t.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),o(r,t)})(t)}function s(t,n){try{var r=t()}catch(t){return n(t)}return r&&r.then?r.then(void 0,n):r}"undefined"!=typeof Symbol&&(Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator"))),"undefined"!=typeof Symbol&&(Symbol.asyncIterator||(Symbol.asyncIterator=Symbol("Symbol.asyncIterator")));var c,a="2.9.7",h=function(){};!function(t){t[t.off=0]="off",t[t.error=1]="error",t[t.warning=2]="warning",t[t.info=3]="info",t[t.debug=4]="debug"}(c||(c={}));var v=c.off,l=function(){function t(t){this.t=t}t.getLevel=function(){return v},t.setLevel=function(t){return v=c[t]};var n=t.prototype;return n.error=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.error,c.error,n)},n.warn=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.warn,c.warning,n)},n.info=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.info,c.info,n)},n.debug=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];this.i(console.log,c.debug,n)},n.i=function(n,r,e){r<=t.getLevel()&&n.apply(console,["["+this.t+"] "].concat(e))},t}(),d=O,m=E,p=g,w=x,b=T,y="/",P=new RegExp(["(\\\\.)","(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");function g(t,n){for(var r,e=[],i=0,o=0,u="",f=n&&n.delimiter||y,s=n&&n.whitelist||void 0,c=!1;null!==(r=P.exec(t));){var a=r[0],h=r[1],v=r.index;if(u+=t.slice(o,v),o=v+a.length,h)u+=h[1],c=!0;else{var l="",d=r[2],m=r[3],p=r[4],w=r[5];if(!c&&u.length){var b=u.length-1,g=u[b];(!s||s.indexOf(g)>-1)&&(l=g,u=u.slice(0,b))}u&&(e.push(u),u="",c=!1);var E=m||p,x=l||f;e.push({name:d||i++,prefix:l,delimiter:x,optional:"?"===w||"*"===w,repeat:"+"===w||"*"===w,pattern:E?A(E):"[^"+k(x===f?x:x+f)+"]+?"})}}return(u||o<t.length)&&e.push(u+t.substr(o)),e}function E(t,n){return function(r,e){var i=t.exec(r);if(!i)return!1;for(var o=i[0],u=i.index,f={},s=e&&e.decode||decodeURIComponent,c=1;c<i.length;c++)if(void 0!==i[c]){var a=n[c-1];f[a.name]=a.repeat?i[c].split(a.delimiter).map((function(t){return s(t,a)})):s(i[c],a)}return{path:o,index:u,params:f}}}function x(t,n){for(var r=new Array(t.length),e=0;e<t.length;e++)"object"==typeof t[e]&&(r[e]=new RegExp("^(?:"+t[e].pattern+")$",R(n)));return function(n,e){for(var i="",o=e&&e.encode||encodeURIComponent,u=!e||!1!==e.validate,f=0;f<t.length;f++){var s=t[f];if("string"!=typeof s){var c,a=n?n[s.name]:void 0;if(Array.isArray(a)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but got array');if(0===a.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var h=0;h<a.length;h++){if(c=o(a[h],s),u&&!r[f].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'"');i+=(0===h?s.prefix:s.delimiter)+c}}else if("string"!=typeof a&&"number"!=typeof a&&"boolean"!=typeof a){if(!s.optional)throw new TypeError('Expected "'+s.name+'" to be '+(s.repeat?"an array":"a string"))}else{if(c=o(String(a),s),u&&!r[f].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but got "'+c+'"');i+=s.prefix+c}}else i+=s}return i}}function k(t){return t.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function A(t){return t.replace(/([=!:$/()])/g,"\\$1")}function R(t){return t&&t.sensitive?"":"i"}function T(t,n,r){for(var e=(r=r||{}).strict,i=!1!==r.start,o=!1!==r.end,u=r.delimiter||y,f=[].concat(r.endsWith||[]).map(k).concat("$").join("|"),s=i?"^":"",c=0;c<t.length;c++){var a=t[c];if("string"==typeof a)s+=k(a);else{var h=a.repeat?"(?:"+a.pattern+")(?:"+k(a.delimiter)+"(?:"+a.pattern+"))*":a.pattern;n&&n.push(a),s+=a.optional?a.prefix?"(?:"+k(a.prefix)+"("+h+"))?":"("+h+")?":k(a.prefix)+"("+h+")"}}if(o)e||(s+="(?:"+k(u)+")?"),s+="$"===f?"$":"(?="+f+")";else{var v=t[t.length-1],l="string"==typeof v?v[v.length-1]===u:void 0===v;e||(s+="(?:"+k(u)+"(?="+f+"))?"),l||(s+="(?="+k(u)+"|"+f+")")}return new RegExp(s,R(r))}function O(t,n,r){return t instanceof RegExp?function(t,n){if(!n)return t;var r=t.source.match(/\((?!\?)/g);if(r)for(var e=0;e<r.length;e++)n.push({name:e,prefix:null,delimiter:null,optional:!1,repeat:!1,pattern:null});return t}(t,n):Array.isArray(t)?function(t,n,r){for(var e=[],i=0;i<t.length;i++)e.push(O(t[i],n,r).source);return new RegExp("(?:"+e.join("|")+")",R(r))}(t,n,r):function(t,n,r){return T(g(t,r),n,r)}(t,n,r)}d.match=function(t,n){var r=[];return E(O(t,r,n),r)},d.regexpToFunction=m,d.parse=p,d.compile=function(t,n){return x(g(t,n),n)},d.tokensToFunction=w,d.tokensToRegExp=b;var S={container:"container",history:"history",namespace:"namespace",prefix:"data-barba",prevent:"prevent",wrapper:"wrapper"},j=new(function(){function t(){this.o=S,this.u=new DOMParser}var n=t.prototype;return n.toString=function(t){return t.outerHTML},n.toDocument=function(t){return this.u.parseFromString(t,"text/html")},n.toElement=function(t){var n=document.createElement("div");return n.innerHTML=t,n},n.getHtml=function(t){return void 0===t&&(t=document),this.toString(t.documentElement)},n.getWrapper=function(t){return void 0===t&&(t=document),t.querySelector("["+this.o.prefix+'="'+this.o.wrapper+'"]')},n.getContainer=function(t){return void 0===t&&(t=document),t.querySelector("["+this.o.prefix+'="'+this.o.container+'"]')},n.removeContainer=function(t){document.body.contains(t)&&t.parentNode.removeChild(t)},n.addContainer=function(t,n){var r=this.getContainer();r?this.s(t,r):n.appendChild(t)},n.getNamespace=function(t){void 0===t&&(t=document);var n=t.querySelector("["+this.o.prefix+"-"+this.o.namespace+"]");return n?n.getAttribute(this.o.prefix+"-"+this.o.namespace):null},n.getHref=function(t){if(t.tagName&&"a"===t.tagName.toLowerCase()){if("string"==typeof t.href)return t.href;var n=t.getAttribute("href")||t.getAttribute("xlink:href");if(n)return this.resolveUrl(n.baseVal||n)}return null},n.resolveUrl=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];var e=n.length;if(0===e)throw new Error("resolveUrl requires at least one argument; got none.");var i=document.createElement("base");if(i.href=arguments[0],1===e)return i.href;var o=document.getElementsByTagName("head")[0];o.insertBefore(i,o.firstChild);for(var u,f=document.createElement("a"),s=1;s<e;s++)f.href=arguments[s],i.href=u=f.href;return o.removeChild(i),u},n.s=function(t,n){n.parentNode.insertBefore(t,n.nextSibling)},t}()),M=new(function(){function t(){this.h=[],this.v=-1}var e=t.prototype;return e.init=function(t,n){this.l="barba";var r={ns:n,scroll:{x:window.scrollX,y:window.scrollY},url:t};this.h.push(r),this.v=0;var e={from:this.l,index:0,states:[].concat(this.h)};window.history&&window.history.replaceState(e,"",t)},e.change=function(t,n,r){if(r&&r.state){var e=r.state,i=e.index;n=this.m(this.v-i),this.replace(e.states),this.v=i}else this.add(t,n);return n},e.add=function(t,n){var r=this.size,e=this.p(n),i={ns:"tmp",scroll:{x:window.scrollX,y:window.scrollY},url:t};this.h.push(i),this.v=r;var o={from:this.l,index:r,states:[].concat(this.h)};switch(e){case"push":window.history&&window.history.pushState(o,"",t);break;case"replace":window.history&&window.history.replaceState(o,"",t)}},e.update=function(t,n){var e=n||this.v,i=r({},this.get(e),{},t);this.set(e,i)},e.remove=function(t){t?this.h.splice(t,1):this.h.pop(),this.v--},e.clear=function(){this.h=[],this.v=-1},e.replace=function(t){this.h=t},e.get=function(t){return this.h[t]},e.set=function(t,n){return this.h[t]=n},e.p=function(t){var n="push",r=t,e=S.prefix+"-"+S.history;return r.hasAttribute&&r.hasAttribute(e)&&(n=r.getAttribute(e)),n},e.m=function(t){return Math.abs(t)>1?t>0?"forward":"back":0===t?"popstate":t>0?"back":"forward"},n(t,[{key:"current",get:function(){return this.h[this.v]}},{key:"state",get:function(){return this.h[this.h.length-1]}},{key:"previous",get:function(){return this.v<1?null:this.h[this.v-1]}},{key:"size",get:function(){return this.h.length}}]),t}()),L=function(t,n){try{var r=function(){if(!n.next.html)return Promise.resolve(t).then((function(t){var r=n.next;if(t){var e=j.toElement(t);r.namespace=j.getNamespace(e),r.container=j.getContainer(e),r.html=t,M.update({ns:r.namespace});var i=j.toDocument(t);document.title=i.title}}))}();return Promise.resolve(r&&r.then?r.then((function(){})):void 0)}catch(t){return Promise.reject(t)}},$=d,_={__proto__:null,update:L,nextTick:function(){return new Promise((function(t){window.requestAnimationFrame(t)}))},pathToRegexp:$},q=function(){return window.location.origin},B=function(t){return void 0===t&&(t=window.location.href),U(t).port},U=function(t){var n,r=t.match(/:\d+/);if(null===r)/^http/.test(t)&&(n=80),/^https/.test(t)&&(n=443);else{var e=r[0].substring(1);n=parseInt(e,10)}var i,o=t.replace(q(),""),u={},f=o.indexOf("#");f>=0&&(i=o.slice(f+1),o=o.slice(0,f));var s=o.indexOf("?");return s>=0&&(u=D(o.slice(s+1)),o=o.slice(0,s)),{hash:i,path:o,port:n,query:u}},D=function(t){return t.split("&").reduce((function(t,n){var r=n.split("=");return t[r[0]]=r[1],t}),{})},F=function(t){return void 0===t&&(t=window.location.href),t.replace(/(\/#.*|\/|#.*)$/,"")},H={__proto__:null,getHref:function(){return window.location.href},getOrigin:q,getPort:B,getPath:function(t){return void 0===t&&(t=window.location.href),U(t).path},parse:U,parseQuery:D,clean:F};function I(t,n,r){return void 0===n&&(n=2e3),new Promise((function(e,i){var o=new XMLHttpRequest;o.onreadystatechange=function(){if(o.readyState===XMLHttpRequest.DONE)if(200===o.status)e(o.responseText);else if(o.status){var n={status:o.status,statusText:o.statusText};r(t,n),i(n)}},o.ontimeout=function(){var e=new Error("Timeout error ["+n+"]");r(t,e),i(e)},o.onerror=function(){var n=new Error("Fetch error");r(t,n),i(n)},o.open("GET",t),o.timeout=n,o.setRequestHeader("Accept","text/html,application/xhtml+xml,application/xml"),o.setRequestHeader("x-barba","yes"),o.send()}))}var C=function(t){return!!t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof t.then};function N(t,n){return void 0===n&&(n={}),function(){for(var r=arguments.length,e=new Array(r),i=0;i<r;i++)e[i]=arguments[i];var o=!1,u=new Promise((function(r,i){n.async=function(){return o=!0,function(t,n){t?i(t):r(n)}};var u=t.apply(n,e);o||(C(u)?u.then(r,i):r(u))}));return u}}var X=new(function(t){function n(){var n;return(n=t.call(this)||this).logger=new l("@barba/core"),n.all=["ready","page","reset","currentAdded","currentRemoved","nextAdded","nextRemoved","beforeOnce","once","afterOnce","before","beforeLeave","leave","afterLeave","beforeEnter","enter","afterEnter","after"],n.registered=new Map,n.init(),n}e(n,t);var r=n.prototype;return r.init=function(){var t=this;this.registered.clear(),this.all.forEach((function(n){t[n]||(t[n]=function(r,e){t.registered.has(n)||t.registered.set(n,new Set),t.registered.get(n).add({ctx:e||{},fn:r})})}))},r.do=function(t){for(var n=this,r=arguments.length,e=new Array(r>1?r-1:0),i=1;i<r;i++)e[i-1]=arguments[i];if(this.registered.has(t)){var o=Promise.resolve();return this.registered.get(t).forEach((function(t){o=o.then((function(){return N(t.fn,t.ctx).apply(void 0,e)}))})),o.catch((function(r){n.logger.debug("Hook error ["+t+"]"),n.logger.error(r)}))}return Promise.resolve()},r.clear=function(){var t=this;this.all.forEach((function(n){delete t[n]})),this.init()},r.help=function(){this.logger.info("Available hooks: "+this.all.join(","));var t=[];this.registered.forEach((function(n,r){return t.push(r)})),this.logger.info("Registered hooks: "+t.join(","))},n}(h)),z=function(){function t(t){if(this.P=[],"boolean"==typeof t)this.g=t;else{var n=Array.isArray(t)?t:[t];this.P=n.map((function(t){return $(t)}))}}return t.prototype.checkHref=function(t){if("boolean"==typeof this.g)return this.g;var n=U(t).path;return this.P.some((function(t){return null!==t.exec(n)}))},t}(),G=function(t){function n(n){var r;return(r=t.call(this,n)||this).k=new Map,r}e(n,t);var i=n.prototype;return i.set=function(t,n,r){return this.k.set(t,{action:r,request:n}),{action:r,request:n}},i.get=function(t){return this.k.get(t)},i.getRequest=function(t){return this.k.get(t).request},i.getAction=function(t){return this.k.get(t).action},i.has=function(t){return!this.checkHref(t)&&this.k.has(t)},i.delete=function(t){return this.k.delete(t)},i.update=function(t,n){var e=r({},this.k.get(t),{},n);return this.k.set(t,e),e},n}(z),Q=function(){return!window.history.pushState},W=function(t){return!t.el||!t.href},J=function(t){var n=t.event;return n.which>1||n.metaKey||n.ctrlKey||n.shiftKey||n.altKey},K=function(t){var n=t.el;return n.hasAttribute("target")&&"_blank"===n.target},V=function(t){var n=t.el;return void 0!==n.protocol&&window.location.protocol!==n.protocol||void 0!==n.hostname&&window.location.hostname!==n.hostname},Y=function(t){var n=t.el;return void 0!==n.port&&B()!==B(n.href)},Z=function(t){var n=t.el;return n.getAttribute&&"string"==typeof n.getAttribute("download")},tt=function(t){return t.el.hasAttribute(S.prefix+"-"+S.prevent)},nt=function(t){return Boolean(t.el.closest("["+S.prefix+"-"+S.prevent+'="all"]'))},rt=function(t){var n=t.href;return F(n)===F()&&B(n)===B()},et=function(t){function n(n){var r;return(r=t.call(this,n)||this).suite=[],r.tests=new Map,r.init(),r}e(n,t);var r=n.prototype;return r.init=function(){this.add("pushState",Q),this.add("exists",W),this.add("newTab",J),this.add("blank",K),this.add("corsDomain",V),this.add("corsPort",Y),this.add("download",Z),this.add("preventSelf",tt),this.add("preventAll",nt),this.add("sameUrl",rt,!1)},r.add=function(t,n,r){void 0===r&&(r=!0),this.tests.set(t,n),r&&this.suite.push(t)},r.run=function(t,n,r,e){return this.tests.get(t)({el:n,event:r,href:e})},r.checkLink=function(t,n,r){var e=this;return this.suite.some((function(i){return e.run(i,t,n,r)}))},n}(z),it=function(t){function n(r,e){var i;void 0===e&&(e="Barba error");for(var o=arguments.length,u=new Array(o>2?o-2:0),f=2;f<o;f++)u[f-2]=arguments[f];return(i=t.call.apply(t,[this].concat(u))||this).error=r,i.label=e,Error.captureStackTrace&&Error.captureStackTrace(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(i),n),i.name="BarbaError",i}return e(n,t),n}(f(Error)),ot=function(){function t(t){void 0===t&&(t=[]),this.logger=new l("@barba/core"),this.all=[],this.page=[],this.once=[],this.A=[{name:"namespace",type:"strings"},{name:"custom",type:"function"}],t&&(this.all=this.all.concat(t)),this.update()}var n=t.prototype;return n.add=function(t,n){switch(t){case"rule":this.A.splice(n.position||0,0,n.value);break;case"transition":default:this.all.push(n)}this.update()},n.resolve=function(t,n){var r=this;void 0===n&&(n={});var e=n.once?this.once:this.page;e=e.filter(n.self?function(t){return t.name&&"self"===t.name}:function(t){return!t.name||"self"!==t.name});var i=new Map,o=e.find((function(e){var o=!0,u={};return!(!n.self||"self"!==e.name)||(r.A.reverse().forEach((function(n){o&&(o=r.R(e,n,t,u),e.from&&e.to&&(o=r.R(e,n,t,u,"from")&&r.R(e,n,t,u,"to")),e.from&&!e.to&&(o=r.R(e,n,t,u,"from")),!e.from&&e.to&&(o=r.R(e,n,t,u,"to")))})),i.set(e,u),o)})),u=i.get(o),f=[];if(f.push(n.once?"once":"page"),n.self&&f.push("self"),u){var s,c=[o];Object.keys(u).length>0&&c.push(u),(s=this.logger).info.apply(s,["Transition found ["+f.join(",")+"]"].concat(c))}else this.logger.info("No transition found ["+f.join(",")+"]");return o},n.update=function(){var t=this;this.all=this.all.map((function(n){return t.T(n)})).sort((function(t,n){return t.priority-n.priority})).reverse().map((function(t){return delete t.priority,t})),this.page=this.all.filter((function(t){return void 0!==t.leave||void 0!==t.enter})),this.once=this.all.filter((function(t){return void 0!==t.once}))},n.R=function(t,n,r,e,i){var o=!0,u=!1,f=t,s=n.name,c=s,a=s,h=s,v=i?f[i]:f,l="to"===i?r.next:r.current;if(i?v&&v[s]:v[s]){switch(n.type){case"strings":default:var d=Array.isArray(v[c])?v[c]:[v[c]];l[c]&&-1!==d.indexOf(l[c])&&(u=!0),-1===d.indexOf(l[c])&&(o=!1);break;case"object":var m=Array.isArray(v[a])?v[a]:[v[a]];l[a]?(l[a].name&&-1!==m.indexOf(l[a].name)&&(u=!0),-1===m.indexOf(l[a].name)&&(o=!1)):o=!1;break;case"function":v[h](r)?u=!0:o=!1}u&&(i?(e[i]=e[i]||{},e[i][s]=f[i][s]):e[s]=f[s])}return o},n.O=function(t,n,r){var e=0;return(t[n]||t.from&&t.from[n]||t.to&&t.to[n])&&(e+=Math.pow(10,r),t.from&&t.from[n]&&(e+=1),t.to&&t.to[n]&&(e+=2)),e},n.T=function(t){var n=this;t.priority=0;var r=0;return this.A.forEach((function(e,i){r+=n.O(t,e.name,i+1)})),t.priority=r,t},t}(),ut=function(){function t(t){void 0===t&&(t=[]),this.logger=new l("@barba/core"),this.S=!1,this.store=new ot(t)}var r=t.prototype;return r.get=function(t,n){return this.store.resolve(t,n)},r.doOnce=function(t){var n=t.data,r=t.transition;try{var e=function(){i.S=!1},i=this,o=r||{};i.S=!0;var u=s((function(){return Promise.resolve(i.j("beforeOnce",n,o)).then((function(){return Promise.resolve(i.once(n,o)).then((function(){return Promise.resolve(i.j("afterOnce",n,o)).then((function(){}))}))}))}),(function(t){i.S=!1,i.logger.debug("Transition error [before/after/once]"),i.logger.error(t)}));return Promise.resolve(u&&u.then?u.then(e):e())}catch(t){return Promise.reject(t)}},r.doPage=function(t){var n=t.data,r=t.transition,e=t.page,i=t.wrapper;try{var o=function(t){if(u)return t;f.S=!1},u=!1,f=this,c=r||{},a=!0===c.sync||!1;f.S=!0;var h=s((function(){function t(){return Promise.resolve(f.j("before",n,c)).then((function(){var t=!1;function r(r){return t?r:Promise.resolve(f.remove(n)).then((function(){return Promise.resolve(f.j("after",n,c)).then((function(){}))}))}var o=function(){if(a)return s((function(){return Promise.resolve(f.add(n,i)).then((function(){return Promise.resolve(f.j("beforeLeave",n,c)).then((function(){return Promise.resolve(f.j("beforeEnter",n,c)).then((function(){return Promise.resolve(Promise.all([f.leave(n,c),f.enter(n,c)])).then((function(){return Promise.resolve(f.j("afterLeave",n,c)).then((function(){return Promise.resolve(f.j("afterEnter",n,c)).then((function(){}))}))}))}))}))}))}),(function(t){if(f.M(t))throw new it(t,"Transition error [sync]")}));var r=function(r){return t?r:s((function(){var t=function(){if(!1!==o)return Promise.resolve(f.add(n,i)).then((function(){return Promise.resolve(f.j("beforeEnter",n,c)).then((function(){return Promise.resolve(f.enter(n,c,o)).then((function(){return Promise.resolve(f.j("afterEnter",n,c)).then((function(){}))}))}))}))}();if(t&&t.then)return t.then((function(){}))}),(function(t){if(f.M(t))throw new it(t,"Transition error [before/after/enter]")}))},o=!1,u=s((function(){return Promise.resolve(f.j("beforeLeave",n,c)).then((function(){return Promise.resolve(Promise.all([f.leave(n,c),L(e,n)]).then((function(t){return t[0]}))).then((function(t){return o=t,Promise.resolve(f.j("afterLeave",n,c)).then((function(){}))}))}))}),(function(t){if(f.M(t))throw new it(t,"Transition error [before/after/leave]")}));return u&&u.then?u.then(r):r(u)}();return o&&o.then?o.then(r):r(o)}))}var r=function(){if(a)return Promise.resolve(L(e,n)).then((function(){}))}();return r&&r.then?r.then(t):t()}),(function(t){if(f.S=!1,t.name&&"BarbaError"===t.name)throw f.logger.debug(t.label),f.logger.error(t.error),t;throw f.logger.debug("Transition error [page]"),f.logger.error(t),t}));return Promise.resolve(h&&h.then?h.then(o):o(h))}catch(t){return Promise.reject(t)}},r.once=function(t,n){try{return Promise.resolve(X.do("once",t,n)).then((function(){return n.once?N(n.once,n)(t):Promise.resolve()}))}catch(t){return Promise.reject(t)}},r.leave=function(t,n){try{return Promise.resolve(X.do("leave",t,n)).then((function(){return n.leave?N(n.leave,n)(t):Promise.resolve()}))}catch(t){return Promise.reject(t)}},r.enter=function(t,n,r){try{return Promise.resolve(X.do("enter",t,n)).then((function(){return n.enter?N(n.enter,n)(t,r):Promise.resolve()}))}catch(t){return Promise.reject(t)}},r.add=function(t,n){try{return j.addContainer(t.next.container,n),X.do("nextAdded",t),Promise.resolve()}catch(t){return Promise.reject(t)}},r.remove=function(t){try{return j.removeContainer(t.current.container),X.do("currentRemoved",t),Promise.resolve()}catch(t){return Promise.reject(t)}},r.M=function(t){return t.message?!/Timeout error|Fetch error/.test(t.message):!t.status},r.j=function(t,n,r){try{return Promise.resolve(X.do(t,n,r)).then((function(){return r[t]?N(r[t],r)(n):Promise.resolve()}))}catch(t){return Promise.reject(t)}},n(t,[{key:"isRunning",get:function(){return this.S},set:function(t){this.S=t}},{key:"hasOnce",get:function(){return this.store.once.length>0}},{key:"hasSelf",get:function(){return this.store.all.some((function(t){return"self"===t.name}))}},{key:"shouldWait",get:function(){return this.store.all.some((function(t){return t.to&&!t.to.route||t.sync}))}}]),t}(),ft=function(){function t(t){var n=this;this.names=["beforeLeave","afterLeave","beforeEnter","afterEnter"],this.byNamespace=new Map,0!==t.length&&(t.forEach((function(t){n.byNamespace.set(t.namespace,t)})),this.names.forEach((function(t){X[t](n.L(t))})))}return t.prototype.L=function(t){var n=this;return function(r){var e=t.match(/enter/i)?r.next:r.current,i=n.byNamespace.get(e.namespace);return i&&i[t]?N(i[t],i)(r):Promise.resolve()}},t}();Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),Element.prototype.closest||(Element.prototype.closest=function(t){var n=this;do{if(n.matches(t))return n;n=n.parentElement||n.parentNode}while(null!==n&&1===n.nodeType);return null});var st={container:null,html:"",namespace:"",url:{hash:"",href:"",path:"",port:null,query:{}}};return new(function(){function t(){this.version=a,this.schemaPage=st,this.Logger=l,this.logger=new l("@barba/core"),this.plugins=[],this.hooks=X,this.dom=j,this.helpers=_,this.history=M,this.request=I,this.url=H}var e=t.prototype;return e.use=function(t,n){var r=this.plugins;r.indexOf(t)>-1?this.logger.warn("Plugin ["+t.name+"] already installed."):"function"==typeof t.install?(t.install(this,n),r.push(t)):this.logger.warn("Plugin ["+t.name+'] has no "install" method.')},e.init=function(t){var n=void 0===t?{}:t,e=n.transitions,i=void 0===e?[]:e,o=n.views,u=void 0===o?[]:o,f=n.schema,s=void 0===f?S:f,c=n.requestError,a=n.timeout,h=void 0===a?2e3:a,v=n.cacheIgnore,d=void 0!==v&&v,m=n.prefetchIgnore,p=void 0!==m&&m,w=n.preventRunning,b=void 0!==w&&w,y=n.prevent,P=void 0===y?null:y,g=n.debug,E=n.logLevel;if(l.setLevel(!0===(void 0!==g&&g)?"debug":void 0===E?"off":E),this.logger.info(this.version),Object.keys(s).forEach((function(t){S[t]&&(S[t]=s[t])})),this.$=c,this.timeout=h,this.cacheIgnore=d,this.prefetchIgnore=p,this.preventRunning=b,this._=this.dom.getWrapper(),!this._)throw new Error("[@barba/core] No Barba wrapper found");this._.setAttribute("aria-live","polite"),this.q();var x=this.data.current;if(!x.container)throw new Error("[@barba/core] No Barba container found");if(this.cache=new G(d),this.prevent=new et(p),this.transitions=new ut(i),this.views=new ft(u),null!==P){if("function"!=typeof P)throw new Error("[@barba/core] Prevent should be a function");this.prevent.add("preventCustom",P)}this.history.init(x.url.href,x.namespace),this.B=this.B.bind(this),this.U=this.U.bind(this),this.D=this.D.bind(this),this.F(),this.plugins.forEach((function(t){return t.init()}));var k=this.data;k.trigger="barba",k.next=k.current,k.current=r({},this.schemaPage),this.hooks.do("ready",k),this.once(k),this.q()},e.destroy=function(){this.q(),this.H(),this.history.clear(),this.hooks.clear(),this.plugins=[]},e.force=function(t){window.location.assign(t)},e.go=function(t,n,r){var e;if(void 0===n&&(n="barba"),this.transitions.isRunning)this.force(t);else if(!(e="popstate"===n?this.history.current&&this.url.getPath(this.history.current.url)===this.url.getPath(t):this.prevent.run("sameUrl",null,null,t))||this.transitions.hasSelf)return n=this.history.change(t,n,r),r&&(r.stopPropagation(),r.preventDefault()),this.page(t,n,e)},e.once=function(t){try{var n=this;return Promise.resolve(n.hooks.do("beforeEnter",t)).then((function(){function r(){return Promise.resolve(n.hooks.do("afterEnter",t)).then((function(){}))}var e=function(){if(n.transitions.hasOnce){var r=n.transitions.get(t,{once:!0});return Promise.resolve(n.transitions.doOnce({transition:r,data:t})).then((function(){}))}}();return e&&e.then?e.then(r):r()}))}catch(t){return Promise.reject(t)}},e.page=function(t,n,e){try{var i=function(){var t=o.data;return Promise.resolve(o.hooks.do("page",t)).then((function(){var n=s((function(){var n=o.transitions.get(t,{once:!1,self:e});return Promise.resolve(o.transitions.doPage({data:t,page:u,transition:n,wrapper:o._})).then((function(){o.q()}))}),(function(){0===l.getLevel()&&o.force(t.current.url.href)}));if(n&&n.then)return n.then((function(){}))}))},o=this;o.data.next.url=r({href:t},o.url.parse(t)),o.data.trigger=n;var u=o.cache.has(t)?o.cache.update(t,{action:"click"}).request:o.cache.set(t,o.request(t,o.timeout,o.onRequestError.bind(o,n)),"click").request,f=function(){if(o.transitions.shouldWait)return Promise.resolve(L(u,o.data)).then((function(){}))}();return Promise.resolve(f&&f.then?f.then(i):i())}catch(t){return Promise.reject(t)}},e.onRequestError=function(t){this.transitions.isRunning=!1;for(var n=arguments.length,r=new Array(n>1?n-1:0),e=1;e<n;e++)r[e-1]=arguments[e];var i=r[0],o=r[1],u=this.cache.getAction(i);return this.cache.delete(i),!(this.$&&!1===this.$(t,u,i,o)||("click"===u&&this.force(i),1))},e.prefetch=function(t){var n=this;this.cache.has(t)||this.cache.set(t,this.request(t,this.timeout,this.onRequestError.bind(this,"barba")).catch((function(t){n.logger.error(t)})),"prefetch")},e.F=function(){!0!==this.prefetchIgnore&&(document.addEventListener("mouseover",this.B),document.addEventListener("touchstart",this.B)),document.addEventListener("click",this.U),window.addEventListener("popstate",this.D)},e.H=function(){!0!==this.prefetchIgnore&&(document.removeEventListener("mouseover",this.B),document.removeEventListener("touchstart",this.B)),document.removeEventListener("click",this.U),window.removeEventListener("popstate",this.D)},e.B=function(t){var n=this,r=this.I(t);if(r){var e=this.dom.getHref(r);this.prevent.checkHref(e)||this.cache.has(e)||this.cache.set(e,this.request(e,this.timeout,this.onRequestError.bind(this,r)).catch((function(t){n.logger.error(t)})),"enter")}},e.U=function(t){var n=this.I(t);if(n)return this.transitions.isRunning&&this.preventRunning?(t.preventDefault(),void t.stopPropagation()):void this.go(this.dom.getHref(n),n,t)},e.D=function(t){this.go(this.url.getHref(),"popstate",t)},e.I=function(t){for(var n=t.target;n&&!this.dom.getHref(n);)n=n.parentNode;if(n&&!this.prevent.checkLink(n,t,this.dom.getHref(n)))return n},e.q=function(){var t=this.url.getHref(),n={container:this.dom.getContainer(),html:this.dom.getHtml(),namespace:this.dom.getNamespace(),url:r({href:t},this.url.parse(t))};this.C={current:n,next:r({},this.schemaPage),trigger:void 0},this.hooks.do("reset",this.data)},n(t,[{key:"data",get:function(){return this.C}},{key:"wrapper",get:function(){return this._}}]),t}())}));
/**
 * Skipped minification because the original files appears to be already minified.
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
 !function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t=t||self).barbaPrefetch=i()}(this,function(){var t="2.1.10",i=window.requestIdleCallback||function(t){var i=Date.now();return setTimeout(function(){t({didTimeout:!1,timeRemaining:function(){return Math.max(0,50-(Date.now()-i))}})},1)};return new(function(){function n(){this.name="@barba/prefetch",this.version=t,this.toPrefetch=new Set}var e=n.prototype;return e.install=function(t,i){var n=void 0===i?{}:i,e=n.root,o=void 0===e?document.body:e,r=n.timeout,s=void 0===r?2e3:r;this.logger=new t.Logger(this.name),this.logger.info(this.version),this.barba=t,this.root=o,this.timeout=s},e.init=function(){var t=this;this.barba.prefetchIgnore?this.logger.warn("barba.prefetchIgnore is enabled"):this.barba.cacheIgnore?this.logger.warn("barba.cacheIgnore is enabled"):(this.observer=new IntersectionObserver(function(i){i.forEach(function(i){if(i.isIntersecting){var n=i.target,e=t.barba.dom.getHref(n);t.toPrefetch.has(e)&&(t.observer.unobserve(n),t.barba.cache.has(e)?t.barba.cache.update(e,{action:"prefetch"}):t.barba.cache.set(e,t.barba.request(e,t.barba.timeout,t.barba.onRequestError.bind(t.barba,"barba")).catch(function(i){t.logger.error(i)}),"prefetch"))}})}),this.observe(),this.barba.hooks.after(this.observe,this))},e.observe=function(){var t=this;i(function(){t.root.querySelectorAll("a").forEach(function(i){var n=i,e=t.barba.dom.getHref(n);t.barba.cache.has(e)||t.barba.prevent.checkHref(e)||t.barba.prevent.checkLink(n,{},e)||(t.observer.observe(i),t.toPrefetch.add(e))})},{timeout:this.timeout})},n}())});
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.window = global.window || {}));
  }(this, (function (exports) { 'use strict';
  
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
  
    /*!
     * Observer 3.11.4
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var gsap,
        _coreInitted,
        _clamp,
        _win,
        _doc,
        _docEl,
        _body,
        _isTouch,
        _pointerType,
        ScrollTrigger,
        _root,
        _normalizer,
        _eventTypes,
        _context,
        _getGSAP = function _getGSAP() {
      return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
    },
        _startup = 1,
        _observers = [],
        _scrollers = [],
        _proxies = [],
        _getTime = Date.now,
        _bridge = function _bridge(name, value) {
      return value;
    },
        _integrate = function _integrate() {
      var core = ScrollTrigger.core,
          data = core.bridge || {},
          scrollers = core._scrollers,
          proxies = core._proxies;
      scrollers.push.apply(scrollers, _scrollers);
      proxies.push.apply(proxies, _proxies);
      _scrollers = scrollers;
      _proxies = proxies;
  
      _bridge = function _bridge(name, value) {
        return data[name](value);
      };
    },
        _getProxyProp = function _getProxyProp(element, property) {
      return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
    },
        _isViewport = function _isViewport(el) {
      return !!~_root.indexOf(el);
    },
        _addListener = function _addListener(element, type, func, nonPassive, capture) {
      return element.addEventListener(type, func, {
        passive: !nonPassive,
        capture: !!capture
      });
    },
        _removeListener = function _removeListener(element, type, func, capture) {
      return element.removeEventListener(type, func, !!capture);
    },
        _scrollLeft = "scrollLeft",
        _scrollTop = "scrollTop",
        _onScroll = function _onScroll() {
      return _normalizer && _normalizer.isPressed || _scrollers.cache++;
    },
        _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
      var cachingFunc = function cachingFunc(value) {
        if (value || value === 0) {
          _startup && (_win.history.scrollRestoration = "manual");
          var isNormalizing = _normalizer && _normalizer.isPressed;
          value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
          f(value);
          cachingFunc.cacheID = _scrollers.cache;
          isNormalizing && _bridge("ss", value);
        } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
          cachingFunc.cacheID = _scrollers.cache;
          cachingFunc.v = f();
        }
  
        return cachingFunc.v + cachingFunc.offset;
      };
  
      cachingFunc.offset = 0;
      return f && cachingFunc;
    },
        _horizontal = {
      s: _scrollLeft,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: _scrollCacheFunc(function (value) {
        return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
      })
    },
        _vertical = {
      s: _scrollTop,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: _horizontal,
      sc: _scrollCacheFunc(function (value) {
        return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
      })
    },
        _getTarget = function _getTarget(t) {
      return gsap.utils.toArray(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
    },
        _getScrollFunc = function _getScrollFunc(element, _ref) {
      var s = _ref.s,
          sc = _ref.sc;
      _isViewport(element) && (element = _doc.scrollingElement || _docEl);
  
      var i = _scrollers.indexOf(element),
          offset = sc === _vertical.sc ? 1 : 2;
  
      !~i && (i = _scrollers.push(element) - 1);
      _scrollers[i + offset] || element.addEventListener("scroll", _onScroll);
      var prev = _scrollers[i + offset],
          func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
        return arguments.length ? element[s] = value : element[s];
      })));
      func.target = element;
      prev || (func.smooth = gsap.getProperty(element, "scrollBehavior") === "smooth");
      return func;
    },
        _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
      var v1 = value,
          v2 = value,
          t1 = _getTime(),
          t2 = t1,
          min = minTimeRefresh || 50,
          dropToZeroTime = Math.max(500, min * 3),
          update = function update(value, force) {
        var t = _getTime();
  
        if (force || t - t1 > min) {
          v2 = v1;
          v1 = value;
          t2 = t1;
          t1 = t;
        } else if (useDelta) {
          v1 += value;
        } else {
          v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
        }
      },
          reset = function reset() {
        v2 = v1 = useDelta ? 0 : v1;
        t2 = t1 = 0;
      },
          getVelocity = function getVelocity(latestValue) {
        var tOld = t2,
            vOld = v2,
            t = _getTime();
  
        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
      };
  
      return {
        update: update,
        reset: reset,
        getVelocity: getVelocity
      };
    },
        _getEvent = function _getEvent(e, preventDefault) {
      preventDefault && !e._gsapAllow && e.preventDefault();
      return e.changedTouches ? e.changedTouches[0] : e;
    },
        _getAbsoluteMax = function _getAbsoluteMax(a) {
      var max = Math.max.apply(Math, a),
          min = Math.min.apply(Math, a);
      return Math.abs(max) >= Math.abs(min) ? max : min;
    },
        _setScrollTrigger = function _setScrollTrigger() {
      ScrollTrigger = gsap.core.globals().ScrollTrigger;
      ScrollTrigger && ScrollTrigger.core && _integrate();
    },
        _initCore = function _initCore(core) {
      gsap = core || _getGSAP();
  
      if (gsap && typeof document !== "undefined" && document.body) {
        _win = window;
        _doc = document;
        _docEl = _doc.documentElement;
        _body = _doc.body;
        _root = [_win, _doc, _docEl, _body];
        _clamp = gsap.utils.clamp;
  
        _context = gsap.core.context || function () {};
  
        _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
        _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
        _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
        setTimeout(function () {
          return _startup = 0;
        }, 500);
  
        _setScrollTrigger();
  
        _coreInitted = 1;
      }
  
      return _coreInitted;
    };
  
    _horizontal.op = _vertical;
    _scrollers.cache = 0;
    var Observer = function () {
      function Observer(vars) {
        this.init(vars);
      }
  
      var _proto = Observer.prototype;
  
      _proto.init = function init(vars) {
        _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
        ScrollTrigger || _setScrollTrigger();
        var tolerance = vars.tolerance,
            dragMinimum = vars.dragMinimum,
            type = vars.type,
            target = vars.target,
            lineHeight = vars.lineHeight,
            debounce = vars.debounce,
            preventDefault = vars.preventDefault,
            onStop = vars.onStop,
            onStopDelay = vars.onStopDelay,
            ignore = vars.ignore,
            wheelSpeed = vars.wheelSpeed,
            event = vars.event,
            onDragStart = vars.onDragStart,
            onDragEnd = vars.onDragEnd,
            onDrag = vars.onDrag,
            onPress = vars.onPress,
            onRelease = vars.onRelease,
            onRight = vars.onRight,
            onLeft = vars.onLeft,
            onUp = vars.onUp,
            onDown = vars.onDown,
            onChangeX = vars.onChangeX,
            onChangeY = vars.onChangeY,
            onChange = vars.onChange,
            onToggleX = vars.onToggleX,
            onToggleY = vars.onToggleY,
            onHover = vars.onHover,
            onHoverEnd = vars.onHoverEnd,
            onMove = vars.onMove,
            ignoreCheck = vars.ignoreCheck,
            isNormalizer = vars.isNormalizer,
            onGestureStart = vars.onGestureStart,
            onGestureEnd = vars.onGestureEnd,
            onWheel = vars.onWheel,
            onEnable = vars.onEnable,
            onDisable = vars.onDisable,
            onClick = vars.onClick,
            scrollSpeed = vars.scrollSpeed,
            capture = vars.capture,
            allowClicks = vars.allowClicks,
            lockAxis = vars.lockAxis,
            onLockAxis = vars.onLockAxis;
        this.target = target = _getTarget(target) || _docEl;
        this.vars = vars;
        ignore && (ignore = gsap.utils.toArray(ignore));
        tolerance = tolerance || 1e-9;
        dragMinimum = dragMinimum || 0;
        wheelSpeed = wheelSpeed || 1;
        scrollSpeed = scrollSpeed || 1;
        type = type || "wheel,touch,pointer";
        debounce = debounce !== false;
        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);
  
        var id,
            onStopDelayedCall,
            dragged,
            moved,
            wheeled,
            locked,
            axis,
            self = this,
            prevDeltaX = 0,
            prevDeltaY = 0,
            scrollFuncX = _getScrollFunc(target, _horizontal),
            scrollFuncY = _getScrollFunc(target, _vertical),
            scrollX = scrollFuncX(),
            scrollY = scrollFuncY(),
            limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
            isViewport = _isViewport(target),
            ownerDoc = target.ownerDocument || _doc,
            deltaX = [0, 0, 0],
            deltaY = [0, 0, 0],
            onClickTime = 0,
            clickCapture = function clickCapture() {
          return onClickTime = _getTime();
        },
            _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
          return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
        },
            onStopFunc = function onStopFunc() {
          self._vx.reset();
  
          self._vy.reset();
  
          onStopDelayedCall.pause();
          onStop && onStop(self);
        },
            update = function update() {
          var dx = self.deltaX = _getAbsoluteMax(deltaX),
              dy = self.deltaY = _getAbsoluteMax(deltaY),
              changedX = Math.abs(dx) >= tolerance,
              changedY = Math.abs(dy) >= tolerance;
  
          onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
  
          if (changedX) {
            onRight && self.deltaX > 0 && onRight(self);
            onLeft && self.deltaX < 0 && onLeft(self);
            onChangeX && onChangeX(self);
            onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
            prevDeltaX = self.deltaX;
            deltaX[0] = deltaX[1] = deltaX[2] = 0;
          }
  
          if (changedY) {
            onDown && self.deltaY > 0 && onDown(self);
            onUp && self.deltaY < 0 && onUp(self);
            onChangeY && onChangeY(self);
            onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
            prevDeltaY = self.deltaY;
            deltaY[0] = deltaY[1] = deltaY[2] = 0;
          }
  
          if (moved || dragged) {
            onMove && onMove(self);
  
            if (dragged) {
              onDrag(self);
              dragged = false;
            }
  
            moved = false;
          }
  
          locked && !(locked = false) && onLockAxis && onLockAxis(self);
  
          if (wheeled) {
            onWheel(self);
            wheeled = false;
          }
  
          id = 0;
        },
            onDelta = function onDelta(x, y, index) {
          deltaX[index] += x;
          deltaY[index] += y;
  
          self._vx.update(x);
  
          self._vy.update(y);
  
          debounce ? id || (id = requestAnimationFrame(update)) : update();
        },
            onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
          if (lockAxis && !axis) {
            self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
            locked = true;
          }
  
          if (axis !== "y") {
            deltaX[2] += x;
  
            self._vx.update(x, true);
          }
  
          if (axis !== "x") {
            deltaY[2] += y;
  
            self._vy.update(y, true);
          }
  
          debounce ? id || (id = requestAnimationFrame(update)) : update();
        },
            _onDrag = function _onDrag(e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }
  
          e = _getEvent(e, preventDefault);
          var x = e.clientX,
              y = e.clientY,
              dx = x - self.x,
              dy = y - self.y,
              isDragging = self.isDragging;
          self.x = x;
          self.y = y;
  
          if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
            onDrag && (dragged = true);
            isDragging || (self.isDragging = true);
            onTouchOrPointerDelta(dx, dy);
            isDragging || onDragStart && onDragStart(self);
          }
        },
            _onPress = self.onPress = function (e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }
  
          self.axis = axis = null;
          onStopDelayedCall.pause();
          self.isPressed = true;
          e = _getEvent(e);
          prevDeltaX = prevDeltaY = 0;
          self.startX = self.x = e.clientX;
          self.startY = self.y = e.clientY;
  
          self._vx.reset();
  
          self._vy.reset();
  
          _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);
  
          self.deltaX = self.deltaY = 0;
          onPress && onPress(self);
        },
            _onRelease = function _onRelease(e) {
          if (_ignoreCheck(e, 1)) {
            return;
          }
  
          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
  
          var isTrackingDrag = !isNaN(self.y - self.startY),
              wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
              eventData = _getEvent(e);
  
          if (!wasDragging && isTrackingDrag) {
            self._vx.reset();
  
            self._vy.reset();
  
            if (preventDefault && allowClicks) {
              gsap.delayedCall(0.08, function () {
                if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                  if (e.target.click) {
                    e.target.click();
                  } else if (ownerDoc.createEvent) {
                    var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                    syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                    e.target.dispatchEvent(syntheticEvent);
                  }
                }
              });
            }
          }
  
          self.isDragging = self.isGesturing = self.isPressed = false;
          onStop && !isNormalizer && onStopDelayedCall.restart(true);
          onDragEnd && wasDragging && onDragEnd(self);
          onRelease && onRelease(self, wasDragging);
        },
            _onGestureStart = function _onGestureStart(e) {
          return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
        },
            _onGestureEnd = function _onGestureEnd() {
          return (self.isGesturing = false) || onGestureEnd(self);
        },
            onScroll = function onScroll(e) {
          if (_ignoreCheck(e)) {
            return;
          }
  
          var x = scrollFuncX(),
              y = scrollFuncY();
          onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
          scrollX = x;
          scrollY = y;
          onStop && onStopDelayedCall.restart(true);
        },
            _onWheel = function _onWheel(e) {
          if (_ignoreCheck(e)) {
            return;
          }
  
          e = _getEvent(e, preventDefault);
          onWheel && (wheeled = true);
          var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
          onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
          onStop && !isNormalizer && onStopDelayedCall.restart(true);
        },
            _onMove = function _onMove(e) {
          if (_ignoreCheck(e)) {
            return;
          }
  
          var x = e.clientX,
              y = e.clientY,
              dx = x - self.x,
              dy = y - self.y;
          self.x = x;
          self.y = y;
          moved = true;
          (dx || dy) && onTouchOrPointerDelta(dx, dy);
        },
            _onHover = function _onHover(e) {
          self.event = e;
          onHover(self);
        },
            _onHoverEnd = function _onHoverEnd(e) {
          self.event = e;
          onHoverEnd(self);
        },
            _onClick = function _onClick(e) {
          return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
        };
  
        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
        self.deltaX = self.deltaY = 0;
        self._vx = _getVelocityProp(0, 50, true);
        self._vy = _getVelocityProp(0, 50, true);
        self.scrollX = scrollFuncX;
        self.scrollY = scrollFuncY;
        self.isDragging = self.isGesturing = self.isPressed = false;
  
        _context(this);
  
        self.enable = function (e) {
          if (!self.isEnabled) {
            _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
  
            type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
            type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);
  
            if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
              _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);
  
              _addListener(ownerDoc, _eventTypes[2], _onRelease);
  
              _addListener(ownerDoc, _eventTypes[3], _onRelease);
  
              allowClicks && _addListener(target, "click", clickCapture, false, true);
              onClick && _addListener(target, "click", _onClick);
              onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
              onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
              onHover && _addListener(target, _pointerType + "enter", _onHover);
              onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
              onMove && _addListener(target, _pointerType + "move", _onMove);
            }
  
            self.isEnabled = true;
            e && e.type && _onPress(e);
            onEnable && onEnable(self);
          }
  
          return self;
        };
  
        self.disable = function () {
          if (self.isEnabled) {
            _observers.filter(function (o) {
              return o !== self && _isViewport(o.target);
            }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
  
            if (self.isPressed) {
              self._vx.reset();
  
              self._vy.reset();
  
              _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
            }
  
            _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
  
            _removeListener(target, "wheel", _onWheel, capture);
  
            _removeListener(target, _eventTypes[0], _onPress, capture);
  
            _removeListener(ownerDoc, _eventTypes[2], _onRelease);
  
            _removeListener(ownerDoc, _eventTypes[3], _onRelease);
  
            _removeListener(target, "click", clickCapture, true);
  
            _removeListener(target, "click", _onClick);
  
            _removeListener(ownerDoc, "gesturestart", _onGestureStart);
  
            _removeListener(ownerDoc, "gestureend", _onGestureEnd);
  
            _removeListener(target, _pointerType + "enter", _onHover);
  
            _removeListener(target, _pointerType + "leave", _onHoverEnd);
  
            _removeListener(target, _pointerType + "move", _onMove);
  
            self.isEnabled = self.isPressed = self.isDragging = false;
            onDisable && onDisable(self);
          }
        };
  
        self.kill = self.revert = function () {
          self.disable();
  
          var i = _observers.indexOf(self);
  
          i >= 0 && _observers.splice(i, 1);
          _normalizer === self && (_normalizer = 0);
        };
  
        _observers.push(self);
  
        isNormalizer && _isViewport(target) && (_normalizer = self);
        self.enable(event);
      };
  
      _createClass(Observer, [{
        key: "velocityX",
        get: function get() {
          return this._vx.getVelocity();
        }
      }, {
        key: "velocityY",
        get: function get() {
          return this._vy.getVelocity();
        }
      }]);
  
      return Observer;
    }();
    Observer.version = "3.11.4";
  
    Observer.create = function (vars) {
      return new Observer(vars);
    };
  
    Observer.register = _initCore;
  
    Observer.getAll = function () {
      return _observers.slice();
    };
  
    Observer.getById = function (id) {
      return _observers.filter(function (o) {
        return o.vars.id === id;
      })[0];
    };
  
    _getGSAP() && gsap.registerPlugin(Observer);
  
    /*!
     * ScrollTrigger 3.11.4
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
  
    var gsap$1,
        _coreInitted$1,
        _win$1,
        _doc$1,
        _docEl$1,
        _body$1,
        _root$1,
        _resizeDelay,
        _toArray,
        _clamp$1,
        _time2,
        _syncInterval,
        _refreshing,
        _pointerIsDown,
        _transformProp,
        _i,
        _prevWidth,
        _prevHeight,
        _autoRefresh,
        _sort,
        _suppressOverwrites,
        _ignoreResize,
        _normalizer$1,
        _ignoreMobileResize,
        _baseScreenHeight,
        _baseScreenWidth,
        _fixIOSBug,
        _context$1,
        _scrollRestoration,
        _limitCallbacks,
        _startup$1 = 1,
        _getTime$1 = Date.now,
        _time1 = _getTime$1(),
        _lastScrollTime = 0,
        _enabled = 0,
        _pointerDownHandler = function _pointerDownHandler() {
      return _pointerIsDown = 1;
    },
        _pointerUpHandler = function _pointerUpHandler() {
      return _pointerIsDown = 0;
    },
        _passThrough = function _passThrough(v) {
      return v;
    },
        _round = function _round(value) {
      return Math.round(value * 100000) / 100000 || 0;
    },
        _windowExists = function _windowExists() {
      return typeof window !== "undefined";
    },
        _getGSAP$1 = function _getGSAP() {
      return gsap$1 || _windowExists() && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1;
    },
        _isViewport$1 = function _isViewport(e) {
      return !!~_root$1.indexOf(e);
    },
        _getBoundsFunc = function _getBoundsFunc(element) {
      return _getProxyProp(element, "getBoundingClientRect") || (_isViewport$1(element) ? function () {
        _winOffsets.width = _win$1.innerWidth;
        _winOffsets.height = _win$1.innerHeight;
        return _winOffsets;
      } : function () {
        return _getBounds(element);
      });
    },
        _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
      var d = _ref.d,
          d2 = _ref.d2,
          a = _ref.a;
      return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
        return a()[d];
      } : function () {
        return (isViewport ? _win$1["inner" + d2] : scroller["client" + d2]) || 0;
      };
    },
        _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
      return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
        return _winOffsets;
      };
    },
        _maxScroll = function _maxScroll(element, _ref2) {
      var s = _ref2.s,
          d2 = _ref2.d2,
          d = _ref2.d,
          a = _ref2.a;
      return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport$1(element) ? (_docEl$1[s] || _body$1[s]) - (_win$1["inner" + d2] || _docEl$1["client" + d2] || _body$1["client" + d2]) : element[s] - element["offset" + d2];
    },
        _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
      for (var i = 0; i < _autoRefresh.length; i += 3) {
        (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
      }
    },
        _isString = function _isString(value) {
      return typeof value === "string";
    },
        _isFunction = function _isFunction(value) {
      return typeof value === "function";
    },
        _isNumber = function _isNumber(value) {
      return typeof value === "number";
    },
        _isObject = function _isObject(value) {
      return typeof value === "object";
    },
        _endAnimation = function _endAnimation(animation, reversed, pause) {
      return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
    },
        _callback = function _callback(self, func) {
      if (self.enabled) {
        var result = func(self);
        result && result.totalTime && (self.callbackAnimation = result);
      }
    },
        _abs = Math.abs,
        _left = "left",
        _top = "top",
        _right = "right",
        _bottom = "bottom",
        _width = "width",
        _height = "height",
        _Right = "Right",
        _Left = "Left",
        _Top = "Top",
        _Bottom = "Bottom",
        _padding = "padding",
        _margin = "margin",
        _Width = "Width",
        _Height = "Height",
        _px = "px",
        _getComputedStyle = function _getComputedStyle(element) {
      return _win$1.getComputedStyle(element);
    },
        _makePositionable = function _makePositionable(element) {
      var position = _getComputedStyle(element).position;
  
      element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
    },
        _setDefaults = function _setDefaults(obj, defaults) {
      for (var p in defaults) {
        p in obj || (obj[p] = defaults[p]);
      }
  
      return obj;
    },
        _getBounds = function _getBounds(element, withoutTransforms) {
      var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$1.to(element, {
        x: 0,
        y: 0,
        xPercent: 0,
        yPercent: 0,
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        scale: 1,
        skewX: 0,
        skewY: 0
      }).progress(1),
          bounds = element.getBoundingClientRect();
      tween && tween.progress(0).kill();
      return bounds;
    },
        _getSize = function _getSize(element, _ref3) {
      var d2 = _ref3.d2;
      return element["offset" + d2] || element["client" + d2] || 0;
    },
        _getLabelRatioArray = function _getLabelRatioArray(timeline) {
      var a = [],
          labels = timeline.labels,
          duration = timeline.duration(),
          p;
  
      for (p in labels) {
        a.push(labels[p] / duration);
      }
  
      return a;
    },
        _getClosestLabel = function _getClosestLabel(animation) {
      return function (value) {
        return gsap$1.utils.snap(_getLabelRatioArray(animation), value);
      };
    },
        _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
      var snap = gsap$1.utils.snap(snapIncrementOrArray),
          a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
        return a - b;
      });
      return a ? function (value, direction, threshold) {
        if (threshold === void 0) {
          threshold = 1e-3;
        }
  
        var i;
  
        if (!direction) {
          return snap(value);
        }
  
        if (direction > 0) {
          value -= threshold;
  
          for (i = 0; i < a.length; i++) {
            if (a[i] >= value) {
              return a[i];
            }
          }
  
          return a[i - 1];
        } else {
          i = a.length;
          value += threshold;
  
          while (i--) {
            if (a[i] <= value) {
              return a[i];
            }
          }
        }
  
        return a[0];
      } : function (value, direction, threshold) {
        if (threshold === void 0) {
          threshold = 1e-3;
        }
  
        var snapped = snap(value);
        return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
      };
    },
        _getLabelAtDirection = function _getLabelAtDirection(timeline) {
      return function (value, st) {
        return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
      };
    },
        _multiListener = function _multiListener(func, element, types, callback) {
      return types.split(",").forEach(function (type) {
        return func(element, type, callback);
      });
    },
        _addListener$1 = function _addListener(element, type, func, nonPassive, capture) {
      return element.addEventListener(type, func, {
        passive: !nonPassive,
        capture: !!capture
      });
    },
        _removeListener$1 = function _removeListener(element, type, func, capture) {
      return element.removeEventListener(type, func, !!capture);
    },
        _wheelListener = function _wheelListener(func, el, scrollFunc) {
      return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
    },
        _markerDefaults = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal"
    },
        _defaults = {
      toggleActions: "play",
      anticipatePin: 0
    },
        _keywords = {
      top: 0,
      left: 0,
      center: 0.5,
      bottom: 1,
      right: 1
    },
        _offsetToPx = function _offsetToPx(value, size) {
      if (_isString(value)) {
        var eqIndex = value.indexOf("="),
            relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
  
        if (~eqIndex) {
          value.indexOf("%") > eqIndex && (relative *= size / 100);
          value = value.substr(0, eqIndex - 1);
        }
  
        value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
      }
  
      return value;
    },
        _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
      var startColor = _ref4.startColor,
          endColor = _ref4.endColor,
          fontSize = _ref4.fontSize,
          indent = _ref4.indent,
          fontWeight = _ref4.fontWeight;
  
      var e = _doc$1.createElement("div"),
          useFixedPosition = _isViewport$1(container) || _getProxyProp(container, "pinType") === "fixed",
          isScroller = type.indexOf("scroller") !== -1,
          parent = useFixedPosition ? _body$1 : container,
          isStart = type.indexOf("start") !== -1,
          color = isStart ? startColor : endColor,
          css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  
      css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
      (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
      matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
      e._isStart = isStart;
      e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
      e.style.cssText = css;
      e.innerText = name || name === 0 ? type + "-" + name : type;
      parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
      e._offset = e["offset" + direction.op.d2];
  
      _positionMarker(e, 0, direction, isStart);
  
      return e;
    },
        _positionMarker = function _positionMarker(marker, start, direction, flipped) {
      var vars = {
        display: "block"
      },
          side = direction[flipped ? "os2" : "p2"],
          oppositeSide = direction[flipped ? "p2" : "os2"];
      marker._isFlipped = flipped;
      vars[direction.a + "Percent"] = flipped ? -100 : 0;
      vars[direction.a] = flipped ? "1px" : 0;
      vars["border" + side + _Width] = 1;
      vars["border" + oppositeSide + _Width] = 0;
      vars[direction.p] = start + "px";
      gsap$1.set(marker, vars);
    },
        _triggers = [],
        _ids = {},
        _rafID,
        _sync = function _sync() {
      return _getTime$1() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
    },
        _onScroll$1 = function _onScroll() {
      if (!_normalizer$1 || !_normalizer$1.isPressed || _normalizer$1.startX > _body$1.clientWidth) {
        _scrollers.cache++;
  
        if (_normalizer$1) {
          _rafID || (_rafID = requestAnimationFrame(_updateAll));
        } else {
          _updateAll();
        }
  
        _lastScrollTime || _dispatch("scrollStart");
        _lastScrollTime = _getTime$1();
      }
    },
        _setBaseDimensions = function _setBaseDimensions() {
      _baseScreenWidth = _win$1.innerWidth;
      _baseScreenHeight = _win$1.innerHeight;
    },
        _onResize = function _onResize() {
      _scrollers.cache++;
      !_refreshing && !_ignoreResize && !_doc$1.fullscreenElement && !_doc$1.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win$1.innerWidth || Math.abs(_win$1.innerHeight - _baseScreenHeight) > _win$1.innerHeight * 0.25) && _resizeDelay.restart(true);
    },
        _listeners = {},
        _emptyArray = [],
        _softRefresh = function _softRefresh() {
      return _removeListener$1(ScrollTrigger$1, "scrollEnd", _softRefresh) || _refreshAll(true);
    },
        _dispatch = function _dispatch(type) {
      return _listeners[type] && _listeners[type].map(function (f) {
        return f();
      }) || _emptyArray;
    },
        _savedStyles = [],
        _revertRecorded = function _revertRecorded(media) {
      for (var i = 0; i < _savedStyles.length; i += 5) {
        if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
          _savedStyles[i].style.cssText = _savedStyles[i + 1];
          _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
          _savedStyles[i + 3].uncache = 1;
        }
      }
    },
        _revertAll = function _revertAll(kill, media) {
      var trigger;
  
      for (_i = 0; _i < _triggers.length; _i++) {
        trigger = _triggers[_i];
  
        if (trigger && (!media || trigger._ctx === media)) {
          if (kill) {
            trigger.kill(1);
          } else {
            trigger.revert(true, true);
          }
        }
      }
  
      media && _revertRecorded(media);
      media || _dispatch("revert");
    },
        _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
      _scrollers.cache++;
      (force || !_refreshingAll) && _scrollers.forEach(function (obj) {
        return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);
      });
      _isString(scrollRestoration) && (_win$1.history.scrollRestoration = _scrollRestoration = scrollRestoration);
    },
        _refreshingAll,
        _refreshID = 0,
        _queueRefreshID,
        _queueRefreshAll = function _queueRefreshAll() {
      if (_queueRefreshID !== _refreshID) {
        var id = _queueRefreshID = _refreshID;
        requestAnimationFrame(function () {
          return id === _refreshID && _refreshAll(true);
        });
      }
    },
        _refreshAll = function _refreshAll(force, skipRevert) {
      if (_lastScrollTime && !force) {
        _addListener$1(ScrollTrigger$1, "scrollEnd", _softRefresh);
  
        return;
      }
  
      _refreshingAll = ScrollTrigger$1.isRefreshing = true;
  
      _scrollers.forEach(function (obj) {
        return _isFunction(obj) && obj.cacheID++ && (obj.rec = obj());
      });
  
      var refreshInits = _dispatch("refreshInit");
  
      _sort && ScrollTrigger$1.sort();
      skipRevert || _revertAll();
  
      _scrollers.forEach(function (obj) {
        if (_isFunction(obj)) {
          obj.smooth && (obj.target.style.scrollBehavior = "auto");
          obj(0);
        }
      });
  
      _triggers.slice(0).forEach(function (t) {
        return t.refresh();
      });
  
      _triggers.forEach(function (t, i) {
        if (t._subPinOffset && t.pin) {
          var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
              original = t.pin[prop];
          t.revert(true, 1);
          t.adjustPinSpacing(t.pin[prop] - original);
          t.revert(false, 1);
        }
      });
  
      _triggers.forEach(function (t) {
        return t.vars.end === "max" && t.setPositions(t.start, Math.max(t.start + 1, _maxScroll(t.scroller, t._dir)));
      });
  
      refreshInits.forEach(function (result) {
        return result && result.render && result.render(-1);
      });
  
      _scrollers.forEach(function (obj) {
        if (_isFunction(obj)) {
          obj.smooth && requestAnimationFrame(function () {
            return obj.target.style.scrollBehavior = "smooth";
          });
          obj.rec && obj(obj.rec);
        }
      });
  
      _clearScrollMemory(_scrollRestoration, 1);
  
      _resizeDelay.pause();
  
      _refreshID++;
  
      _updateAll(2);
  
      _triggers.forEach(function (t) {
        return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);
      });
  
      _refreshingAll = ScrollTrigger$1.isRefreshing = false;
  
      _dispatch("refresh");
    },
        _lastScroll = 0,
        _direction = 1,
        _primary,
        _updateAll = function _updateAll(force) {
      if (!_refreshingAll || force === 2) {
        ScrollTrigger$1.isUpdating = true;
        _primary && _primary.update(0);
  
        var l = _triggers.length,
            time = _getTime$1(),
            recordVelocity = time - _time1 >= 50,
            scroll = l && _triggers[0].scroll();
  
        _direction = _lastScroll > scroll ? -1 : 1;
        _lastScroll = scroll;
  
        if (recordVelocity) {
          if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
            _lastScrollTime = 0;
  
            _dispatch("scrollEnd");
          }
  
          _time2 = _time1;
          _time1 = time;
        }
  
        if (_direction < 0) {
          _i = l;
  
          while (_i-- > 0) {
            _triggers[_i] && _triggers[_i].update(0, recordVelocity);
          }
  
          _direction = 1;
        } else {
          for (_i = 0; _i < l; _i++) {
            _triggers[_i] && _triggers[_i].update(0, recordVelocity);
          }
        }
  
        ScrollTrigger$1.isUpdating = false;
      }
  
      _rafID = 0;
    },
        _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
        _swapPinOut = function _swapPinOut(pin, spacer, state) {
      _setState(state);
  
      var cache = pin._gsap;
  
      if (cache.spacerIsNative) {
        _setState(cache.spacerState);
      } else if (pin._gsap.swappedIn) {
        var parent = spacer.parentNode;
  
        if (parent) {
          parent.insertBefore(pin, spacer);
          parent.removeChild(spacer);
        }
      }
  
      pin._gsap.swappedIn = false;
    },
        _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
      if (!pin._gsap.swappedIn) {
        var i = _propNamesToCopy.length,
            spacerStyle = spacer.style,
            pinStyle = pin.style,
            p;
  
        while (i--) {
          p = _propNamesToCopy[i];
          spacerStyle[p] = cs[p];
        }
  
        spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
        cs.display === "inline" && (spacerStyle.display = "inline-block");
        pinStyle[_bottom] = pinStyle[_right] = "auto";
        spacerStyle.flexBasis = cs.flexBasis || "auto";
        spacerStyle.overflow = "visible";
        spacerStyle.boxSizing = "border-box";
        spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
        spacerStyle[_height] = _getSize(pin, _vertical) + _px;
        spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
  
        _setState(spacerState);
  
        pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
        pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
        pinStyle[_padding] = cs[_padding];
  
        if (pin.parentNode !== spacer) {
          pin.parentNode.insertBefore(spacer, pin);
          spacer.appendChild(pin);
        }
  
        pin._gsap.swappedIn = true;
      }
    },
        _capsExp = /([A-Z])/g,
        _setState = function _setState(state) {
      if (state) {
        var style = state.t.style,
            l = state.length,
            i = 0,
            p,
            value;
        (state.t._gsap || gsap$1.core.getCache(state.t)).uncache = 1;
  
        for (; i < l; i += 2) {
          value = state[i + 1];
          p = state[i];
  
          if (value) {
            style[p] = value;
          } else if (style[p]) {
            style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
          }
        }
      }
    },
        _getState = function _getState(element) {
      var l = _stateProps.length,
          style = element.style,
          state = [],
          i = 0;
  
      for (; i < l; i++) {
        state.push(_stateProps[i], style[_stateProps[i]]);
      }
  
      state.t = element;
      return state;
    },
        _copyState = function _copyState(state, override, omitOffsets) {
      var result = [],
          l = state.length,
          i = omitOffsets ? 8 : 0,
          p;
  
      for (; i < l; i += 2) {
        p = state[i];
        result.push(p, p in override ? override[p] : state[i + 1]);
      }
  
      result.t = state.t;
      return result;
    },
        _winOffsets = {
      left: 0,
      top: 0
    },
        _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
      _isFunction(value) && (value = value(self));
  
      if (_isString(value) && value.substr(0, 3) === "max") {
        value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
      }
  
      var time = containerAnimation ? containerAnimation.time() : 0,
          p1,
          p2,
          element;
      containerAnimation && containerAnimation.seek(0);
  
      if (!_isNumber(value)) {
        _isFunction(trigger) && (trigger = trigger(self));
        var offsets = (value || "0").split(" "),
            bounds,
            localOffset,
            globalOffset,
            display;
        element = _getTarget(trigger) || _body$1;
        bounds = _getBounds(element) || {};
  
        if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
          display = element.style.display;
          element.style.display = "block";
          bounds = _getBounds(element);
          display ? element.style.display = display : element.style.removeProperty("display");
        }
  
        localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
        globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
        value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
        markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
        scrollerSize -= scrollerSize - globalOffset;
      } else if (markerScroller) {
        _positionMarker(markerScroller, scrollerSize, direction, true);
      }
  
      if (marker) {
        var position = value + scrollerSize,
            isStart = marker._isStart;
        p1 = "scroll" + direction.d2;
  
        _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body$1[p1], _docEl$1[p1]) : marker.parentNode[p1]) <= position + 1);
  
        if (useFixedPosition) {
          scrollerBounds = _getBounds(markerScroller);
          useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
        }
      }
  
      if (containerAnimation && element) {
        p1 = _getBounds(element);
        containerAnimation.seek(scrollerMax);
        p2 = _getBounds(element);
        containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
        value = value / containerAnimation._caScrollDist * scrollerMax;
      }
  
      containerAnimation && containerAnimation.seek(time);
      return containerAnimation ? value : Math.round(value);
    },
        _prefixExp = /(webkit|moz|length|cssText|inset)/i,
        _reparent = function _reparent(element, parent, top, left) {
      if (element.parentNode !== parent) {
        var style = element.style,
            p,
            cs;
  
        if (parent === _body$1) {
          element._stOrig = style.cssText;
          cs = _getComputedStyle(element);
  
          for (p in cs) {
            if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
              style[p] = cs[p];
            }
          }
  
          style.top = top;
          style.left = left;
        } else {
          style.cssText = element._stOrig;
        }
  
        gsap$1.core.getCache(element).uncache = 1;
        parent.appendChild(element);
      }
    },
        _getTweenCreator = function _getTweenCreator(scroller, direction) {
      var getScroll = _getScrollFunc(scroller, direction),
          prop = "_scroll" + direction.p2,
          lastScroll1,
          lastScroll2,
          getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
        var tween = getTween.tween,
            onComplete = vars.onComplete,
            modifiers = {};
        initialValue = initialValue || getScroll();
        change2 = change1 && change2 || 0;
        change1 = change1 || scrollTo - initialValue;
        tween && tween.kill();
        lastScroll1 = Math.round(initialValue);
        vars[prop] = scrollTo;
        vars.modifiers = modifiers;
  
        modifiers[prop] = function (value) {
          value = Math.round(getScroll());
  
          if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 3 && Math.abs(value - lastScroll2) > 3) {
            tween.kill();
            getTween.tween = 0;
          } else {
            value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
          }
  
          lastScroll2 = lastScroll1;
          return lastScroll1 = Math.round(value);
        };
  
        vars.onUpdate = function () {
          _scrollers.cache++;
  
          _updateAll();
        };
  
        vars.onComplete = function () {
          getTween.tween = 0;
          onComplete && onComplete.call(tween);
        };
  
        tween = getTween.tween = gsap$1.to(scroller, vars);
        return tween;
      };
  
      scroller[prop] = getScroll;
  
      getScroll.wheelHandler = function () {
        return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
      };
  
      _addListener$1(scroller, "wheel", getScroll.wheelHandler);
  
      return getTween;
    };
  
    var ScrollTrigger$1 = function () {
      function ScrollTrigger(vars, animation) {
        _coreInitted$1 || ScrollTrigger.register(gsap$1) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
        this.init(vars, animation);
      }
  
      var _proto = ScrollTrigger.prototype;
  
      _proto.init = function init(vars, animation) {
        this.progress = this.start = 0;
        this.vars && this.kill(true, true);
  
        if (!_enabled) {
          this.update = this.refresh = this.kill = _passThrough;
          return;
        }
  
        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
          trigger: vars
        } : vars, _defaults);
  
        var _vars = vars,
            onUpdate = _vars.onUpdate,
            toggleClass = _vars.toggleClass,
            id = _vars.id,
            onToggle = _vars.onToggle,
            onRefresh = _vars.onRefresh,
            scrub = _vars.scrub,
            trigger = _vars.trigger,
            pin = _vars.pin,
            pinSpacing = _vars.pinSpacing,
            invalidateOnRefresh = _vars.invalidateOnRefresh,
            anticipatePin = _vars.anticipatePin,
            onScrubComplete = _vars.onScrubComplete,
            onSnapComplete = _vars.onSnapComplete,
            once = _vars.once,
            snap = _vars.snap,
            pinReparent = _vars.pinReparent,
            pinSpacer = _vars.pinSpacer,
            containerAnimation = _vars.containerAnimation,
            fastScrollEnd = _vars.fastScrollEnd,
            preventOverlaps = _vars.preventOverlaps,
            direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
            isToggle = !scrub && scrub !== 0,
            scroller = _getTarget(vars.scroller || _win$1),
            scrollerCache = gsap$1.core.getCache(scroller),
            isViewport = _isViewport$1(scroller),
            useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
            callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
            toggleActions = isToggle && vars.toggleActions.split(" "),
            markers = "markers" in vars ? vars.markers : _defaults.markers,
            borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
            self = this,
            onRefreshInit = vars.onRefreshInit && function () {
          return vars.onRefreshInit(self);
        },
            getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
            getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
            lastSnap = 0,
            lastRefresh = 0,
            scrollFunc = _getScrollFunc(scroller, direction),
            tweenTo,
            pinCache,
            snapFunc,
            scroll1,
            scroll2,
            start,
            end,
            markerStart,
            markerEnd,
            markerStartTrigger,
            markerEndTrigger,
            markerVars,
            change,
            pinOriginalState,
            pinActiveState,
            pinState,
            spacer,
            offset,
            pinGetter,
            pinSetter,
            pinStart,
            pinChange,
            spacingStart,
            spacerState,
            markerStartSetter,
            pinMoves,
            markerEndSetter,
            cs,
            snap1,
            snap2,
            scrubTween,
            scrubSmooth,
            snapDurClamp,
            snapDelayedCall,
            prevProgress,
            prevScroll,
            prevAnimProgress,
            caMarkerSetter,
            customRevertReturn;
  
        _context$1(self);
  
        self._dir = direction;
        anticipatePin *= 45;
        self.scroller = scroller;
        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
        scroll1 = scrollFunc();
        self.vars = vars;
        animation = animation || vars.animation;
  
        if ("refreshPriority" in vars) {
          _sort = 1;
          vars.refreshPriority === -9999 && (_primary = self);
        }
  
        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
          top: _getTweenCreator(scroller, _vertical),
          left: _getTweenCreator(scroller, _horizontal)
        };
        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
  
        self.scrubDuration = function (value) {
          scrubSmooth = _isNumber(value) && value;
  
          if (!scrubSmooth) {
            scrubTween && scrubTween.progress(1).kill();
            scrubTween = 0;
          } else {
            scrubTween ? scrubTween.duration(value) : scrubTween = gsap$1.to(animation, {
              ease: "expo",
              totalProgress: "+=0.001",
              duration: scrubSmooth,
              paused: true,
              onComplete: function onComplete() {
                return onScrubComplete && onScrubComplete(self);
              }
            });
          }
        };
  
        if (animation) {
          animation.vars.lazy = false;
          animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
          self.animation = animation.pause();
          animation.scrollTrigger = self;
          self.scrubDuration(scrub);
          snap1 = 0;
          id || (id = animation.vars.id);
        }
  
        _triggers.push(self);
  
        if (snap) {
          if (!_isObject(snap) || snap.push) {
            snap = {
              snapTo: snap
            };
          }
  
          "scrollBehavior" in _body$1.style && gsap$1.set(isViewport ? [_body$1, _docEl$1] : scroller, {
            scrollBehavior: "auto"
          });
  
          _scrollers.forEach(function (o) {
            return _isFunction(o) && o.target === (isViewport ? _doc$1.scrollingElement || _docEl$1 : scroller) && (o.smooth = false);
          });
  
          snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
            return _snapDirectional(snap.snapTo)(value, _getTime$1() - lastRefresh < 500 ? 0 : st.direction);
          } : gsap$1.utils.snap(snap.snapTo);
          snapDurClamp = snap.duration || {
            min: 0.1,
            max: 2
          };
          snapDurClamp = _isObject(snapDurClamp) ? _clamp$1(snapDurClamp.min, snapDurClamp.max) : _clamp$1(snapDurClamp, snapDurClamp);
          snapDelayedCall = gsap$1.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
            var scroll = scrollFunc(),
                refreshedRecently = _getTime$1() - lastRefresh < 500,
                tween = tweenTo.tween;
  
            if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
              var progress = (scroll - start) / change,
                  totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                  velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime$1() - _time2) * 1000 || 0,
                  change1 = gsap$1.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
                  naturalEnd = progress + (snap.inertia === false ? 0 : change1),
                  endValue = _clamp$1(0, 1, snapFunc(naturalEnd, self)),
                  endScroll = Math.round(start + endValue * change),
                  _snap = snap,
                  onStart = _snap.onStart,
                  _onInterrupt = _snap.onInterrupt,
                  _onComplete = _snap.onComplete;
  
              if (scroll <= end && scroll >= start && endScroll !== scroll) {
                if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                  return;
                }
  
                if (snap.inertia === false) {
                  change1 = endValue - progress;
                }
  
                tweenTo(endScroll, {
                  duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                  ease: snap.ease || "power3",
                  data: _abs(endScroll - scroll),
                  onInterrupt: function onInterrupt() {
                    return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                  },
                  onComplete: function onComplete() {
                    self.update();
                    lastSnap = scrollFunc();
                    snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                    onSnapComplete && onSnapComplete(self);
                    _onComplete && _onComplete(self);
                  }
                }, scroll, change1 * change, endScroll - scroll - change1 * change);
                onStart && onStart(self, tweenTo.tween);
              }
            } else if (self.isActive && lastSnap !== scroll) {
              snapDelayedCall.restart(true);
            }
          }).pause();
        }
  
        id && (_ids[id] = self);
        trigger = self.trigger = _getTarget(trigger || pin);
        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
        customRevertReturn && (customRevertReturn = customRevertReturn(self));
        pin = pin === true ? trigger : _getTarget(pin);
        _isString(toggleClass) && (toggleClass = {
          targets: trigger,
          className: toggleClass
        });
  
        if (pin) {
          pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
          self.pin = pin;
          pinCache = gsap$1.core.getCache(pin);
  
          if (!pinCache.spacer) {
            if (pinSpacer) {
              pinSpacer = _getTarget(pinSpacer);
              pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
              pinCache.spacerIsNative = !!pinSpacer;
              pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
            }
  
            pinCache.spacer = spacer = pinSpacer || _doc$1.createElement("div");
            spacer.classList.add("pin-spacer");
            id && spacer.classList.add("pin-spacer-" + id);
            pinCache.pinState = pinOriginalState = _getState(pin);
          } else {
            pinOriginalState = pinCache.pinState;
          }
  
          vars.force3D !== false && gsap$1.set(pin, {
            force3D: true
          });
          self.spacer = spacer = pinCache.spacer;
          cs = _getComputedStyle(pin);
          spacingStart = cs[pinSpacing + direction.os2];
          pinGetter = gsap$1.getProperty(pin);
          pinSetter = gsap$1.quickSetter(pin, direction.a, _px);
  
          _swapPinIn(pin, spacer, cs);
  
          pinState = _getState(pin);
        }
  
        if (markers) {
          markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
          markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
          markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
          offset = markerStartTrigger["offset" + direction.op.d2];
  
          var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
  
          markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
          markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
          containerAnimation && (caMarkerSetter = gsap$1.quickSetter([markerStart, markerEnd], direction.a, _px));
  
          if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
            _makePositionable(isViewport ? _body$1 : scroller);
  
            gsap$1.set([markerStartTrigger, markerEndTrigger], {
              force3D: true
            });
            markerStartSetter = gsap$1.quickSetter(markerStartTrigger, direction.a, _px);
            markerEndSetter = gsap$1.quickSetter(markerEndTrigger, direction.a, _px);
          }
        }
  
        if (containerAnimation) {
          var oldOnUpdate = containerAnimation.vars.onUpdate,
              oldParams = containerAnimation.vars.onUpdateParams;
          containerAnimation.eventCallback("onUpdate", function () {
            self.update(0, 0, 1);
            oldOnUpdate && oldOnUpdate.apply(oldParams || []);
          });
        }
  
        self.previous = function () {
          return _triggers[_triggers.indexOf(self) - 1];
        };
  
        self.next = function () {
          return _triggers[_triggers.indexOf(self) + 1];
        };
  
        self.revert = function (revert, temp) {
          if (!temp) {
            return self.kill(true);
          }
  
          var r = revert !== false || !self.enabled,
              prevRefreshing = _refreshing;
  
          if (r !== self.isReverted) {
            if (r) {
              prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
              prevProgress = self.progress;
              prevAnimProgress = animation && animation.progress();
            }
  
            markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
              return m.style.display = r ? "none" : "block";
            });
  
            if (r) {
              _refreshing = 1;
              self.update(r);
            }
  
            if (pin && (!pinReparent || !self.isActive)) {
              if (r) {
                _swapPinOut(pin, spacer, pinOriginalState);
              } else {
                _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
              }
            }
  
            r || self.update(r);
            _refreshing = prevRefreshing;
            self.isReverted = r;
          }
        };
  
        self.refresh = function (soft, force) {
          if ((_refreshing || !self.enabled) && !force) {
            return;
          }
  
          if (pin && soft && _lastScrollTime) {
            _addListener$1(ScrollTrigger, "scrollEnd", _softRefresh);
  
            return;
          }
  
          !_refreshingAll && onRefreshInit && onRefreshInit(self);
          _refreshing = 1;
          lastRefresh = _getTime$1();
  
          if (tweenTo.tween) {
            tweenTo.tween.kill();
            tweenTo.tween = 0;
          }
  
          scrubTween && scrubTween.pause();
          invalidateOnRefresh && animation && animation.revert({
            kill: false
          }).invalidate();
          self.isReverted || self.revert(true, true);
          self._subPinOffset = false;
  
          var size = getScrollerSize(),
              scrollerBounds = getScrollerOffsets(),
              max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
              offset = 0,
              otherPinOffset = 0,
              parsedEnd = vars.end,
              parsedEndTrigger = vars.endTrigger || trigger,
              parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
              pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer),
              triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
              i = triggerIndex,
              cs,
              bounds,
              scroll,
              isVertical,
              override,
              curTrigger,
              curPin,
              oppositeScroll,
              initted,
              revertedPins,
              forcedOverflow;
  
          while (i--) {
            curTrigger = _triggers[i];
            curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1);
            curPin = curTrigger.pin;
  
            if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
              revertedPins || (revertedPins = []);
              revertedPins.unshift(curTrigger);
              curTrigger.revert(true, true);
            }
  
            if (curTrigger !== _triggers[i]) {
              triggerIndex--;
              i--;
            }
          }
  
          _isFunction(parsedStart) && (parsedStart = parsedStart(self));
          start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
          _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
  
          if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
            if (~parsedEnd.indexOf(" ")) {
              parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
            } else {
              offset = _offsetToPx(parsedEnd.substr(2), size);
              parsedEnd = _isString(parsedStart) ? parsedStart : start + offset;
              parsedEndTrigger = trigger;
            }
          }
  
          end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
          change = end - start || (start -= 0.01) && 0.001;
          offset = 0;
          i = triggerIndex;
  
          while (i--) {
            curTrigger = _triggers[i];
            curPin = curTrigger.pin;
  
            if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
              cs = curTrigger.end - curTrigger.start;
  
              if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
                offset += cs * (1 - curTrigger.progress);
              }
  
              curPin === pin && (otherPinOffset += cs);
            }
          }
  
          start += offset;
          end += offset;
          self._pinPush = otherPinOffset;
  
          if (markerStart && offset) {
            cs = {};
            cs[direction.a] = "+=" + offset;
            pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
            gsap$1.set([markerStart, markerEnd], cs);
          }
  
          if (pin) {
            cs = _getComputedStyle(pin);
            isVertical = direction === _vertical;
            scroll = scrollFunc();
            pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
  
            if (!max && end > 1) {
              forcedOverflow = (isViewport ? _doc$1.scrollingElement || _docEl$1 : scroller).style;
              forcedOverflow = {
                style: forcedOverflow,
                value: forcedOverflow["overflow" + direction.a.toUpperCase()]
              };
              forcedOverflow["overflow" + direction.a.toUpperCase()] = "scroll";
            }
  
            _swapPinIn(pin, spacer, cs);
  
            pinState = _getState(pin);
            bounds = _getBounds(pin, true);
            oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
  
            if (pinSpacing) {
              spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
              spacerState.t = spacer;
              i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
              i && spacerState.push(direction.d, i + _px);
  
              _setState(spacerState);
  
              if (pinnedContainer) {
                _triggers.forEach(function (t) {
                  if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {
                    t._subPinOffset = true;
                  }
                });
              }
  
              useFixedPosition && scrollFunc(prevScroll);
            }
  
            if (useFixedPosition) {
              override = {
                top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                boxSizing: "border-box",
                position: "fixed"
              };
              override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
              override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
              override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
              override[_padding] = cs[_padding];
              override[_padding + _Top] = cs[_padding + _Top];
              override[_padding + _Right] = cs[_padding + _Right];
              override[_padding + _Bottom] = cs[_padding + _Bottom];
              override[_padding + _Left] = cs[_padding + _Left];
              pinActiveState = _copyState(pinOriginalState, override, pinReparent);
              _refreshingAll && scrollFunc(0);
            }
  
            if (animation) {
              initted = animation._initted;
  
              _suppressOverwrites(1);
  
              animation.render(animation.duration(), true, true);
              pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
              pinMoves = Math.abs(change - pinChange) > 1;
              useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
              animation.render(0, true, true);
              initted || animation.invalidate(true);
              animation.parent || animation.totalTime(animation.totalTime());
  
              _suppressOverwrites(0);
            } else {
              pinChange = change;
            }
  
            forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
          } else if (trigger && scrollFunc() && !containerAnimation) {
            bounds = trigger.parentNode;
  
            while (bounds && bounds !== _body$1) {
              if (bounds._pinOffset) {
                start -= bounds._pinOffset;
                end -= bounds._pinOffset;
              }
  
              bounds = bounds.parentNode;
            }
          }
  
          revertedPins && revertedPins.forEach(function (t) {
            return t.revert(false, true);
          });
          self.start = start;
          self.end = end;
          scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
  
          if (!containerAnimation && !_refreshingAll) {
            scroll1 < prevScroll && scrollFunc(prevScroll);
            self.scroll.rec = 0;
          }
  
          self.revert(false, true);
  
          if (snapDelayedCall) {
            lastSnap = -1;
            self.isActive && scrollFunc(start + change * prevProgress);
            snapDelayedCall.restart(true);
          }
  
          _refreshing = 0;
          animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true);
  
          if (prevProgress !== self.progress || containerAnimation) {
            animation && !isToggle && animation.totalProgress(prevProgress, true);
            self.progress = (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
          }
  
          pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
          onRefresh && !_refreshingAll && onRefresh(self);
        };
  
        self.getVelocity = function () {
          return (scrollFunc() - scroll2) / (_getTime$1() - _time2) * 1000 || 0;
        };
  
        self.endAnimation = function () {
          _endAnimation(self.callbackAnimation);
  
          if (animation) {
            scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
          }
        };
  
        self.labelToScroll = function (label) {
          return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
        };
  
        self.getTrailing = function (name) {
          var i = _triggers.indexOf(self),
              a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
  
          return (_isString(name) ? a.filter(function (t) {
            return t.vars.preventOverlaps === name;
          }) : a).filter(function (t) {
            return self.direction > 0 ? t.end <= start : t.start >= end;
          });
        };
  
        self.update = function (reset, recordVelocity, forceFake) {
          if (containerAnimation && !forceFake && !reset) {
            return;
          }
  
          var scroll = _refreshingAll ? prevScroll : self.scroll(),
              p = reset ? 0 : (scroll - start) / change,
              clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
              prevProgress = self.progress,
              isActive,
              wasActive,
              toggleState,
              action,
              stateChanged,
              toggled,
              isAtMax,
              isTakingAction;
  
          if (recordVelocity) {
            scroll2 = scroll1;
            scroll1 = containerAnimation ? scrollFunc() : scroll;
  
            if (snap) {
              snap2 = snap1;
              snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
            }
          }
  
          anticipatePin && !clipped && pin && !_refreshing && !_startup$1 && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime$1() - _time2) * anticipatePin && (clipped = 0.0001);
  
          if (clipped !== prevProgress && self.enabled) {
            isActive = self.isActive = !!clipped && clipped < 1;
            wasActive = !!prevProgress && prevProgress < 1;
            toggled = isActive !== wasActive;
            stateChanged = toggled || !!clipped !== !!prevProgress;
            self.direction = clipped > prevProgress ? 1 : -1;
            self.progress = clipped;
  
            if (stateChanged && !_refreshing) {
              toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3;
  
              if (isToggle) {
                action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
                isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
              }
            }
  
            preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
              return t.endAnimation();
            }));
  
            if (!isToggle) {
              if (scrubTween && !_refreshing && !_startup$1) {
                scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
  
                if (scrubTween.resetTo) {
                  scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
                } else {
                  scrubTween.vars.totalProgress = clipped;
                  scrubTween.invalidate().restart();
                }
              } else if (animation) {
                animation.totalProgress(clipped, !!_refreshing);
              }
            }
  
            if (pin) {
              reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
  
              if (!useFixedPosition) {
                pinSetter(_round(pinStart + pinChange * clipped));
              } else if (stateChanged) {
                isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
  
                if (pinReparent) {
                  if (!reset && (isActive || isAtMax)) {
                    var bounds = _getBounds(pin, true),
                        _offset = scroll - start;
  
                    _reparent(pin, _body$1, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                  } else {
                    _reparent(pin, spacer);
                  }
                }
  
                _setState(isActive || isAtMax ? pinActiveState : pinState);
  
                pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
              }
            }
  
            snap && !tweenTo.tween && !_refreshing && !_startup$1 && snapDelayedCall.restart(true);
            toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
              return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
            });
            onUpdate && !isToggle && !reset && onUpdate(self);
  
            if (stateChanged && !_refreshing) {
              if (isToggle) {
                if (isTakingAction) {
                  if (action === "complete") {
                    animation.pause().totalProgress(1);
                  } else if (action === "reset") {
                    animation.restart(true).pause();
                  } else if (action === "restart") {
                    animation.restart(true);
                  } else {
                    animation[action]();
                  }
                }
  
                onUpdate && onUpdate(self);
              }
  
              if (toggled || !_limitCallbacks) {
                onToggle && toggled && _callback(self, onToggle);
                callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);
  
                if (!toggled) {
                  toggleState = clipped === 1 ? 1 : 3;
                  callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                }
              }
  
              if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                _endAnimation(self.callbackAnimation);
  
                scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
              }
            } else if (isToggle && onUpdate && !_refreshing) {
              onUpdate(self);
            }
          }
  
          if (markerEndSetter) {
            var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
            markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
            markerEndSetter(n);
          }
  
          caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
        };
  
        self.enable = function (reset, refresh) {
          if (!self.enabled) {
            self.enabled = true;
  
            _addListener$1(scroller, "resize", _onResize);
  
            _addListener$1(isViewport ? _doc$1 : scroller, "scroll", _onScroll$1);
  
            onRefreshInit && _addListener$1(ScrollTrigger, "refreshInit", onRefreshInit);
  
            if (reset !== false) {
              self.progress = prevProgress = 0;
              scroll1 = scroll2 = lastSnap = scrollFunc();
            }
  
            refresh !== false && self.refresh();
          }
        };
  
        self.getTween = function (snap) {
          return snap && tweenTo ? tweenTo.tween : scrubTween;
        };
  
        self.setPositions = function (newStart, newEnd) {
          if (pin) {
            pinStart += newStart - start;
            pinChange += newEnd - newStart - change;
            pinSpacing === _padding && self.adjustPinSpacing(newEnd - newStart - change);
          }
  
          self.start = start = newStart;
          self.end = end = newEnd;
          change = newEnd - newStart;
          self.update();
        };
  
        self.adjustPinSpacing = function (amount) {
          if (spacerState) {
            var i = spacerState.indexOf(direction.d) + 1;
            spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
            spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
  
            _setState(spacerState);
          }
        };
  
        self.disable = function (reset, allowAnimation) {
          if (self.enabled) {
            reset !== false && self.revert(true, true);
            self.enabled = self.isActive = false;
            allowAnimation || scrubTween && scrubTween.pause();
            prevScroll = 0;
            pinCache && (pinCache.uncache = 1);
            onRefreshInit && _removeListener$1(ScrollTrigger, "refreshInit", onRefreshInit);
  
            if (snapDelayedCall) {
              snapDelayedCall.pause();
              tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
            }
  
            if (!isViewport) {
              var i = _triggers.length;
  
              while (i--) {
                if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                  return;
                }
              }
  
              _removeListener$1(scroller, "resize", _onResize);
  
              _removeListener$1(scroller, "scroll", _onScroll$1);
            }
          }
        };
  
        self.kill = function (revert, allowAnimation) {
          self.disable(revert, allowAnimation);
          scrubTween && !allowAnimation && scrubTween.kill();
          id && delete _ids[id];
  
          var i = _triggers.indexOf(self);
  
          i >= 0 && _triggers.splice(i, 1);
          i === _i && _direction > 0 && _i--;
          i = 0;
  
          _triggers.forEach(function (t) {
            return t.scroller === self.scroller && (i = 1);
          });
  
          i || _refreshingAll || (self.scroll.rec = 0);
  
          if (animation) {
            animation.scrollTrigger = null;
            revert && animation.revert({
              kill: false
            });
            allowAnimation || animation.kill();
          }
  
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
            return m.parentNode && m.parentNode.removeChild(m);
          });
          _primary === self && (_primary = 0);
  
          if (pin) {
            pinCache && (pinCache.uncache = 1);
            i = 0;
  
            _triggers.forEach(function (t) {
              return t.pin === pin && i++;
            });
  
            i || (pinCache.spacer = 0);
          }
  
          vars.onKill && vars.onKill(self);
        };
  
        self.enable(false, false);
        customRevertReturn && customRevertReturn(self);
        !animation || !animation.add || change ? self.refresh() : gsap$1.delayedCall(0.01, function () {
          return start || end || self.refresh();
        }) && (change = 0.01) && (start = end = 0);
        pin && _queueRefreshAll();
      };
  
      ScrollTrigger.register = function register(core) {
        if (!_coreInitted$1) {
          gsap$1 = core || _getGSAP$1();
          _windowExists() && window.document && ScrollTrigger.enable();
          _coreInitted$1 = _enabled;
        }
  
        return _coreInitted$1;
      };
  
      ScrollTrigger.defaults = function defaults(config) {
        if (config) {
          for (var p in config) {
            _defaults[p] = config[p];
          }
        }
  
        return _defaults;
      };
  
      ScrollTrigger.disable = function disable(reset, kill) {
        _enabled = 0;
  
        _triggers.forEach(function (trigger) {
          return trigger[kill ? "kill" : "disable"](reset);
        });
  
        _removeListener$1(_win$1, "wheel", _onScroll$1);
  
        _removeListener$1(_doc$1, "scroll", _onScroll$1);
  
        clearInterval(_syncInterval);
  
        _removeListener$1(_doc$1, "touchcancel", _passThrough);
  
        _removeListener$1(_body$1, "touchstart", _passThrough);
  
        _multiListener(_removeListener$1, _doc$1, "pointerdown,touchstart,mousedown", _pointerDownHandler);
  
        _multiListener(_removeListener$1, _doc$1, "pointerup,touchend,mouseup", _pointerUpHandler);
  
        _resizeDelay.kill();
  
        _iterateAutoRefresh(_removeListener$1);
  
        for (var i = 0; i < _scrollers.length; i += 3) {
          _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 1]);
  
          _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 2]);
        }
      };
  
      ScrollTrigger.enable = function enable() {
        _win$1 = window;
        _doc$1 = document;
        _docEl$1 = _doc$1.documentElement;
        _body$1 = _doc$1.body;
  
        if (gsap$1) {
          _toArray = gsap$1.utils.toArray;
          _clamp$1 = gsap$1.utils.clamp;
          _context$1 = gsap$1.core.context || _passThrough;
          _suppressOverwrites = gsap$1.core.suppressOverwrites || _passThrough;
          _scrollRestoration = _win$1.history.scrollRestoration || "auto";
          gsap$1.core.globals("ScrollTrigger", ScrollTrigger);
  
          if (_body$1) {
            _enabled = 1;
            Observer.register(gsap$1);
            ScrollTrigger.isTouch = Observer.isTouch;
            _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
  
            _addListener$1(_win$1, "wheel", _onScroll$1);
  
            _root$1 = [_win$1, _doc$1, _docEl$1, _body$1];
  
            if (gsap$1.matchMedia) {
              ScrollTrigger.matchMedia = function (vars) {
                var mm = gsap$1.matchMedia(),
                    p;
  
                for (p in vars) {
                  mm.add(p, vars[p]);
                }
  
                return mm;
              };
  
              gsap$1.addEventListener("matchMediaInit", function () {
                return _revertAll();
              });
              gsap$1.addEventListener("matchMediaRevert", function () {
                return _revertRecorded();
              });
              gsap$1.addEventListener("matchMedia", function () {
                _refreshAll(0, 1);
  
                _dispatch("matchMedia");
              });
              gsap$1.matchMedia("(orientation: portrait)", function () {
                _setBaseDimensions();
  
                return _setBaseDimensions;
              });
            } else {
              console.warn("Requires GSAP 3.11.0 or later");
            }
  
            _setBaseDimensions();
  
            _addListener$1(_doc$1, "scroll", _onScroll$1);
  
            var bodyStyle = _body$1.style,
                border = bodyStyle.borderTopStyle,
                AnimationProto = gsap$1.core.Animation.prototype,
                bounds,
                i;
            AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
              value: function value() {
                return this.time(-0.01, true);
              }
            });
            bodyStyle.borderTopStyle = "solid";
            bounds = _getBounds(_body$1);
            _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
            _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
            border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
            _syncInterval = setInterval(_sync, 250);
            gsap$1.delayedCall(0.5, function () {
              return _startup$1 = 0;
            });
  
            _addListener$1(_doc$1, "touchcancel", _passThrough);
  
            _addListener$1(_body$1, "touchstart", _passThrough);
  
            _multiListener(_addListener$1, _doc$1, "pointerdown,touchstart,mousedown", _pointerDownHandler);
  
            _multiListener(_addListener$1, _doc$1, "pointerup,touchend,mouseup", _pointerUpHandler);
  
            _transformProp = gsap$1.utils.checkPrefix("transform");
  
            _stateProps.push(_transformProp);
  
            _coreInitted$1 = _getTime$1();
            _resizeDelay = gsap$1.delayedCall(0.2, _refreshAll).pause();
            _autoRefresh = [_doc$1, "visibilitychange", function () {
              var w = _win$1.innerWidth,
                  h = _win$1.innerHeight;
  
              if (_doc$1.hidden) {
                _prevWidth = w;
                _prevHeight = h;
              } else if (_prevWidth !== w || _prevHeight !== h) {
                _onResize();
              }
            }, _doc$1, "DOMContentLoaded", _refreshAll, _win$1, "load", _refreshAll, _win$1, "resize", _onResize];
  
            _iterateAutoRefresh(_addListener$1);
  
            _triggers.forEach(function (trigger) {
              return trigger.enable(0, 1);
            });
  
            for (i = 0; i < _scrollers.length; i += 3) {
              _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 1]);
  
              _wheelListener(_removeListener$1, _scrollers[i], _scrollers[i + 2]);
            }
          }
        }
      };
  
      ScrollTrigger.config = function config(vars) {
        "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
        var ms = vars.syncInterval;
        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
        "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);
  
        if ("autoRefreshEvents" in vars) {
          _iterateAutoRefresh(_removeListener$1) || _iterateAutoRefresh(_addListener$1, vars.autoRefreshEvents || "none");
          _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
        }
      };
  
      ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
        var t = _getTarget(target),
            i = _scrollers.indexOf(t),
            isViewport = _isViewport$1(t);
  
        if (~i) {
          _scrollers.splice(i, isViewport ? 6 : 2);
        }
  
        if (vars) {
          isViewport ? _proxies.unshift(_win$1, vars, _body$1, vars, _docEl$1, vars) : _proxies.unshift(t, vars);
        }
      };
  
      ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
        _triggers.forEach(function (t) {
          return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);
        });
      };
  
      ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
        var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),
            offset = bounds[horizontal ? _width : _height] * ratio || 0;
        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win$1.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win$1.innerHeight;
      };
  
      ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
        _isString(element) && (element = _getTarget(element));
        var bounds = element.getBoundingClientRect(),
            size = bounds[horizontal ? _width : _height],
            offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
        return horizontal ? (bounds.left + offset) / _win$1.innerWidth : (bounds.top + offset) / _win$1.innerHeight;
      };
  
      ScrollTrigger.killAll = function killAll(allowListeners) {
        _triggers.slice(0).forEach(function (t) {
          return t.vars.id !== "ScrollSmoother" && t.kill();
        });
  
        if (allowListeners !== true) {
          var listeners = _listeners.killAll || [];
          _listeners = {};
          listeners.forEach(function (f) {
            return f();
          });
        }
      };
  
      return ScrollTrigger;
    }();
    ScrollTrigger$1.version = "3.11.4";
  
    ScrollTrigger$1.saveStyles = function (targets) {
      return targets ? _toArray(targets).forEach(function (target) {
        if (target && target.style) {
          var i = _savedStyles.indexOf(target);
  
          i >= 0 && _savedStyles.splice(i, 5);
  
          _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap$1.core.getCache(target), _context$1());
        }
      }) : _savedStyles;
    };
  
    ScrollTrigger$1.revert = function (soft, media) {
      return _revertAll(!soft, media);
    };
  
    ScrollTrigger$1.create = function (vars, animation) {
      return new ScrollTrigger$1(vars, animation);
    };
  
    ScrollTrigger$1.refresh = function (safe) {
      return safe ? _onResize() : (_coreInitted$1 || ScrollTrigger$1.register()) && _refreshAll(true);
    };
  
    ScrollTrigger$1.update = function (force) {
      return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
    };
  
    ScrollTrigger$1.clearScrollMemory = _clearScrollMemory;
  
    ScrollTrigger$1.maxScroll = function (element, horizontal) {
      return _maxScroll(element, horizontal ? _horizontal : _vertical);
    };
  
    ScrollTrigger$1.getScrollFunc = function (element, horizontal) {
      return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
    };
  
    ScrollTrigger$1.getById = function (id) {
      return _ids[id];
    };
  
    ScrollTrigger$1.getAll = function () {
      return _triggers.filter(function (t) {
        return t.vars.id !== "ScrollSmoother";
      });
    };
  
    ScrollTrigger$1.isScrolling = function () {
      return !!_lastScrollTime;
    };
  
    ScrollTrigger$1.snapDirectional = _snapDirectional;
  
    ScrollTrigger$1.addEventListener = function (type, callback) {
      var a = _listeners[type] || (_listeners[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    };
  
    ScrollTrigger$1.removeEventListener = function (type, callback) {
      var a = _listeners[type],
          i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    };
  
    ScrollTrigger$1.batch = function (targets, vars) {
      var result = [],
          varsCopy = {},
          interval = vars.interval || 0.016,
          batchMax = vars.batchMax || 1e9,
          proxyCallback = function proxyCallback(type, callback) {
        var elements = [],
            triggers = [],
            delay = gsap$1.delayedCall(interval, function () {
          callback(elements, triggers);
          elements = [];
          triggers = [];
        }).pause();
        return function (self) {
          elements.length || delay.restart(true);
          elements.push(self.trigger);
          triggers.push(self);
          batchMax <= elements.length && delay.progress(1);
        };
      },
          p;
  
      for (p in vars) {
        varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
      }
  
      if (_isFunction(batchMax)) {
        batchMax = batchMax();
  
        _addListener$1(ScrollTrigger$1, "refresh", function () {
          return batchMax = vars.batchMax();
        });
      }
  
      _toArray(targets).forEach(function (target) {
        var config = {};
  
        for (p in varsCopy) {
          config[p] = varsCopy[p];
        }
  
        config.trigger = target;
        result.push(ScrollTrigger$1.create(config));
      });
  
      return result;
    };
  
    var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
      current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
      return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
    },
        _allowNativePanning = function _allowNativePanning(target, direction) {
      if (direction === true) {
        target.style.removeProperty("touch-action");
      } else {
        target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none";
      }
  
      target === _docEl$1 && _allowNativePanning(_body$1, direction);
    },
        _overflow = {
      auto: 1,
      scroll: 1
    },
        _nestedScroll = function _nestedScroll(_ref5) {
      var event = _ref5.event,
          target = _ref5.target,
          axis = _ref5.axis;
  
      var node = (event.changedTouches ? event.changedTouches[0] : event).target,
          cache = node._gsap || gsap$1.core.getCache(node),
          time = _getTime$1(),
          cs;
  
      if (!cache._isScrollT || time - cache._isScrollT > 2000) {
        while (node && node !== _body$1 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
          node = node.parentNode;
        }
  
        cache._isScroll = node && node !== target && !_isViewport$1(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
        cache._isScrollT = time;
      }
  
      if (cache._isScroll || axis === "x") {
        event.stopPropagation();
        event._gsapAllow = true;
      }
    },
        _inputObserver = function _inputObserver(target, type, inputs, nested) {
      return Observer.create({
        target: target,
        capture: true,
        debounce: false,
        lockAxis: true,
        type: type,
        onWheel: nested = nested && _nestedScroll,
        onPress: nested,
        onDrag: nested,
        onScroll: nested,
        onEnable: function onEnable() {
          return inputs && _addListener$1(_doc$1, Observer.eventTypes[0], _captureInputs, false, true);
        },
        onDisable: function onDisable() {
          return _removeListener$1(_doc$1, Observer.eventTypes[0], _captureInputs, true);
        }
      });
    },
        _inputExp = /(input|label|select|textarea)/i,
        _inputIsFocused,
        _captureInputs = function _captureInputs(e) {
      var isInput = _inputExp.test(e.target.tagName);
  
      if (isInput || _inputIsFocused) {
        e._gsapAllow = true;
        _inputIsFocused = isInput;
      }
    },
        _getScrollNormalizer = function _getScrollNormalizer(vars) {
      _isObject(vars) || (vars = {});
      vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
      vars.type || (vars.type = "wheel,touch");
      vars.debounce = !!vars.debounce;
      vars.id = vars.id || "normalizer";
  
      var _vars2 = vars,
          normalizeScrollX = _vars2.normalizeScrollX,
          momentum = _vars2.momentum,
          allowNestedScroll = _vars2.allowNestedScroll,
          self,
          maxY,
          target = _getTarget(vars.target) || _docEl$1,
          smoother = gsap$1.core.globals().ScrollSmoother,
          smootherInstance = smoother && smoother.get(),
          content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),
          scrollFuncY = _getScrollFunc(target, _vertical),
          scrollFuncX = _getScrollFunc(target, _horizontal),
          scale = 1,
          initialScale = (Observer.isTouch && _win$1.visualViewport ? _win$1.visualViewport.scale * _win$1.visualViewport.width : _win$1.outerWidth) / _win$1.innerWidth,
          wheelRefresh = 0,
          resolveMomentumDuration = _isFunction(momentum) ? function () {
        return momentum(self);
      } : function () {
        return momentum || 2.8;
      },
          lastRefreshID,
          skipTouchMove,
          inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
          resumeTouchMove = function resumeTouchMove() {
        return skipTouchMove = false;
      },
          scrollClampX = _passThrough,
          scrollClampY = _passThrough,
          updateClamps = function updateClamps() {
        maxY = _maxScroll(target, _vertical);
        scrollClampY = _clamp$1(_fixIOSBug ? 1 : 0, maxY);
        normalizeScrollX && (scrollClampX = _clamp$1(0, _maxScroll(target, _horizontal)));
        lastRefreshID = _refreshID;
      },
          removeContentOffset = function removeContentOffset() {
        content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
        scrollFuncY.offset = scrollFuncY.cacheID = 0;
      },
          ignoreDrag = function ignoreDrag() {
        if (skipTouchMove) {
          requestAnimationFrame(resumeTouchMove);
  
          var offset = _round(self.deltaY / 2),
              scroll = scrollClampY(scrollFuncY.v - offset);
  
          if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
            scrollFuncY.offset = scroll - scrollFuncY.v;
  
            var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
  
            content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
            content._gsap.y = y + "px";
            scrollFuncY.cacheID = _scrollers.cache;
  
            _updateAll();
          }
  
          return true;
        }
  
        scrollFuncY.offset && removeContentOffset();
        skipTouchMove = true;
      },
          tween,
          startScrollX,
          startScrollY,
          onStopDelayedCall,
          onResize = function onResize() {
        updateClamps();
  
        if (tween.isActive() && tween.vars.scrollY > maxY) {
          scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
        }
      };
  
      content && gsap$1.set(content, {
        y: "+=0"
      });
  
      vars.ignoreCheck = function (e) {
        return _fixIOSBug && e.type === "touchmove" && ignoreDrag() || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
      };
  
      vars.onPress = function () {
        var prevScale = scale;
        scale = _round((_win$1.visualViewport && _win$1.visualViewport.scale || 1) / initialScale);
        tween.pause();
        prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
        startScrollX = scrollFuncX();
        startScrollY = scrollFuncY();
        updateClamps();
        lastRefreshID = _refreshID;
      };
  
      vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
        scrollFuncY.offset && removeContentOffset();
  
        if (!wasDragging) {
          onStopDelayedCall.restart(true);
        } else {
          _scrollers.cache++;
          var dur = resolveMomentumDuration(),
              currentScroll,
              endScroll;
  
          if (normalizeScrollX) {
            currentScroll = scrollFuncX();
            endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227;
            dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
            tween.vars.scrollX = scrollClampX(endScroll);
          }
  
          currentScroll = scrollFuncY();
          endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227;
          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
          tween.vars.scrollY = scrollClampY(endScroll);
          tween.invalidate().duration(dur).play(0.01);
  
          if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
            gsap$1.to({}, {
              onUpdate: onResize,
              duration: dur
            });
          }
        }
      };
  
      vars.onWheel = function () {
        tween._ts && tween.pause();
  
        if (_getTime$1() - wheelRefresh > 1000) {
          lastRefreshID = 0;
          wheelRefresh = _getTime$1();
        }
      };
  
      vars.onChange = function (self, dx, dy, xArray, yArray) {
        _refreshID !== lastRefreshID && updateClamps();
        dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1]));
  
        if (dy) {
          scrollFuncY.offset && removeContentOffset();
          var isTouch = yArray[2] === dy,
              y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
              yClamped = scrollClampY(y);
          isTouch && y !== yClamped && (startScrollY += yClamped - y);
          scrollFuncY(yClamped);
        }
  
        (dy || dx) && _updateAll();
      };
  
      vars.onEnable = function () {
        _allowNativePanning(target, normalizeScrollX ? false : "x");
  
        ScrollTrigger$1.addEventListener("refresh", onResize);
  
        _addListener$1(_win$1, "resize", onResize);
  
        if (scrollFuncY.smooth) {
          scrollFuncY.target.style.scrollBehavior = "auto";
          scrollFuncY.smooth = scrollFuncX.smooth = false;
        }
  
        inputObserver.enable();
      };
  
      vars.onDisable = function () {
        _allowNativePanning(target, true);
  
        _removeListener$1(_win$1, "resize", onResize);
  
        ScrollTrigger$1.removeEventListener("refresh", onResize);
        inputObserver.kill();
      };
  
      vars.lockAxis = vars.lockAxis !== false;
      self = new Observer(vars);
      self.iOS = _fixIOSBug;
      _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
      _fixIOSBug && gsap$1.ticker.add(_passThrough);
      onStopDelayedCall = self._dc;
      tween = gsap$1.to(self, {
        ease: "power4",
        paused: true,
        scrollX: normalizeScrollX ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        onComplete: onStopDelayedCall.vars.onComplete
      });
      return self;
    };
  
    ScrollTrigger$1.sort = function (func) {
      return _triggers.sort(func || function (a, b) {
        return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
      });
    };
  
    ScrollTrigger$1.observe = function (vars) {
      return new Observer(vars);
    };
  
    ScrollTrigger$1.normalizeScroll = function (vars) {
      if (typeof vars === "undefined") {
        return _normalizer$1;
      }
  
      if (vars === true && _normalizer$1) {
        return _normalizer$1.enable();
      }
  
      if (vars === false) {
        return _normalizer$1 && _normalizer$1.kill();
      }
  
      var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
      _normalizer$1 && _normalizer$1.target === normalizer.target && _normalizer$1.kill();
      _isViewport$1(normalizer.target) && (_normalizer$1 = normalizer);
      return normalizer;
    };
  
    ScrollTrigger$1.core = {
      _getVelocityProp: _getVelocityProp,
      _inputObserver: _inputObserver,
      _scrollers: _scrollers,
      _proxies: _proxies,
      bridge: {
        ss: function ss() {
          _lastScrollTime || _dispatch("scrollStart");
          _lastScrollTime = _getTime$1();
        },
        ref: function ref() {
          return _refreshing;
        }
      }
    };
    _getGSAP$1() && gsap$1.registerPlugin(ScrollTrigger$1);
  
    exports.ScrollTrigger = ScrollTrigger$1;
    exports.default = ScrollTrigger$1;
  
    if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}
  
  })));
  
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

	/*!
	 * ScrollToPlugin 3.11.5
	 * https://greensock.com
	 *
	 * @license Copyright 2008-2023, GreenSock. All rights reserved.
	 * Subject to the terms at https://greensock.com/standard-license or for
	 * Club GreenSock members, the agreement issued with that membership.
	 * @author: Jack Doyle, jack@greensock.com
	*/
	var gsap,
	    _coreInitted,
	    _window,
	    _docEl,
	    _body,
	    _toArray,
	    _config,
	    ScrollTrigger,
	    _windowExists = function _windowExists() {
	  return typeof window !== "undefined";
	},
	    _getGSAP = function _getGSAP() {
	  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
	},
	    _isString = function _isString(value) {
	  return typeof value === "string";
	},
	    _isFunction = function _isFunction(value) {
	  return typeof value === "function";
	},
	    _max = function _max(element, axis) {
	  var dim = axis === "x" ? "Width" : "Height",
	      scroll = "scroll" + dim,
	      client = "client" + dim;
	  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
	},
	    _buildGetter = function _buildGetter(e, axis) {
	  var p = "scroll" + (axis === "x" ? "Left" : "Top");

	  if (e === _window) {
	    if (e.pageXOffset != null) {
	      p = "page" + axis.toUpperCase() + "Offset";
	    } else {
	      e = _docEl[p] != null ? _docEl : _body;
	    }
	  }

	  return function () {
	    return e[p];
	  };
	},
	    _clean = function _clean(value, index, target, targets) {
	  _isFunction(value) && (value = value(index, target, targets));

	  if (typeof value !== "object") {
	    return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
	      x: value,
	      y: value
	    } : {
	      y: value
	    };
	  } else if (value.nodeType) {
	    return {
	      y: value,
	      x: value
	    };
	  } else {
	    var result = {},
	        p;

	    for (p in value) {
	      result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
	    }

	    return result;
	  }
	},
	    _getOffset = function _getOffset(element, container) {
	  element = _toArray(element)[0];

	  if (!element || !element.getBoundingClientRect) {
	    return console.warn("scrollTo target doesn't exist. Using 0") || {
	      x: 0,
	      y: 0
	    };
	  }

	  var rect = element.getBoundingClientRect(),
	      isRoot = !container || container === _window || container === _body,
	      cRect = isRoot ? {
	    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
	    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
	  } : container.getBoundingClientRect(),
	      offsets = {
	    x: rect.left - cRect.left,
	    y: rect.top - cRect.top
	  };

	  if (!isRoot && container) {
	    offsets.x += _buildGetter(container, "x")();
	    offsets.y += _buildGetter(container, "y")();
	  }

	  return offsets;
	},
	    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
	  return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
	},
	    _initCore = function _initCore() {
	  gsap = _getGSAP();

	  if (_windowExists() && gsap && typeof document !== "undefined" && document.body) {
	    _window = window;
	    _body = document.body;
	    _docEl = document.documentElement;
	    _toArray = gsap.utils.toArray;
	    gsap.config({
	      autoKillThreshold: 7
	    });
	    _config = gsap.config();
	    _coreInitted = 1;
	  }
	};

	var ScrollToPlugin = {
	  version: "3.11.5",
	  name: "scrollTo",
	  rawVars: 1,
	  register: function register(core) {
	    gsap = core;

	    _initCore();
	  },
	  init: function init(target, value, tween, index, targets) {
	    _coreInitted || _initCore();
	    var data = this,
	        snapType = gsap.getProperty(target, "scrollSnapType");
	    data.isWin = target === _window;
	    data.target = target;
	    data.tween = tween;
	    value = _clean(value, index, target, targets);
	    data.vars = value;
	    data.autoKill = !!value.autoKill;
	    data.getX = _buildGetter(target, "x");
	    data.getY = _buildGetter(target, "y");
	    data.x = data.xPrev = data.getX();
	    data.y = data.yPrev = data.getY();
	    ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);
	    gsap.getProperty(target, "scrollBehavior") === "smooth" && gsap.set(target, {
	      scrollBehavior: "auto"
	    });

	    if (snapType && snapType !== "none") {
	      data.snap = 1;
	      data.snapInline = target.style.scrollSnapType;
	      target.style.scrollSnapType = "none";
	    }

	    if (value.x != null) {
	      data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

	      data._props.push("scrollTo_x");
	    } else {
	      data.skipX = 1;
	    }

	    if (value.y != null) {
	      data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

	      data._props.push("scrollTo_y");
	    } else {
	      data.skipY = 1;
	    }
	  },
	  render: function render(ratio, data) {
	    var pt = data._pt,
	        target = data.target,
	        tween = data.tween,
	        autoKill = data.autoKill,
	        xPrev = data.xPrev,
	        yPrev = data.yPrev,
	        isWin = data.isWin,
	        snap = data.snap,
	        snapInline = data.snapInline,
	        x,
	        y,
	        yDif,
	        xDif,
	        threshold;

	    while (pt) {
	      pt.r(ratio, pt.d);
	      pt = pt._next;
	    }

	    x = isWin || !data.skipX ? data.getX() : xPrev;
	    y = isWin || !data.skipY ? data.getY() : yPrev;
	    yDif = y - yPrev;
	    xDif = x - xPrev;
	    threshold = _config.autoKillThreshold;

	    if (data.x < 0) {
	      data.x = 0;
	    }

	    if (data.y < 0) {
	      data.y = 0;
	    }

	    if (autoKill) {
	      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
	        data.skipX = 1;
	      }

	      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
	        data.skipY = 1;
	      }

	      if (data.skipX && data.skipY) {
	        tween.kill();
	        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
	      }
	    }

	    if (isWin) {
	      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
	    } else {
	      data.skipY || (target.scrollTop = data.y);
	      data.skipX || (target.scrollLeft = data.x);
	    }

	    if (snap && (ratio === 1 || ratio === 0)) {
	      y = target.scrollTop;
	      x = target.scrollLeft;
	      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
	      target.scrollTop = y + 1;
	      target.scrollLeft = x + 1;
	      target.scrollTop = y;
	      target.scrollLeft = x;
	    }

	    data.xPrev = data.x;
	    data.yPrev = data.y;
	    ScrollTrigger && ScrollTrigger.update();
	  },
	  kill: function kill(property) {
	    var both = property === "scrollTo";

	    if (both || property === "scrollTo_x") {
	      this.skipX = 1;
	    }

	    if (both || property === "scrollTo_y") {
	      this.skipY = 1;
	    }
	  }
	};
	ScrollToPlugin.max = _max;
	ScrollToPlugin.getOffset = _getOffset;
	ScrollToPlugin.buildGetter = _buildGetter;
	_getGSAP() && gsap.registerPlugin(ScrollToPlugin);

	exports.ScrollToPlugin = ScrollToPlugin;
	exports.default = ScrollToPlugin;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /*!
   * Observer 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var gsap,
      _coreInitted,
      _clamp,
      _win,
      _doc,
      _docEl,
      _body,
      _isTouch,
      _pointerType,
      ScrollTrigger,
      _root,
      _normalizer,
      _eventTypes,
      _context,
      _getGSAP = function _getGSAP() {
    return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
  },
      _startup = 1,
      _observers = [];
      exports._scrollers = [];
      exports._proxies = [];
      var _getTime = Date.now,
      _bridge = function _bridge(name, value) {
    return value;
  },
      _integrate = function _integrate() {
    var core = ScrollTrigger.core,
        data = core.bridge || {},
        scrollers = core._scrollers,
        proxies = core._proxies;
    scrollers.push.apply(scrollers, exports._scrollers);
    proxies.push.apply(proxies, exports._proxies);
    exports._scrollers = scrollers;
    exports._proxies = proxies;

    _bridge = function _bridge(name, value) {
      return data[name](value);
    };
  },
      _getProxyProp = function _getProxyProp(element, property) {
    return ~exports._proxies.indexOf(element) && exports._proxies[exports._proxies.indexOf(element) + 1][property];
  },
      _isViewport = function _isViewport(el) {
    return !!~_root.indexOf(el);
  },
      _addListener = function _addListener(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  },
      _removeListener = function _removeListener(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  },
      _scrollLeft = "scrollLeft",
      _scrollTop = "scrollTop",
      _onScroll = function _onScroll() {
    return _normalizer && _normalizer.isPressed || exports._scrollers.cache++;
  },
      _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
    var cachingFunc = function cachingFunc(value) {
      if (value || value === 0) {
        _startup && (_win.history.scrollRestoration = "manual");
        var isNormalizing = _normalizer && _normalizer.isPressed;
        value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
        f(value);
        cachingFunc.cacheID = exports._scrollers.cache;
        isNormalizing && _bridge("ss", value);
      } else if (doNotCache || exports._scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
        cachingFunc.cacheID = exports._scrollers.cache;
        cachingFunc.v = f();
      }

      return cachingFunc.v + cachingFunc.offset;
    };

    cachingFunc.offset = 0;
    return f && cachingFunc;
  },
      _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
    })
  },
      _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function (value) {
      return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
    })
  },
      _getTarget = function _getTarget(t, self) {
    return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
  },
      _getScrollFunc = function _getScrollFunc(element, _ref) {
    var s = _ref.s,
        sc = _ref.sc;
    _isViewport(element) && (element = _doc.scrollingElement || _docEl);

    var i = exports._scrollers.indexOf(element),
        offset = sc === _vertical.sc ? 1 : 2;

    !~i && (i = exports._scrollers.push(element) - 1);
    exports._scrollers[i + offset] || _addListener(element, "scroll", _onScroll);
    var prev = exports._scrollers[i + offset],
        func = prev || (exports._scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
      return arguments.length ? element[s] = value : element[s];
    })));
    func.target = element;
    prev || (func.smooth = gsap.getProperty(element, "scrollBehavior") === "smooth");
    return func;
  },
      _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
    var v1 = value,
        v2 = value,
        t1 = _getTime(),
        t2 = t1,
        min = minTimeRefresh || 50,
        dropToZeroTime = Math.max(500, min * 3),
        update = function update(value, force) {
      var t = _getTime();

      if (force || t - t1 > min) {
        v2 = v1;
        v1 = value;
        t2 = t1;
        t1 = t;
      } else if (useDelta) {
        v1 += value;
      } else {
        v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
      }
    },
        reset = function reset() {
      v2 = v1 = useDelta ? 0 : v1;
      t2 = t1 = 0;
    },
        getVelocity = function getVelocity(latestValue) {
      var tOld = t2,
          vOld = v2,
          t = _getTime();

      (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
      return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
    };

    return {
      update: update,
      reset: reset,
      getVelocity: getVelocity
    };
  },
      _getEvent = function _getEvent(e, preventDefault) {
    preventDefault && !e._gsapAllow && e.preventDefault();
    return e.changedTouches ? e.changedTouches[0] : e;
  },
      _getAbsoluteMax = function _getAbsoluteMax(a) {
    var max = Math.max.apply(Math, a),
        min = Math.min.apply(Math, a);
    return Math.abs(max) >= Math.abs(min) ? max : min;
  },
      _setScrollTrigger = function _setScrollTrigger() {
    ScrollTrigger = gsap.core.globals().ScrollTrigger;
    ScrollTrigger && ScrollTrigger.core && _integrate();
  },
      _initCore = function _initCore(core) {
    gsap = core || _getGSAP();

    if (!_coreInitted && gsap && typeof document !== "undefined" && document.body) {
      _win = window;
      _doc = document;
      _docEl = _doc.documentElement;
      _body = _doc.body;
      _root = [_win, _doc, _docEl, _body];
      _clamp = gsap.utils.clamp;

      _context = gsap.core.context || function () {};

      _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
      _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function () {
        return _startup = 0;
      }, 500);

      _setScrollTrigger();

      _coreInitted = 1;
    }

    return _coreInitted;
  };

  _horizontal.op = _vertical;
  exports._scrollers.cache = 0;
  var Observer = function () {
    function Observer(vars) {
      this.init(vars);
    }

    var _proto = Observer.prototype;

    _proto.init = function init(vars) {
      _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger || _setScrollTrigger();
      var tolerance = vars.tolerance,
          dragMinimum = vars.dragMinimum,
          type = vars.type,
          target = vars.target,
          lineHeight = vars.lineHeight,
          debounce = vars.debounce,
          preventDefault = vars.preventDefault,
          onStop = vars.onStop,
          onStopDelay = vars.onStopDelay,
          ignore = vars.ignore,
          wheelSpeed = vars.wheelSpeed,
          event = vars.event,
          onDragStart = vars.onDragStart,
          onDragEnd = vars.onDragEnd,
          onDrag = vars.onDrag,
          onPress = vars.onPress,
          onRelease = vars.onRelease,
          onRight = vars.onRight,
          onLeft = vars.onLeft,
          onUp = vars.onUp,
          onDown = vars.onDown,
          onChangeX = vars.onChangeX,
          onChangeY = vars.onChangeY,
          onChange = vars.onChange,
          onToggleX = vars.onToggleX,
          onToggleY = vars.onToggleY,
          onHover = vars.onHover,
          onHoverEnd = vars.onHoverEnd,
          onMove = vars.onMove,
          ignoreCheck = vars.ignoreCheck,
          isNormalizer = vars.isNormalizer,
          onGestureStart = vars.onGestureStart,
          onGestureEnd = vars.onGestureEnd,
          onWheel = vars.onWheel,
          onEnable = vars.onEnable,
          onDisable = vars.onDisable,
          onClick = vars.onClick,
          scrollSpeed = vars.scrollSpeed,
          capture = vars.capture,
          allowClicks = vars.allowClicks,
          lockAxis = vars.lockAxis,
          onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl;
      this.vars = vars;
      ignore && (ignore = gsap.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce = debounce !== false;
      lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);

      var id,
          onStopDelayedCall,
          dragged,
          moved,
          wheeled,
          locked,
          axis,
          self = this,
          prevDeltaX = 0,
          prevDeltaY = 0,
          passive = vars.passive || !preventDefault,
          scrollFuncX = _getScrollFunc(target, _horizontal),
          scrollFuncY = _getScrollFunc(target, _vertical),
          scrollX = scrollFuncX(),
          scrollY = scrollFuncY(),
          limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
          isViewport = _isViewport(target),
          ownerDoc = target.ownerDocument || _doc,
          deltaX = [0, 0, 0],
          deltaY = [0, 0, 0],
          onClickTime = 0,
          clickCapture = function clickCapture() {
        return onClickTime = _getTime();
      },
          _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
        return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
      },
          onStopFunc = function onStopFunc() {
        self._vx.reset();

        self._vy.reset();

        onStopDelayedCall.pause();
        onStop && onStop(self);
      },
          update = function update() {
        var dx = self.deltaX = _getAbsoluteMax(deltaX),
            dy = self.deltaY = _getAbsoluteMax(deltaY),
            changedX = Math.abs(dx) >= tolerance,
            changedY = Math.abs(dy) >= tolerance;

        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);

        if (changedX) {
          onRight && self.deltaX > 0 && onRight(self);
          onLeft && self.deltaX < 0 && onLeft(self);
          onChangeX && onChangeX(self);
          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
          prevDeltaX = self.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }

        if (changedY) {
          onDown && self.deltaY > 0 && onDown(self);
          onUp && self.deltaY < 0 && onUp(self);
          onChangeY && onChangeY(self);
          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
          prevDeltaY = self.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }

        if (moved || dragged) {
          onMove && onMove(self);

          if (dragged) {
            onDrag(self);
            dragged = false;
          }

          moved = false;
        }

        locked && !(locked = false) && onLockAxis && onLockAxis(self);

        if (wheeled) {
          onWheel(self);
          wheeled = false;
        }

        id = 0;
      },
          onDelta = function onDelta(x, y, index) {
        deltaX[index] += x;
        deltaY[index] += y;

        self._vx.update(x);

        self._vy.update(y);

        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
          onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
        if (lockAxis && !axis) {
          self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
          locked = true;
        }

        if (axis !== "y") {
          deltaX[2] += x;

          self._vx.update(x, true);
        }

        if (axis !== "x") {
          deltaY[2] += y;

          self._vy.update(y, true);
        }

        debounce ? id || (id = requestAnimationFrame(update)) : update();
      },
          _onDrag = function _onDrag(e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }

        e = _getEvent(e, preventDefault);
        var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y,
            isDragging = self.isDragging;
        self.x = x;
        self.y = y;

        if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
          onDrag && (dragged = true);
          isDragging || (self.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
          isDragging || onDragStart && onDragStart(self);
        }
      },
          _onPress = self.onPress = function (e) {
        if (_ignoreCheck(e, 1) || e && e.button) {
          return;
        }

        self.axis = axis = null;
        onStopDelayedCall.pause();
        self.isPressed = true;
        e = _getEvent(e);
        prevDeltaX = prevDeltaY = 0;
        self.startX = self.x = e.clientX;
        self.startY = self.y = e.clientY;

        self._vx.reset();

        self._vy.reset();

        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);

        self.deltaX = self.deltaY = 0;
        onPress && onPress(self);
      },
          _onRelease = self.onRelease = function (e) {
        if (_ignoreCheck(e, 1)) {
          return;
        }

        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

        var isTrackingDrag = !isNaN(self.y - self.startY),
            wasDragging = self.isDragging,
            isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
            eventData = _getEvent(e);

        if (!isDragNotClick && isTrackingDrag) {
          self._vx.reset();

          self._vy.reset();

          if (preventDefault && allowClicks) {
            gsap.delayedCall(0.08, function () {
              if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                if (e.target.click) {
                  e.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }

        self.isDragging = self.isGesturing = self.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        onDragEnd && wasDragging && onDragEnd(self);
        onRelease && onRelease(self, isDragNotClick);
      },
          _onGestureStart = function _onGestureStart(e) {
        return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
      },
          _onGestureEnd = function _onGestureEnd() {
        return (self.isGesturing = false) || onGestureEnd(self);
      },
          onScroll = function onScroll(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        var x = scrollFuncX(),
            y = scrollFuncY();
        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
        scrollX = x;
        scrollY = y;
        onStop && onStopDelayedCall.restart(true);
      },
          _onWheel = function _onWheel(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        e = _getEvent(e, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      },
          _onMove = function _onMove(e) {
        if (_ignoreCheck(e)) {
          return;
        }

        var x = e.clientX,
            y = e.clientY,
            dx = x - self.x,
            dy = y - self.y;
        self.x = x;
        self.y = y;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      },
          _onHover = function _onHover(e) {
        self.event = e;
        onHover(self);
      },
          _onHoverEnd = function _onHoverEnd(e) {
        self.event = e;
        onHoverEnd(self);
      },
          _onClick = function _onClick(e) {
        return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
      };

      onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self.deltaX = self.deltaY = 0;
      self._vx = _getVelocityProp(0, 50, true);
      self._vy = _getVelocityProp(0, 50, true);
      self.scrollX = scrollFuncX;
      self.scrollY = scrollFuncY;
      self.isDragging = self.isGesturing = self.isPressed = false;

      _context(this);

      self.enable = function (e) {
        if (!self.isEnabled) {
          _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

          type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);

          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener(target, _eventTypes[0], _onPress, passive, capture);

            _addListener(ownerDoc, _eventTypes[2], _onRelease);

            _addListener(ownerDoc, _eventTypes[3], _onRelease);

            allowClicks && _addListener(target, "click", clickCapture, true, true);
            onClick && _addListener(target, "click", _onClick);
            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener(target, _pointerType + "move", _onMove);
          }

          self.isEnabled = true;
          e && e.type && _onPress(e);
          onEnable && onEnable(self);
        }

        return self;
      };

      self.disable = function () {
        if (self.isEnabled) {
          _observers.filter(function (o) {
            return o !== self && _isViewport(o.target);
          }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

          if (self.isPressed) {
            self._vx.reset();

            self._vy.reset();

            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }

          _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

          _removeListener(target, "wheel", _onWheel, capture);

          _removeListener(target, _eventTypes[0], _onPress, capture);

          _removeListener(ownerDoc, _eventTypes[2], _onRelease);

          _removeListener(ownerDoc, _eventTypes[3], _onRelease);

          _removeListener(target, "click", clickCapture, true);

          _removeListener(target, "click", _onClick);

          _removeListener(ownerDoc, "gesturestart", _onGestureStart);

          _removeListener(ownerDoc, "gestureend", _onGestureEnd);

          _removeListener(target, _pointerType + "enter", _onHover);

          _removeListener(target, _pointerType + "leave", _onHoverEnd);

          _removeListener(target, _pointerType + "move", _onMove);

          self.isEnabled = self.isPressed = self.isDragging = false;
          onDisable && onDisable(self);
        }
      };

      self.kill = self.revert = function () {
        self.disable();

        var i = _observers.indexOf(self);

        i >= 0 && _observers.splice(i, 1);
        _normalizer === self && (_normalizer = 0);
      };

      _observers.push(self);

      isNormalizer && _isViewport(target) && (_normalizer = self);
      self.enable(event);
    };

    _createClass(Observer, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);

    return Observer;
  }();
  Observer.version = "3.12.5";

  Observer.create = function (vars) {
    return new Observer(vars);
  };

  Observer.register = _initCore;

  Observer.getAll = function () {
    return _observers.slice();
  };

  Observer.getById = function (id) {
    return _observers.filter(function (o) {
      return o.vars.id === id;
    })[0];
  };

  _getGSAP() && gsap.registerPlugin(Observer);

  exports.Observer = Observer;
  exports._getProxyProp = _getProxyProp;
  exports._getScrollFunc = _getScrollFunc;
  exports._getTarget = _getTarget;
  exports._getVelocityProp = _getVelocityProp;
  exports._horizontal = _horizontal;
  exports._isViewport = _isViewport;
  exports._vertical = _vertical;
  exports.default = Observer;

  if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}

})));

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t||self).Lenis=e()}(this,function(){function t(t,e){for(var i=0;i<e.length;i++){var o=e[i];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function e(e,i,o){return i&&t(e.prototype,i),o&&t(e,o),Object.defineProperty(e,"prototype",{writable:!1}),e}function i(){return i=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&(t[o]=i[o])}return t},i.apply(this,arguments)}function o(t,e){return o=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},o(t,e)}function n(){}n.prototype={on:function(t,e,i){var o=this.e||(this.e={});return(o[t]||(o[t]=[])).push({fn:e,ctx:i}),this},once:function(t,e,i){var o=this;function n(){o.off(t,n),e.apply(i,arguments)}return n._=e,this.on(t,n,i)},emit:function(t){for(var e=[].slice.call(arguments,1),i=((this.e||(this.e={}))[t]||[]).slice(),o=0,n=i.length;o<n;o++)i[o].fn.apply(i[o].ctx,e);return this},off:function(t,e){var i=this.e||(this.e={}),o=i[t],n=[];if(o&&e)for(var r=0,s=o.length;r<s;r++)o[r].fn!==e&&o[r].fn._!==e&&n.push(o[r]);return n.length?i[t]=n:delete i[t],this}};var r=n;n.TinyEmitter=r,"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var s=function(t){var e={exports:{}};return function(t,e){t.exports=function(){var t=0;function e(e){return"__private_"+t+++"_"+e}function i(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}function o(){}o.prototype={on:function(t,e,i){var o=this.e||(this.e={});return(o[t]||(o[t]=[])).push({fn:e,ctx:i}),this},once:function(t,e,i){var o=this;function n(){o.off(t,n),e.apply(i,arguments)}return n._=e,this.on(t,n,i)},emit:function(t){for(var e=[].slice.call(arguments,1),i=((this.e||(this.e={}))[t]||[]).slice(),o=0,n=i.length;o<n;o++)i[o].fn.apply(i[o].ctx,e);return this},off:function(t,e){var i=this.e||(this.e={}),o=i[t],n=[];if(o&&e)for(var r=0,s=o.length;r<s;r++)o[r].fn!==e&&o[r].fn._!==e&&n.push(o[r]);return n.length?i[t]=n:delete i[t],this}};var n=o;n.TinyEmitter=o;var r,s="virtualscroll",l=e("options"),h=e("el"),a=e("emitter"),c=e("event"),u=e("touchStart"),d=e("bodyTouchAction");return function(){function t(t){var e=this;Object.defineProperty(this,l,{writable:!0,value:void 0}),Object.defineProperty(this,h,{writable:!0,value:void 0}),Object.defineProperty(this,a,{writable:!0,value:void 0}),Object.defineProperty(this,c,{writable:!0,value:void 0}),Object.defineProperty(this,u,{writable:!0,value:void 0}),Object.defineProperty(this,d,{writable:!0,value:void 0}),this._onWheel=function(t){var o=i(e,l)[l],n=i(e,c)[c];n.deltaX=t.wheelDeltaX||-1*t.deltaX,n.deltaY=t.wheelDeltaY||-1*t.deltaY,r.isFirefox&&1===t.deltaMode&&(n.deltaX*=o.firefoxMultiplier,n.deltaY*=o.firefoxMultiplier),n.deltaX*=o.mouseMultiplier,n.deltaY*=o.mouseMultiplier,e._notify(t)},this._onMouseWheel=function(t){var o=i(e,c)[c];o.deltaX=t.wheelDeltaX?t.wheelDeltaX:0,o.deltaY=t.wheelDeltaY?t.wheelDeltaY:t.wheelDelta,e._notify(t)},this._onTouchStart=function(t){var o=t.targetTouches?t.targetTouches[0]:t;i(e,u)[u].x=o.pageX,i(e,u)[u].y=o.pageY},this._onTouchMove=function(t){var o=i(e,l)[l];o.preventTouch&&!t.target.classList.contains(o.unpreventTouchClass)&&t.preventDefault();var n=i(e,c)[c],r=t.targetTouches?t.targetTouches[0]:t;n.deltaX=(r.pageX-i(e,u)[u].x)*o.touchMultiplier,n.deltaY=(r.pageY-i(e,u)[u].y)*o.touchMultiplier,i(e,u)[u].x=r.pageX,i(e,u)[u].y=r.pageY,e._notify(t)},this._onKeyDown=function(t){var o=i(e,c)[c];o.deltaX=o.deltaY=0;var n=window.innerHeight-40;switch(t.keyCode){case 37:case 38:o.deltaY=i(e,l)[l].keyStep;break;case 39:case 40:o.deltaY=-i(e,l)[l].keyStep;break;case 32:o.deltaY=n*(t.shiftKey?1:-1);break;default:return}e._notify(t)},i(this,h)[h]=window,t&&t.el&&(i(this,h)[h]=t.el,delete t.el),r||(r={hasWheelEvent:"onwheel"in document,hasMouseWheelEvent:"onmousewheel"in document,hasTouch:"ontouchstart"in document,hasTouchWin:navigator.msMaxTouchPoints&&navigator.msMaxTouchPoints>1,hasPointer:!!window.navigator.msPointerEnabled,hasKeyDown:"onkeydown"in document,isFirefox:navigator.userAgent.indexOf("Firefox")>-1}),i(this,l)[l]=Object.assign({mouseMultiplier:1,touchMultiplier:2,firefoxMultiplier:15,keyStep:120,preventTouch:!1,unpreventTouchClass:"vs-touchmove-allowed",useKeyboard:!0,useTouch:!0},t),i(this,a)[a]=new n,i(this,c)[c]={y:0,x:0,deltaX:0,deltaY:0},i(this,u)[u]={x:null,y:null},i(this,d)[d]=null,void 0!==i(this,l)[l].passive&&(this.listenerOptions={passive:i(this,l)[l].passive})}var e=t.prototype;return e._notify=function(t){var e=i(this,c)[c];e.x+=e.deltaX,e.y+=e.deltaY,i(this,a)[a].emit(s,{x:e.x,y:e.y,deltaX:e.deltaX,deltaY:e.deltaY,originalEvent:t})},e._bind=function(){r.hasWheelEvent&&i(this,h)[h].addEventListener("wheel",this._onWheel,this.listenerOptions),r.hasMouseWheelEvent&&i(this,h)[h].addEventListener("mousewheel",this._onMouseWheel,this.listenerOptions),r.hasTouch&&i(this,l)[l].useTouch&&(i(this,h)[h].addEventListener("touchstart",this._onTouchStart,this.listenerOptions),i(this,h)[h].addEventListener("touchmove",this._onTouchMove,this.listenerOptions)),r.hasPointer&&r.hasTouchWin&&(i(this,d)[d]=document.body.style.msTouchAction,document.body.style.msTouchAction="none",i(this,h)[h].addEventListener("MSPointerDown",this._onTouchStart,!0),i(this,h)[h].addEventListener("MSPointerMove",this._onTouchMove,!0)),r.hasKeyDown&&i(this,l)[l].useKeyboard&&document.addEventListener("keydown",this._onKeyDown)},e._unbind=function(){r.hasWheelEvent&&i(this,h)[h].removeEventListener("wheel",this._onWheel),r.hasMouseWheelEvent&&i(this,h)[h].removeEventListener("mousewheel",this._onMouseWheel),r.hasTouch&&(i(this,h)[h].removeEventListener("touchstart",this._onTouchStart),i(this,h)[h].removeEventListener("touchmove",this._onTouchMove)),r.hasPointer&&r.hasTouchWin&&(document.body.style.msTouchAction=i(this,d)[d],i(this,h)[h].removeEventListener("MSPointerDown",this._onTouchStart,!0),i(this,h)[h].removeEventListener("MSPointerMove",this._onTouchMove,!0)),r.hasKeyDown&&i(this,l)[l].useKeyboard&&document.removeEventListener("keydown",this._onKeyDown)},e.on=function(t,e){i(this,a)[a].on(s,t,e);var o=i(this,a)[a].e;o&&o[s]&&1===o[s].length&&this._bind()},e.off=function(t,e){i(this,a)[a].off(s,t,e);var o=i(this,a)[a].e;(!o[s]||o[s].length<=0)&&this._unbind()},e.destroy=function(){i(this,a)[a].off(),this._unbind()},t}()}()}(e),e.exports}();function l(t,e){var i=t%e;return i<0&&(i+=e),i}var h=["duration","easing"],a=/*#__PURE__*/function(){function t(){}var o=t.prototype;return o.to=function(t,e){var o=this,n=void 0===e?{}:e,r=n.duration,s=void 0===r?1:r,l=n.easing,a=void 0===l?function(t){return t}:l,c=function(t,e){if(null==t)return{};var i,o,n={},r=Object.keys(t);for(o=0;o<r.length;o++)e.indexOf(i=r[o])>=0||(n[i]=t[i]);return n}(n,h);this.target=t,this.fromKeys=i({},c),this.toKeys=i({},c),this.keys=Object.keys(i({},c)),this.keys.forEach(function(e){o.fromKeys[e]=t[e]}),this.duration=s,this.easing=a,this.currentTime=0,this.isRunning=!0},o.stop=function(){this.isRunning=!1},o.raf=function(t){var e=this;if(this.isRunning){this.currentTime=Math.min(this.currentTime+t,this.duration);var i=this.easing(this.progress);this.keys.forEach(function(t){var o=e.fromKeys[t];e.target[t]=o+(e.toKeys[t]-o)*i}),1===i&&this.stop()}},e(t,[{key:"progress",get:function(){return this.currentTime/this.duration}}]),t}();/*#__PURE__*/
return function(t){var i,n;function r(e){var i,o,n,r,l=void 0===e?{}:e,h=l.duration,c=void 0===h?1.2:h,u=l.easing,d=void 0===u?function(t){return Math.min(1,1.001-Math.pow(2,-10*t))}:u,p=l.smooth,f=void 0===p||p,v=l.mouseMultiplier,y=void 0===v?1:v,w=l.smoothTouch,g=void 0!==w&&w,m=l.touchMultiplier,b=void 0===m?2:m,T=l.direction,M=void 0===T?"vertical":T,S=l.gestureDirection,_=void 0===S?"vertical":S,O=l.infinite,E=void 0!==O&&O,W=l.wrapper,x=void 0===W?window:W,P=l.content,D=void 0===P?document.body:P;(r=t.call(this)||this).onWindowResize=function(){r.wrapperWidth=window.innerWidth,r.wrapperHeight=window.innerHeight},r.onWrapperResize=function(t){var e=t[0];if(e){var i=e.contentRect;r.wrapperWidth=i.width,r.wrapperHeight=i.height}},r.onContentResize=function(t){var e=t[0];if(e){var i=e.contentRect;r.contentWidth=i.width,r.contentHeight=i.height}},r.onVirtualScroll=function(t){var e=t.deltaY,i=t.deltaX,o=t.originalEvent,n=!!o.composedPath().find(function(t){return t.hasAttribute&&t.hasAttribute("data-lenis-prevent")});o.ctrlKey||n||(r.smooth=o.changedTouches?r.smoothTouch:r.options.smooth,r.stopped?o.preventDefault():r.smooth&&4!==o.buttons&&(r.smooth&&o.preventDefault(),r.targetScroll-="both"===r.gestureDirection?i+e:"horizontal"===r.gestureDirection?i:e,r.scrollTo(r.targetScroll)))},r.onScroll=function(t){r.isScrolling&&r.smooth||(r.targetScroll=r.scroll=r.lastScroll=r.wrapperNode[r.scrollProperty],r.notify())},window.lenisVersion="0.2.23",r.options={duration:c,easing:d,smooth:f,mouseMultiplier:y,smoothTouch:g,touchMultiplier:b,direction:M,gestureDirection:_,infinite:E,wrapper:x,content:D},r.duration=c,r.easing=d,r.smooth=f,r.mouseMultiplier=y,r.smoothTouch=g,r.touchMultiplier=b,r.direction=M,r.gestureDirection=_,r.infinite=E,r.wrapperNode=x,r.contentNode=D,r.wrapperNode.addEventListener("scroll",r.onScroll),r.wrapperNode===window?(r.wrapperNode.addEventListener("resize",r.onWindowResize),r.onWindowResize()):(r.wrapperHeight=r.wrapperNode.offsetHeight,r.wrapperWidth=r.wrapperNode.offsetWidth,r.wrapperObserver=new ResizeObserver(r.onWrapperResize),r.wrapperObserver.observe(r.wrapperNode)),r.contentHeight=r.contentNode.offsetHeight,r.contentWidth=r.contentNode.offsetWidth,r.contentObserver=new ResizeObserver(r.onContentResize),r.contentObserver.observe(r.contentNode),r.targetScroll=r.scroll=r.lastScroll=r.wrapperNode[r.scrollProperty],r.animate=new a;var N=(null==(i=navigator)||null==(o=i.userAgentData)?void 0:o.platform)||(null==(n=navigator)?void 0:n.platform)||"unknown";return r.virtualScroll=new s({el:r.wrapperNode,firefoxMultiplier:50,mouseMultiplier:r.mouseMultiplier*(N.includes("Win")?.84:.4),touchMultiplier:r.touchMultiplier,passive:!1,useKeyboard:!1,useTouch:!0}),r.virtualScroll.on(r.onVirtualScroll),r}n=t,(i=r).prototype=Object.create(n.prototype),i.prototype.constructor=i,o(i,n);var h=r.prototype;return h.start=function(){this.stopped=!1},h.stop=function(){this.stopped=!0,this.animate.stop()},h.destroy=function(){var t;this.wrapperNode===window&&this.wrapperNode.removeEventListener("resize",this.onWindowResize),this.wrapperNode.removeEventListener("scroll",this.onScroll),this.virtualScroll.destroy(),null==(t=this.wrapperObserver)||t.disconnect(),this.contentObserver.disconnect()},h.raf=function(t){var e=t-(this.now||0);this.now=t,!this.stopped&&this.smooth&&(this.lastScroll=this.scroll,this.animate.raf(.001*e),this.scroll===this.targetScroll&&(this.lastScroll=this.scroll),this.isScrolling&&(this.setScroll(this.scroll),this.notify()),this.isScrolling=this.scroll!==this.targetScroll)},h.setScroll=function(t){var e=this.infinite?l(t,this.limit):t;"horizontal"===this.direction?this.wrapperNode.scrollTo(e,0):this.wrapperNode.scrollTo(0,e)},h.notify=function(){var t=this.infinite?l(this.scroll,this.limit):this.scroll;this.emit("scroll",{scroll:t,limit:this.limit,velocity:this.velocity,direction:this.lastScroll<t?1:-1,progress:t/this.limit})},h.scrollTo=function(t,e){var i=void 0===e?{}:e,o=i.offset,n=void 0===o?0:o,r=i.immediate,s=void 0!==r&&r,l=i.duration,h=void 0===l?this.duration:l,a=i.easing,c=void 0===a?this.easing:a;if(null!=t){var u;if("number"==typeof t)u=t;else if("top"===t||"#top"===t)u=0;else if("bottom"===t)u=this.limit;else{var d;if("string"==typeof t)d=document.querySelector(t);else{if(null==t||!t.nodeType)return;d=t}if(!d)return;var p=0;if(this.wrapperNode!==window){var f=this.wrapperNode.getBoundingClientRect();p="horizontal"===this.direction?f.left:f.top}var v=d.getBoundingClientRect();u=("horizontal"===this.direction?v.left:v.top)+this.scroll-p}u+=n,this.targetScroll=this.infinite?u:Math.max(0,Math.min(u,this.limit)),!this.smooth||s?(this.animate.stop(),this.scroll=this.lastScroll=this.targetScroll,this.setScroll(this.targetScroll)):this.animate.to(this,{duration:h,easing:c,scroll:this.targetScroll})}},e(r,[{key:"scrollProperty",get:function(){return this.wrapperNode===window?"horizontal"===this.direction?"scrollX":"scrollY":"horizontal"===this.direction?"scrollLeft":"scrollTop"}},{key:"limit",get:function(){return"horizontal"===this.direction?this.contentWidth-this.wrapperWidth:this.contentHeight-this.wrapperHeight}},{key:"velocity",get:function(){return this.scroll-this.lastScroll}}]),r}(r)});

/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
}(this, (function (exports) { 'use strict';

	const REVISION = '128';
	const MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	const TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const SmoothShading = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;
	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const RGBEFormat = RGBAFormat;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBIntegerFormat = 1032;
	const RGBAIntegerFormat = 1033;
	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const LogLuvEncoding = 3003;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;
	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;
	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const StreamDrawUsage = 35040;
	const StaticReadUsage = 35045;
	const DynamicReadUsage = 35049;
	const StreamReadUsage = 35041;
	const StaticCopyUsage = 35046;
	const DynamicCopyUsage = 35050;
	const StreamCopyUsage = 35042;
	const GLSL1 = '100';
	const GLSL3 = '300 es';

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	class EventDispatcher {
		addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			const listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		}

		hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			const listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		}

		removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				const index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		}

		dispatchEvent(event) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this; // Make a copy, in case listeners are removed while iterating.

				const array = listenerArray.slice(0);

				for (let i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}

				event.target = null;
			}
		}

	}

	const _lut = [];

	for (let i = 0; i < 256; i++) {
		_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}

	let _seed = 1234567;
	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	function generateUUID() {
		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

		return uuid.toUpperCase();
	}

	function clamp(value, min, max) {
		return Math.max(min, Math.min(max, value));
	} // compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation


	function euclideanModulo(n, m) {
		return (n % m + m) % m;
	} // Linear mapping from range <a1, a2> to range <b1, b2>


	function mapLinear(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


	function inverseLerp(x, y, value) {
		if (x !== y) {
			return (value - x) / (y - x);
		} else {
			return 0;
		}
	} // https://en.wikipedia.org/wiki/Linear_interpolation


	function lerp(x, y, t) {
		return (1 - t) * x + t * y;
	} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


	function damp(x, y, lambda, dt) {
		return lerp(x, y, 1 - Math.exp(-lambda * dt));
	} // https://www.desmos.com/calculator/vcsjnyz7x4


	function pingpong(x, length = 1) {
		return length - Math.abs(euclideanModulo(x, length * 2) - length);
	} // http://en.wikipedia.org/wiki/Smoothstep


	function smoothstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	}

	function smootherstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	} // Random integer from <low, high> interval


	function randInt(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1));
	} // Random float from <low, high> interval


	function randFloat(low, high) {
		return low + Math.random() * (high - low);
	} // Random float from <-range/2, range/2> interval


	function randFloatSpread(range) {
		return range * (0.5 - Math.random());
	} // Deterministic pseudo-random float in the interval [ 0, 1 ]


	function seededRandom(s) {
		if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;
		return (_seed - 1) / 2147483646;
	}

	function degToRad(degrees) {
		return degrees * DEG2RAD;
	}

	function radToDeg(radians) {
		return radians * RAD2DEG;
	}

	function isPowerOfTwo(value) {
		return (value & value - 1) === 0 && value !== 0;
	}

	function ceilPowerOfTwo(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}

	function floorPowerOfTwo(value) {
		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	}

	function setQuaternionFromProperEuler(q, a, b, c, order) {
		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians
		const cos = Math.cos;
		const sin = Math.sin;
		const c2 = cos(b / 2);
		const s2 = sin(b / 2);
		const c13 = cos((a + c) / 2);
		const s13 = sin((a + c) / 2);
		const c1_3 = cos((a - c) / 2);
		const s1_3 = sin((a - c) / 2);
		const c3_1 = cos((c - a) / 2);
		const s3_1 = sin((c - a) / 2);

		switch (order) {
			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;

			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;

			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;

			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;

			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;

			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;

			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
		}
	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler
	});

	class Vector2 {
		constructor(x = 0, y = 0) {
			this.x = x;
			this.y = y;
		}

		get width() {
			return this.x;
		}

		set width(value) {
			this.x = value;
		}

		get height() {
			return this.y;
		}

		set height(value) {
			this.y = value;
		}

		set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y;
		}

		cross(v) {
			return this.x * v.y - this.y * v.x;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		angle() {
			// computes the angle in radians with respect to the positive x-axis
			const angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y;
			return dx * dx + dy * dy;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		}

		rotateAround(center, angle) {
			const c = Math.cos(angle),
						s = Math.sin(angle);
			const x = this.x - center.x;
			const y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			return this;
		}

	}

	Vector2.prototype.isVector2 = true;

	class Matrix3 {
		constructor() {
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			const te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this;
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		}

		setFromMatrix4(m) {
			const me = m.elements;
			this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
			return this;
		}

		multiply(m) {
			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[3],
						a13 = ae[6];
			const a21 = ae[1],
						a22 = ae[4],
						a23 = ae[7];
			const a31 = ae[2],
						a32 = ae[5],
						a33 = ae[8];
			const b11 = be[0],
						b12 = be[3],
						b13 = be[6];
			const b21 = be[1],
						b22 = be[4],
						b23 = be[7];
			const b31 = be[2],
						b32 = be[5],
						b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const a = te[0],
						b = te[1],
						c = te[2],
						d = te[3],
						e = te[4],
						f = te[5],
						g = te[6],
						h = te[7],
						i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		}

		invert() {
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n12 = te[3],
						n22 = te[4],
						n32 = te[5],
						n13 = te[6],
						n23 = te[7],
						n33 = te[8],
						t11 = n33 * n22 - n32 * n23,
						t12 = n32 * n13 - n33 * n12,
						t13 = n23 * n12 - n22 * n13,
						det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		}

		transpose() {
			let tmp;
			const m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		}

		getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).invert().transpose();
		}

		transposeIntoArray(r) {
			const m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		}

		setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			const c = Math.cos(rotation);
			const s = Math.sin(rotation);
			this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
			return this;
		}

		scale(sx, sy) {
			const te = this.elements;
			te[0] *= sx;
			te[3] *= sx;
			te[6] *= sx;
			te[1] *= sy;
			te[4] *= sy;
			te[7] *= sy;
			return this;
		}

		rotate(theta) {
			const c = Math.cos(theta);
			const s = Math.sin(theta);
			const te = this.elements;
			const a11 = te[0],
						a12 = te[3],
						a13 = te[6];
			const a21 = te[1],
						a22 = te[4],
						a23 = te[7];
			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;
			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;
			return this;
		}

		translate(tx, ty) {
			const te = this.elements;
			te[0] += tx * te[2];
			te[3] += tx * te[5];
			te[6] += tx * te[8];
			te[1] += ty * te[2];
			te[4] += ty * te[5];
			te[7] += ty * te[8];
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		}

		clone() {
			return new this.constructor().fromArray(this.elements);
		}

	}

	Matrix3.prototype.isMatrix3 = true;

	let _canvas;

	class ImageUtils {
		static getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}

			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}

			let canvas;

			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {
		constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
			super();
			Object.defineProperty(this, 'id', {
				value: textureId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.image = image;
			this.mipmaps = [];
			this.mapping = mapping;
			this.wrapS = wrapS;
			this.wrapT = wrapT;
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.anisotropy = anisotropy;
			this.format = format;
			this.internalFormat = null;
			this.type = type;
			this.offset = new Vector2(0, 0);
			this.repeat = new Vector2(1, 1);
			this.center = new Vector2(0, 0);
			this.rotation = 0;
			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

			this.encoding = encoding;
			this.version = 0;
			this.onUpdate = null;
		}

		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			return this;
		}

		toJSON(meta) {
			const isRootObject = meta === undefined || typeof meta === 'string';

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			const output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image
				const image = this.image;

				if (image.uuid === undefined) {
					image.uuid = generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					let url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture
						url = [];

						for (let i = 0, l = image.length; i < l; i++) {
							// check cube texture with data textures
							if (image[i].isDataTexture) {
								url.push(serializeImage(image[i].image));
							} else {
								url.push(serializeImage(image[i]));
							}
						}
					} else {
						// process single image
						url = serializeImage(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					};
				}

				output.image = image.uuid;
			}

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;

					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}

						break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;

					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}

						break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype.isTexture = true;

	function serializeImage(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}

	class Vector4 {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		get width() {
			return this.z;
		}

		set width(value) {
			this.z = value;
		}

		get height() {
			return this.w;
		}

		set height(value) {
			this.w = value;
		}

		set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setW(w) {
			this.w = w;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				case 3:
					this.w = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				case 3:
					return this.w;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = v.w !== undefined ? v.w : 1;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z,
						w = this.w;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			const s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		}

		setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			let angle, x, y, z; // variables for result

			const epsilon = 0.01,
						// margin to allow for rounding errors
			epsilon2 = 0.1,
						// margin to distinguish between 0 and 180 degrees
			te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				} // otherwise this singularity is angle = 180


				angle = Math.PI;
				const xx = (m11 + 1) / 2;
				const yy = (m22 + 1) / 2;
				const zz = (m33 + 1) / 2;
				const xy = (m12 + m21) / 4;
				const xz = (m13 + m31) / 4;
				const yz = (m23 + m32) / 4;

				if (xx > yy && xx > zz) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			} // as we have reached here there are no singularities so we can handle normally


			let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();
			return this;
		}

	}

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

	class WebGLRenderTarget extends EventDispatcher {
		constructor(width, height, options) {
			super();
			this.width = width;
			this.height = height;
			this.depth = 1;
			this.scissor = new Vector4(0, 0, width, height);
			this.scissorTest = false;
			this.viewport = new Vector4(0, 0, width, height);
			options = options || {};
			this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.image = {};
			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = 1;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
		}

		setTexture(texture) {
			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};
			this.texture = texture;
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;
				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
		constructor(width, height, options) {
			super(width, height, options);
			this.samples = 4;
		}

		copy(source) {
			super.copy.call(this, source);
			this.samples = source.samples;
			return this;
		}

	}

	WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

	class Quaternion {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}

		static slerp(qa, qb, qm, t) {
			console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
			return qm.slerpQuaternions(qa, qb, t);
		}

		static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			let x0 = src0[srcOffset0 + 0],
					y0 = src0[srcOffset0 + 1],
					z0 = src0[srcOffset0 + 2],
					w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1 + 0],
						y1 = src1[srcOffset1 + 1],
						z1 = src1[srcOffset1 + 2],
						w1 = src1[srcOffset1 + 3];

			if (t === 0) {
				dst[dstOffset + 0] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
				return;
			}

			if (t === 1) {
				dst[dstOffset + 0] = x1;
				dst[dstOffset + 1] = y1;
				dst[dstOffset + 2] = z1;
				dst[dstOffset + 3] = w1;
				return;
			}

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
							dir = cos >= 0 ? 1 : -1,
							sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

				if (sqrSin > Number.EPSILON) {
					const sin = Math.sqrt(sqrSin),
								len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				const tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

				if (s === 1 - t) {
					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		}

		static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			const x0 = src0[srcOffset0];
			const y0 = src0[srcOffset0 + 1];
			const z0 = src0[srcOffset0 + 2];
			const w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1];
			const y1 = src1[srcOffset1 + 1];
			const z1 = src1[srcOffset1 + 2];
			const w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get w() {
			return this._w;
		}

		set w(value) {
			this._w = value;

			this._onChangeCallback();
		}

		set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		}

		copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;
		}

		setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			const x = euler._x,
						y = euler._y,
						z = euler._z,
						order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;
			const c1 = cos(x / 2);
			const c2 = cos(y / 2);
			const c3 = cos(z / 2);
			const s1 = sin(x / 2);
			const s2 = sin(y / 2);
			const s3 = sin(z / 2);

			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}

			if (update !== false) this._onChangeCallback();
			return this;
		}

		setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			const halfAngle = angle / 2,
						s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10],
						trace = m11 + m22 + m33;

			if (trace > 0) {
				const s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;
			} else if (m22 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;
			} else {
				const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;
			}

			this._onChangeCallback();

			return this;
		}

		setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			let r = vFrom.dot(vTo) + 1;

			if (r < Number.EPSILON) {
				// vFrom and vTo point in opposite directions
				r = 0;

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}

			return this.normalize();
		}

		angleTo(q) {
			return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
		}

		rotateTowards(q, step) {
			const angle = this.angleTo(q);
			if (angle === 0) return this;
			const t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		}

		identity() {
			return this.set(0, 0, 0, 1);
		}

		invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		}

		conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;
		}

		dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		}

		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		}

		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		}

		normalize() {
			let l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}

			this._onChangeCallback();

			return this;
		}

		multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		}

		premultiply(q) {
			return this.multiplyQuaternions(q, this);
		}

		multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			const qax = a._x,
						qay = a._y,
						qaz = a._z,
						qaw = a._w;
			const qbx = b._x,
						qby = b._y,
						qbz = b._z,
						qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;
		}

		slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			const x = this._x,
						y = this._y,
						z = this._z,
						w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();

				this._onChangeCallback();

				return this;
			}

			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
						ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = w * ratioA + this._w * ratioB;
			this._x = x * ratioA + this._x * ratioB;
			this._y = y * ratioA + this._y * ratioB;
			this._z = z * ratioA + this._z * ratioB;

			this._onChangeCallback();

			return this;
		}

		slerpQuaternions(qa, qb, t) {
			this.copy(qa).slerp(qb, t);
		}

		equals(quaternion) {
			return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		}

		fromArray(array, offset = 0) {
			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Quaternion.prototype.isQuaternion = true;

	class Vector3 {
		constructor(x = 0, y = 0, z = 0) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		}

		multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		}

		multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		}

		applyEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
		}

		applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		}

		applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		}

		applyQuaternion(q) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const qx = q.x,
						qy = q.y,
						qz = q.z,
						qw = q.w; // calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		}

		project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		}

		unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		}

		transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		} // TODO lengthSquared?


		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		}

		cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		}

		crossVectors(a, b) {
			const ax = a.x,
						ay = a.y,
						az = a.z;
			const bx = b.x,
						by = b.y,
						bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		}

		projectOnVector(v) {
			const denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			const scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		}

		projectOnPlane(planeNormal) {
			_vector$c.copy(this).projectOnVector(planeNormal);

			return this.sub(_vector$c);
		}

		reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
		}

		angleTo(v) {
			const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

			return Math.acos(clamp(theta, -1, 1));
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y,
						dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		}

		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		}

		setFromSphericalCoords(radius, phi, theta) {
			const sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		}

		setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		}

		setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		}

		setFromMatrixPosition(m) {
			const e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		}

		setFromMatrixScale(m) {
			const sx = this.setFromMatrixColumn(m, 0).length();
			const sy = this.setFromMatrixColumn(m, 1).length();
			const sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		}

		setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		}

		setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		}

	}

	Vector3.prototype.isVector3 = true;

	const _vector$c = /*@__PURE__*/new Vector3();

	const _quaternion$4 = /*@__PURE__*/new Quaternion();

	class Box3 {
		constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromArray(array) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = array.length; i < l; i += 3) {
				const x = array[i];
				const y = array[i + 1];
				const z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromBufferAttribute(attribute) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = attribute.count; i < l; i++) {
				const x = attribute.getX(i);
				const y = attribute.getY(i);
				const z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$b.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		setFromObject(object) {
			this.makeEmpty();
			return this.expandByObject(object);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		}

		getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .getCenter() target is now required');
				target = new Vector3();
			}

			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .getSize() target is now required');
				target = new Vector3();
			}

			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		expandByObject(object) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			const geometry = object.geometry;

			if (geometry !== undefined) {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}

				_box$3.copy(geometry.boundingBox);

				_box$3.applyMatrix4(object.matrixWorld);

				this.union(_box$3);
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i]);
			}

			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			if (target === undefined) {
				console.warn('THREE.Box3: .getParameter() target is now required');
				target = new Vector3();
			}

			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		}

		intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		}

		intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.

			return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
		}

		intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			let min, max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return min <= -plane.constant && max >= -plane.constant;
		}

		intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			} // compute box center and extents


			this.getCenter(_center);

			_extents.subVectors(this.max, _center); // translate triangle to aabb origin


			_v0$2.subVectors(triangle.a, _center);

			_v1$7.subVectors(triangle.b, _center);

			_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle


			_f0.subVectors(_v1$7, _v0$2);

			_f1.subVectors(_v2$3, _v1$7);

			_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


			let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // test 3 face normals from the aabb


			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // finally testing the face normal of the triangle
			// use already existing triangle edge vectors here


			_triangleNormal.crossVectors(_f0, _f1);

			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
		}

		clampPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .clampPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		getBoundingSphere(target) {
			if (target === undefined) {
				console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
			}

			this.getCenter(target.center);
			target.radius = this.getSize(_vector$b).length() * 0.5;
			return target;
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

			if (this.isEmpty()) this.makeEmpty();
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


			this.setFromPoints(_points);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box3.prototype.isBox3 = true;
	const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

	const _vector$b = /*@__PURE__*/new Vector3();

	const _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices


	const _v0$2 = /*@__PURE__*/new Vector3();

	const _v1$7 = /*@__PURE__*/new Vector3();

	const _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors


	const _f0 = /*@__PURE__*/new Vector3();

	const _f1 = /*@__PURE__*/new Vector3();

	const _f2 = /*@__PURE__*/new Vector3();

	const _center = /*@__PURE__*/new Vector3();

	const _extents = /*@__PURE__*/new Vector3();

	const _triangleNormal = /*@__PURE__*/new Vector3();

	const _testAxis = /*@__PURE__*/new Vector3();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


			const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

			const p0 = v0.dot(_testAxis);
			const p1 = v1.dot(_testAxis);
			const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;
			}
		}

		return true;
	}

	const _box$2 = /*@__PURE__*/new Box3();

	const _v1$6 = /*@__PURE__*/new Vector3();

	const _toFarthestPoint = /*@__PURE__*/new Vector3();

	const _toPoint = /*@__PURE__*/new Vector3();

	class Sphere {
		constructor(center = new Vector3(), radius = -1) {
			this.center = center;
			this.radius = radius;
		}

		set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		}

		setFromPoints(points, optionalCenter) {
			const center = this.center;

			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$2.setFromPoints(points).getCenter(center);
			}

			let maxRadiusSq = 0;

			for (let i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		}

		copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		}

		isEmpty() {
			return this.radius < 0;
		}

		makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		}

		containsPoint(point) {
			return point.distanceToSquared(this.center) <= this.radius * this.radius;
		}

		distanceToPoint(point) {
			return point.distanceTo(this.center) - this.radius;
		}

		intersectsSphere(sphere) {
			const radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
		}

		intersectsBox(box) {
			return box.intersectsSphere(this);
		}

		intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		}

		clampPoint(point, target) {
			const deltaLengthSq = this.center.distanceToSquared(point);

			if (target === undefined) {
				console.warn('THREE.Sphere: .clampPoint() target is now required');
				target = new Vector3();
			}

			target.copy(point);

			if (deltaLengthSq > this.radius * this.radius) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		}

		getBoundingBox(target) {
			if (target === undefined) {
				console.warn('THREE.Sphere: .getBoundingBox() target is now required');
				target = new Box3();
			}

			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		}

		applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		}

		translate(offset) {
			this.center.add(offset);
			return this;
		}

		expandByPoint(point) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
			_toPoint.subVectors(point, this.center);

			const lengthSq = _toPoint.lengthSq();

			if (lengthSq > this.radius * this.radius) {
				const length = Math.sqrt(lengthSq);
				const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
				this.radius += missingRadiusHalf;
			}

			return this;
		}

		union(sphere) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.
			_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

			this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
			return this;
		}

		equals(sphere) {
			return sphere.center.equals(this.center) && sphere.radius === this.radius;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$a = /*@__PURE__*/new Vector3();

	const _segCenter = /*@__PURE__*/new Vector3();

	const _segDir = /*@__PURE__*/new Vector3();

	const _diff = /*@__PURE__*/new Vector3();

	const _edge1 = /*@__PURE__*/new Vector3();

	const _edge2 = /*@__PURE__*/new Vector3();

	const _normal$1 = /*@__PURE__*/new Vector3();

	class Ray {
		constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
			this.origin = origin;
			this.direction = direction;
		}

		set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		}

		copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		}

		at(t, target) {
			if (target === undefined) {
				console.warn('THREE.Ray: .at() target is now required');
				target = new Vector3();
			}

			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		}

		lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		}

		recast(t) {
			this.origin.copy(this.at(t, _vector$a));
			return this;
		}

		closestPointToPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Ray: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			target.subVectors(point, this.origin);
			const directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		}

		distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		}

		distanceSqToPoint(point) {
			const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray


			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}

			_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

			return _vector$a.distanceToSquared(point);
		}

		distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);

			_segDir.copy(v1).sub(v0).normalize();

			_diff.copy(this.origin).sub(_segCenter);

			const segExtent = v0.distanceTo(v1) * 0.5;
			const a01 = -this.direction.dot(_segDir);

			const b0 = _diff.dot(this.direction);

			const b1 = -_diff.dot(_segDir);

			const c = _diff.lengthSq();

			const det = Math.abs(1 - a01 * a01);
			let s0, s1, sqrDist, extDet;

			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = a01 > 0 ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}

			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
			}

			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
			}

			return sqrDist;
		}

		intersectSphere(sphere, target) {
			_vector$a.subVectors(sphere.center, this.origin);

			const tca = _vector$a.dot(this.direction);

			const d2 = _vector$a.dot(_vector$a) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

			const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

			const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

			if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.

			if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

			return this.at(t0, target);
		}

		intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		}

		distanceToPlane(plane) {
			const denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				} // Null is preferable to undefined since undefined means.... it is undefined


				return null;
			}

			const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		}

		intersectPlane(plane, target) {
			const t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		}

		intersectsPlane(plane) {
			// check if the ray lies on the plane first
			const distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			const denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			} // ray origin is behind the plane (and is pointing behind it)


			return false;
		}

		intersectBox(box, target) {
			let tmin, tmax, tymin, tymax, tzmin, tzmax;
			const invdirx = 1 / this.direction.x,
						invdiry = 1 / this.direction.y,
						invdirz = 1 / this.direction.z;
			const origin = this.origin;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;
			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if (tmin > tzmax || tzmin > tmax) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		}

		intersectsBox(box) {
			return this.intersectBox(box, _vector$a) !== null;
		}

		intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);

			_edge2.subVectors(c, a);

			_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


			let DdN = this.direction.dot(_normal$1);
			let sign;

			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_diff.subVectors(this.origin, a);

			const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

			if (DdQxE2 < 0) {
				return null;
			}

			const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

			if (DdE1xQ < 0) {
				return null;
			} // b1+b2 > 1, no intersection


			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			} // Line intersects triangle, check if ray does.


			const QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection


			if (QdN < 0) {
				return null;
			} // Ray intersects triangle.


			return this.at(QdN / DdN, target);
		}

		applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		}

		equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class Matrix4 {
		constructor() {
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			const te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		clone() {
			return new Matrix4().fromArray(this.elements);
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		}

		copyPosition(m) {
			const te = this.elements,
						me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		}

		setFromMatrix3(m) {
			const me = m.elements;
			this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		}

		makeBasis(xAxis, yAxis, zAxis) {
			this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
			return this;
		}

		extractRotation(m) {
			// this method does not support reflection matrices
			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();

			const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();

			const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			const te = this.elements;
			const x = euler.x,
						y = euler.y,
						z = euler.z;
			const a = Math.cos(x),
						b = Math.sin(x);
			const c = Math.cos(y),
						d = Math.sin(y);
			const e = Math.cos(z),
						f = Math.sin(z);

			if (euler.order === 'XYZ') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce - df * b;
				te[4] = -a * f;
				te[8] = de + cf * b;
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
			} // bottom row


			te[3] = 0;
			te[7] = 0;
			te[11] = 0; // last column

			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		}

		lookAt(eye, target, up) {
			const te = this.elements;

			_z.subVectors(eye, target);

			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}

			_z.normalize();

			_x.crossVectors(up, _z);

			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}

				_z.normalize();

				_x.crossVectors(up, _z);
			}

			_x.normalize();

			_y.crossVectors(_z, _x);

			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		}

		multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[4],
						a13 = ae[8],
						a14 = ae[12];
			const a21 = ae[1],
						a22 = ae[5],
						a23 = ae[9],
						a24 = ae[13];
			const a31 = ae[2],
						a32 = ae[6],
						a33 = ae[10],
						a34 = ae[14];
			const a41 = ae[3],
						a42 = ae[7],
						a43 = ae[11],
						a44 = ae[15];
			const b11 = be[0],
						b12 = be[4],
						b13 = be[8],
						b14 = be[12];
			const b21 = be[1],
						b22 = be[5],
						b23 = be[9],
						b24 = be[13];
			const b31 = be[2],
						b32 = be[6],
						b33 = be[10],
						b34 = be[14];
			const b41 = be[3],
						b42 = be[7],
						b43 = be[11],
						b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const n11 = te[0],
						n12 = te[4],
						n13 = te[8],
						n14 = te[12];
			const n21 = te[1],
						n22 = te[5],
						n23 = te[9],
						n24 = te[13];
			const n31 = te[2],
						n32 = te[6],
						n33 = te[10],
						n34 = te[14];
			const n41 = te[3],
						n42 = te[7],
						n43 = te[11],
						n44 = te[15]; //TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		}

		transpose() {
			const te = this.elements;
			let tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		}

		setPosition(x, y, z) {
			const te = this.elements;

			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}

			return this;
		}

		invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n41 = te[3],
						n12 = te[4],
						n22 = te[5],
						n32 = te[6],
						n42 = te[7],
						n13 = te[8],
						n23 = te[9],
						n33 = te[10],
						n43 = te[11],
						n14 = te[12],
						n24 = te[13],
						n34 = te[14],
						n44 = te[15],
						t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
						t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
						t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
						t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		}

		scale(v) {
			const te = this.elements;
			const x = v.x,
						y = v.y,
						z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		}

		getMaxScaleOnAxis() {
			const te = this.elements;
			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		}

		makeTranslation(x, y, z) {
			this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
			return this;
		}

		makeRotationX(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationY(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationZ(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			const c = Math.cos(angle);
			const s = Math.sin(angle);
			const t = 1 - c;
			const x = axis.x,
						y = axis.y,
						z = axis.z;
			const tx = t * x,
						ty = t * y;
			this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
			return this;
		}

		makeScale(x, y, z) {
			this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
			return this;
		}

		makeShear(x, y, z) {
			this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
			return this;
		}

		compose(position, quaternion, scale) {
			const te = this.elements;
			const x = quaternion._x,
						y = quaternion._y,
						z = quaternion._z,
						w = quaternion._w;
			const x2 = x + x,
						y2 = y + y,
						z2 = z + z;
			const xx = x * x2,
						xy = x * y2,
						xz = x * z2;
			const yy = y * y2,
						yz = y * z2,
						zz = z * z2;
			const wx = w * x2,
						wy = w * y2,
						wz = w * z2;
			const sx = scale.x,
						sy = scale.y,
						sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		}

		decompose(position, quaternion, scale) {
			const te = this.elements;

			let sx = _v1$5.set(te[0], te[1], te[2]).length();

			const sy = _v1$5.set(te[4], te[5], te[6]).length();

			const sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


			const det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14]; // scale the rotation part

			_m1$2.copy(this);

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;
			_m1$2.elements[0] *= invSX;
			_m1$2.elements[1] *= invSX;
			_m1$2.elements[2] *= invSX;
			_m1$2.elements[4] *= invSY;
			_m1$2.elements[5] *= invSY;
			_m1$2.elements[6] *= invSY;
			_m1$2.elements[8] *= invSZ;
			_m1$2.elements[9] *= invSZ;
			_m1$2.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1$2);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		}

		makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			const te = this.elements;
			const x = 2 * near / (right - left);
			const y = 2 * near / (top - bottom);
			const a = (right + left) / (right - left);
			const b = (top + bottom) / (top - bottom);
			const c = -(far + near) / (far - near);
			const d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		}

		makeOrthographic(left, right, top, bottom, near, far) {
			const te = this.elements;
			const w = 1.0 / (right - left);
			const h = 1.0 / (top - bottom);
			const p = 1.0 / (far - near);
			const x = (right + left) * w;
			const y = (top + bottom) * h;
			const z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		}

	}

	Matrix4.prototype.isMatrix4 = true;

	const _v1$5 = /*@__PURE__*/new Vector3();

	const _m1$2 = /*@__PURE__*/new Matrix4();

	const _zero = /*@__PURE__*/new Vector3(0, 0, 0);

	const _one = /*@__PURE__*/new Vector3(1, 1, 1);

	const _x = /*@__PURE__*/new Vector3();

	const _y = /*@__PURE__*/new Vector3();

	const _z = /*@__PURE__*/new Vector3();

	const _matrix$1 = /*@__PURE__*/new Matrix4();

	const _quaternion$3 = /*@__PURE__*/new Quaternion();

	class Euler {
		constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get order() {
			return this._order;
		}

		set order(value) {
			this._order = value;

			this._onChangeCallback();
		}

		set(x, y, z, order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		}

		copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m, order, update) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements;
			const m11 = te[0],
						m12 = te[4],
						m13 = te[8];
			const m21 = te[1],
						m22 = te[5],
						m23 = te[9];
			const m31 = te[2],
						m32 = te[6],
						m33 = te[10];
			order = order || this._order;

			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));

					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}

					break;

				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));

					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}

					break;

				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));

					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}

					break;

				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));

					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}

					break;

				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));

					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}

					break;

				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));

					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}

					break;

				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}

			this._order = order;
			if (update !== false) this._onChangeCallback();
			return this;
		}

		setFromQuaternion(q, order, update) {
			_matrix$1.makeRotationFromQuaternion(q);

			return this.setFromRotationMatrix(_matrix$1, order, update);
		}

		setFromVector3(v, order) {
			return this.set(v.x, v.y, v.z, order || this._order);
		}

		reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$3.setFromEuler(this);

			return this.setFromQuaternion(_quaternion$3, newOrder);
		}

		equals(euler) {
			return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		}

		fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		}

		toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			} else {
				return new Vector3(this._x, this._y, this._z);
			}
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Euler.prototype.isEuler = true;
	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	class Layers {
		constructor() {
			this.mask = 1 | 0;
		}

		set(channel) {
			this.mask = 1 << channel | 0;
		}

		enable(channel) {
			this.mask |= 1 << channel | 0;
		}

		enableAll() {
			this.mask = 0xffffffff | 0;
		}

		toggle(channel) {
			this.mask ^= 1 << channel | 0;
		}

		disable(channel) {
			this.mask &= ~(1 << channel | 0);
		}

		disableAll() {
			this.mask = 0;
		}

		test(layers) {
			return (this.mask & layers.mask) !== 0;
		}

	}

	let _object3DId = 0;

	const _v1$4 = new /*@__PURE__*/Vector3();

	const _q1 = new /*@__PURE__*/Quaternion();

	const _m1$1 = new /*@__PURE__*/Matrix4();

	const _target = new /*@__PURE__*/Vector3();

	const _position$3 = new /*@__PURE__*/Vector3();

	const _scale$2 = new /*@__PURE__*/Vector3();

	const _quaternion$2 = new /*@__PURE__*/Quaternion();

	const _xAxis = new /*@__PURE__*/Vector3(1, 0, 0);

	const _yAxis = new /*@__PURE__*/Vector3(0, 1, 0);

	const _zAxis = new /*@__PURE__*/Vector3(0, 0, 1);

	const _addedEvent = {
		type: 'added'
	};
	const _removedEvent = {
		type: 'removed'
	};

	class Object3D extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _object3DId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Object3D';
			this.parent = null;
			this.children = [];
			this.up = Object3D.DefaultUp.clone();
			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3(1, 1, 1);

			function onRotationChange() {
				quaternion.setFromEuler(rotation, false);
			}

			function onQuaternionChange() {
				rotation.setFromQuaternion(quaternion, undefined, false);
			}

			rotation._onChange(onRotationChange);

			quaternion._onChange(onQuaternionChange);

			Object.defineProperties(this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			});
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
			this.layers = new Layers();
			this.visible = true;
			this.castShadow = false;
			this.receiveShadow = false;
			this.frustumCulled = true;
			this.renderOrder = 0;
			this.animations = [];
			this.userData = {};
		}

		onBeforeRender() {}

		onAfterRender() {}

		applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		}

		applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		}

		setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		}

		setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		}

		setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		}

		setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		}

		rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(_q1);
			return this;
		}

		rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(_q1);
			return this;
		}

		rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		}

		rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		}

		rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		}

		translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$4.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(_v1$4.multiplyScalar(distance));
			return this;
		}

		translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		}

		translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		}

		translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		}

		localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		}

		worldToLocal(vector) {
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		}

		lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}

			const parent = this.parent;
			this.updateWorldMatrix(true, false);

			_position$3.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position$3, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position$3, this.up);
			}

			this.quaternion.setFromRotationMatrix(_m1$1);

			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);

				_q1.setFromRotationMatrix(_m1$1);

				this.quaternion.premultiply(_q1.invert());
			}
		}

		add(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}

			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		}

		remove(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			const index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}

			return this;
		}

		clear() {
			for (let i = 0; i < this.children.length; i++) {
				const object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}

			this.children.length = 0;
			return this;
		}

		attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			this.updateWorldMatrix(true, false);

			_m1$1.copy(this.matrixWorld).invert();

			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);

				_m1$1.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix4(_m1$1);
			this.add(object);
			object.updateWorldMatrix(false, true);
			return this;
		}

		getObjectById(id) {
			return this.getObjectByProperty('id', id);
		}

		getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		}

		getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (let i = 0, l = this.children.length; i < l; i++) {
				const child = this.children[i];
				const object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		}

		getWorldPosition(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldPosition() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		}

		getWorldQuaternion(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
				target = new Quaternion();
			}

			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, target, _scale$2);
			return target;
		}

		getWorldScale(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldScale() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, _quaternion$2, target);
			return target;
		}

		getWorldDirection(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldDirection() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		}

		raycast() {}

		traverse(callback) {
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		}

		traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		}

		traverseAncestors(callback) {
			const parent = this.parent;

			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		}

		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		}

		updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;
				force = true;
			} // update children


			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		}

		updateWorldMatrix(updateParents, updateChildren) {
			const parent = this.parent;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			} // update children


			if (updateChildren === true) {
				const children = this.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		}

		toJSON(meta) {
			// meta is a string when called from JSON.stringify
			const isRootObject = meta === undefined || typeof meta === 'string';
			const output = {}; // meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.

			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			} // standard Object3D serialization


			const object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
			} //


			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				const parameters = this.geometry.parameters;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					const shapes = parameters.shapes;

					if (Array.isArray(shapes)) {
						for (let i = 0, l = shapes.length; i < l; i++) {
							const shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					const uuids = [];

					for (let i = 0, l = this.material.length; i < l; i++) {
						uuids.push(serialize(meta.materials, this.material[i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			} //


			if (this.children.length > 0) {
				object.children = [];

				for (let i = 0; i < this.children.length; i++) {
					object.children.push(this.children[i].toJSON(meta).object);
				}
			} //


			if (this.animations.length > 0) {
				object.animations = [];

				for (let i = 0; i < this.animations.length; i++) {
					const animation = this.animations[i];
					object.animations.push(serialize(meta.animations, animation));
				}
			}

			if (isRootObject) {
				const geometries = extractFromCache(meta.geometries);
				const materials = extractFromCache(meta.materials);
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				const shapes = extractFromCache(meta.shapes);
				const skeletons = extractFromCache(meta.skeletons);
				const animations = extractFromCache(meta.animations);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (shapes.length > 0) output.shapes = shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
			}

			output.object = object;
			return output; // extract data from the cache hash
			// remove metadata on each item
			// and return as array

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}
		}

		clone(recursive) {
			return new this.constructor().copy(this, recursive);
		}

		copy(source, recursive = true) {
			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (let i = 0; i < source.children.length; i++) {
					const child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		}

	}

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype.isObject3D = true;

	const _vector1 = /*@__PURE__*/new Vector3();

	const _vector2$1 = /*@__PURE__*/new Vector3();

	const _normalMatrix = /*@__PURE__*/new Matrix3();

	class Plane {
		constructor(normal = new Vector3(1, 0, 0), constant = 0) {
			// normal is assumed to be normalized
			this.normal = normal;
			this.constant = constant;
		}

		set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		}

		setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		}

		setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		}

		setFromCoplanarPoints(a, b, c) {
			const normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		}

		copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		}

		normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		}

		negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		}

		distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		}

		distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		}

		projectPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .projectPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		}

		intersectLine(line, target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .intersectLine() target is now required');
				target = new Vector3();
			}

			const direction = line.delta(_vector1);
			const denominator = this.normal.dot(direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				} // Unsure if this is the correct method to handle this case.


				return null;
			}

			const t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {
				return null;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		}

		intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			const startSign = this.distanceToPoint(line.start);
			const endSign = this.distanceToPoint(line.end);
			return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
		}

		intersectsBox(box) {
			return box.intersectsPlane(this);
		}

		intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		}

		coplanarPoint(target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .coplanarPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(this.normal).multiplyScalar(-this.constant);
		}

		applyMatrix4(matrix, optionalNormalMatrix) {
			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

			const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			const normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		}

		translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		}

		equals(plane) {
			return plane.normal.equals(this.normal) && plane.constant === this.constant;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Plane.prototype.isPlane = true;

	const _v0$1 = /*@__PURE__*/new Vector3();

	const _v1$3 = /*@__PURE__*/new Vector3();

	const _v2$2 = /*@__PURE__*/new Vector3();

	const _v3$1 = /*@__PURE__*/new Vector3();

	const _vab = /*@__PURE__*/new Vector3();

	const _vac = /*@__PURE__*/new Vector3();

	const _vbc = /*@__PURE__*/new Vector3();

	const _vap = /*@__PURE__*/new Vector3();

	const _vbp = /*@__PURE__*/new Vector3();

	const _vcp = /*@__PURE__*/new Vector3();

	class Triangle {
		constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

		static getNormal(a, b, c, target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getNormal() target is now required');
				target = new Vector3();
			}

			target.subVectors(c, b);

			_v0$1.subVectors(a, b);

			target.cross(_v0$1);
			const targetLengthSq = target.lengthSq();

			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}

			return target.set(0, 0, 0);
		} // static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html


		static getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);

			_v1$3.subVectors(b, a);

			_v2$2.subVectors(point, a);

			const dot00 = _v0$1.dot(_v0$1);

			const dot01 = _v0$1.dot(_v1$3);

			const dot02 = _v0$1.dot(_v2$2);

			const dot11 = _v1$3.dot(_v1$3);

			const dot12 = _v1$3.dot(_v2$2);

			const denom = dot00 * dot11 - dot01 * dot01;

			if (target === undefined) {
				console.warn('THREE.Triangle: .getBarycoord() target is now required');
				target = new Vector3();
			} // collinear or singular triangle


			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}

			const invDenom = 1 / denom;
			const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

			return target.set(1 - u - v, v, u);
		}

		static containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3$1);
			return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
		}

		static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3$1);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3$1.x);
			target.addScaledVector(uv2, _v3$1.y);
			target.addScaledVector(uv3, _v3$1.z);
			return target;
		}

		static isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);

			_v1$3.subVectors(a, b); // strictly front facing


			return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
		}

		set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		}

		setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		}

		getArea() {
			_v0$1.subVectors(this.c, this.b);

			_v1$3.subVectors(this.a, this.b);

			return _v0$1.cross(_v1$3).length() * 0.5;
		}

		getMidpoint(target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getMidpoint() target is now required');
				target = new Vector3();
			}

			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		}

		getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		}

		getPlane(target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getPlane() target is now required');
				target = new Plane();
			}

			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		}

		getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		}

		getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		}

		containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		}

		isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		}

		intersectsBox(box) {
			return box.intersectsTriangle(this);
		}

		closestPointToPoint(p, target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			const a = this.a,
						b = this.b,
						c = this.c;
			let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a);

			_vac.subVectors(c, a);

			_vap.subVectors(p, a);

			const d1 = _vab.dot(_vap);

			const d2 = _vac.dot(_vap);

			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}

			_vbp.subVectors(p, b);

			const d3 = _vab.dot(_vbp);

			const d4 = _vac.dot(_vbp);

			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}

			const vc = d1 * d4 - d3 * d2;

			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

				return target.copy(a).addScaledVector(_vab, v);
			}

			_vcp.subVectors(p, c);

			const d5 = _vab.dot(_vcp);

			const d6 = _vac.dot(_vcp);

			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}

			const vb = d5 * d2 - d1 * d6;

			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

				return target.copy(a).addScaledVector(_vac, w);
			}

			const va = d3 * d6 - d5 * d4;

			if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
				_vbc.subVectors(c, b);

				w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			} // face region


			const denom = 1 / (va + vb + vc); // u = va * denom

			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		}

		equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		}

	}

	let materialId = 0;

	function Material() {
		Object.defineProperty(this, 'id', {
			value: materialId++
		});
		this.uuid = generateUUID();
		this.name = '';
		this.type = 'Material';
		this.fog = true;
		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;
		this.opacity = 1;
		this.transparent = false;
		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;
		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;
		this.shadowSide = null;
		this.colorWrite = true;
		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
		this.dithering = false;
		this.alphaTest = 0;
		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.visible = true;
		this.toneMapped = true;
		this.userData = {};
		this.version = 0;
	}

	Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
		constructor: Material,
		isMaterial: true,
		onBuild: function ()
		/* shaderobject, renderer */
		{},
		onBeforeCompile: function ()
		/* shaderobject, renderer */
		{},
		customProgramCacheKey: function () {
			return this.onBeforeCompile.toString();
		},
		setValues: function (values) {
			if (values === undefined) return;

			for (const key in values) {
				const newValue = values[key];

				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				} // for backward compatability if shading is set in the constructor


				if (key === 'shading') {
					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
					this.flatShading = newValue === FlatShading ? true : false;
					continue;
				}

				const currentValue = this[key];

				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		},
		toJSON: function (meta) {
			const isRoot = meta === undefined || typeof meta === 'string';

			if (isRoot) {
				meta = {
					textures: {},
					images: {}
				};
			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}; // standard Material serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

			if (this.lightMap && this.lightMap.isTexture) {
				data.lightMap = this.lightMap.toJSON(meta).uuid;
				data.lightMapIntensity = this.lightMapIntensity;
			}

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				if (this.combine !== undefined) data.combine = this.combine;
			}

			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.size !== undefined) data.size = this.size;
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.morphTargets === true) data.morphTargets = true;
			if (this.morphNormals === true) data.morphNormals = true;
			if (this.skinning === true) data.skinning = true;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}

			if (isRoot) {
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		},
		clone: function () {
			return new this.constructor().copy(this);
		},
		copy: function (source) {
			this.name = source.name;
			this.fog = source.fog;
			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if (srcPlanes !== null) {
				const n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (let i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		},
		dispose: function () {
			this.dispatchEvent({
				type: 'dispose'
			});
		}
	});
	Object.defineProperty(Material.prototype, 'needsUpdate', {
		set: function (value) {
			if (value === true) this.version++;
		}
	});

	const _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	const _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	const _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}

	function SRGBToLinear(c) {
		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}

	class Color {
		constructor(r, g, b) {
			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}

			return this.setRGB(r, g, b);
		}

		set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		}

		setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		}

		setHex(hex) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			return this;
		}

		setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;
			return this;
		}

		setHSL(h, s, l) {
			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1);
			s = clamp(s, 0, 1);
			l = clamp(l, 0, 1);

			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
				const q = 2 * l - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}

			return this;
		}

		setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}

			let m;

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				let color;
				const name = m[1];
				const components = m[2];

				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							handleAlpha(color[4]);
							return this;
						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							handleAlpha(color[4]);
							return this;
						}

						break;

					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat(color[1]) / 360;
							const s = parseInt(color[2], 10) / 100;
							const l = parseInt(color[3], 10) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l);
						}

						break;
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				const hex = m[1];
				const size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					return this;
				}
			}

			if (style && style.length > 0) {
				return this.setColorName(style);
			}

			return this;
		}

		setColorName(style) {
			// color keywords
			const hex = _colorKeywords[style.toLowerCase()];

			if (hex !== undefined) {
				// red
				this.setHex(hex);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}

			return this;
		}

		clone() {
			return new this.constructor(this.r, this.g, this.b);
		}

		copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		}

		copyGammaToLinear(color, gammaFactor = 2.0) {
			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);
			return this;
		}

		copyLinearToGamma(color, gammaFactor = 2.0) {
			const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);
			return this;
		}

		convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);
			return this;
		}

		convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);
			return this;
		}

		copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		}

		copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		}

		convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		}

		convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		}

		getHex() {
			return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		}

		getHexString() {
			return ('000000' + this.getHex().toString(16)).slice(-6);
		}

		getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0
			if (target === undefined) {
				console.warn('THREE.Color: .getHSL() target is now required');
				target = {
					h: 0,
					s: 0,
					l: 0
				};
			}

			const r = this.r,
						g = this.g,
						b = this.b;
			const max = Math.max(r, g, b);
			const min = Math.min(r, g, b);
			let hue, saturation;
			const lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				const delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;

					case g:
						hue = (b - r) / delta + 2;
						break;

					case b:
						hue = (r - g) / delta + 4;
						break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		}

		getStyle() {
			return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		}

		offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		}

		add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		}

		addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		}

		addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		}

		sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		}

		multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		}

		multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		}

		lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		}

		lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		}

		lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			const h = lerp(_hslA.h, _hslB.h, alpha);
			const s = lerp(_hslA.s, _hslB.s, alpha);
			const l = lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		}

		equals(c) {
			return c.r === this.r && c.g === this.g && c.b === this.b;
		}

		fromArray(array, offset = 0) {
			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);

			if (attribute.normalized === true) {
				// assuming Uint8Array
				this.r /= 255;
				this.g /= 255;
				this.b /= 255;
			}

			return this;
		}

		toJSON() {
			return this.getHex();
		}

	}

	Color.NAMES = _colorKeywords;
	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>
	 * }
	 */

	class MeshBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshBasicMaterial';
			this.color = new Color(0xffffff); // emissive

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.skinning = false;
			this.morphTargets = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			return this;
		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	const _vector$9 = new /*@__PURE__*/Vector3();

	const _vector2 = new /*@__PURE__*/Vector2();

	class BufferAttribute {
		constructor(array, itemSize, normalized) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.name = '';
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;

			this.onUploadCallback = function () {};
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (let i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		copyArray(array) {
			this.array.set(array);
			return this;
		}

		copyColorsArray(colors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = colors.length; i < l; i++) {
				let color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		}

		copyVector2sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		}

		copyVector3sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		}

		copyVector4sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		}

		applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector2.fromBufferAttribute(this, i);

					_vector2.applyMatrix3(m);

					this.setXY(i, _vector2.x, _vector2.y);
				}
			} else if (this.itemSize === 3) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector$9.fromBufferAttribute(this, i);

					_vector$9.applyMatrix3(m);

					this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
				}
			}

			return this;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyMatrix4(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyNormalMatrix(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.transformDirection(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		getX(index) {
			return this.array[index * this.itemSize];
		}

		setX(index, x) {
			this.array[index * this.itemSize] = x;
			return this;
		}

		getY(index) {
			return this.array[index * this.itemSize + 1];
		}

		setY(index, y) {
			this.array[index * this.itemSize + 1] = y;
			return this;
		}

		getZ(index) {
			return this.array[index * this.itemSize + 2];
		}

		setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;
			return this;
		}

		getW(index) {
			return this.array[index * this.itemSize + 3];
		}

		setW(index, w) {
			this.array[index * this.itemSize + 3] = w;
			return this;
		}

		setXY(index, x, y) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		}

		toJSON() {
			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			};
			if (this.name !== '') data.name = this.name;
			if (this.usage !== StaticDrawUsage) data.usage = this.usage;
			if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
			return data;
		}

	}

	BufferAttribute.prototype.isBufferAttribute = true; //

	class Int8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int8Array(array), itemSize, normalized);
		}

	}

	class Uint8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8Array(array), itemSize, normalized);
		}

	}

	class Uint8ClampedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8ClampedArray(array), itemSize, normalized);
		}

	}

	class Int16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int16Array(array), itemSize, normalized);
		}

	}

	class Uint16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	class Int32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int32Array(array), itemSize, normalized);
		}

	}

	class Uint32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint32Array(array), itemSize, normalized);
		}

	}

	class Float16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	class Float32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float32Array(array), itemSize, normalized);
		}

	}

	class Float64BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float64Array(array), itemSize, normalized);
		}

	} //

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;
		let max = array[0];

		for (let i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	let _id = 0;

	const _m1 = new /*@__PURE__*/Matrix4();

	const _obj = new /*@__PURE__*/Object3D();

	const _offset = new /*@__PURE__*/Vector3();

	const _box$1 = new /*@__PURE__*/Box3();

	const _boxMorphTargets = new /*@__PURE__*/Box3();

	const _vector$8 = new /*@__PURE__*/Vector3();

	class BufferGeometry extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _id++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'BufferGeometry';
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.morphTargetsRelative = false;
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
			this.drawRange = {
				start: 0,
				count: Infinity
			};
			this.userData = {};
		}

		getIndex() {
			return this.index;
		}

		setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}

			return this;
		}

		getAttribute(name) {
			return this.attributes[name];
		}

		setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		}

		deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		}

		hasAttribute(name) {
			return this.attributes[name] !== undefined;
		}

		addGroup(start, count, materialIndex = 0) {
			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		}

		clearGroups() {
			this.groups = [];
		}

		setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		}

		applyMatrix4(matrix) {
			const position = this.attributes.position;

			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}

			const normal = this.attributes.normal;

			if (normal !== undefined) {
				const normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}

			const tangent = this.attributes.tangent;

			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		}

		rotateX(angle) {
			// rotate geometry around world x-axis
			_m1.makeRotationX(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateY(angle) {
			// rotate geometry around world y-axis
			_m1.makeRotationY(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1.makeRotationZ(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		translate(x, y, z) {
			// translate geometry
			_m1.makeTranslation(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		scale(x, y, z) {
			// scale geometry
			_m1.makeScale(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		lookAt(vector) {
			_obj.lookAt(vector);

			_obj.updateMatrix();

			this.applyMatrix4(_obj.matrix);
			return this;
		}

		center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		}

		setFromPoints(points) {
			const position = [];

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		}

		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
				return;
			}

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_box$1.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(this.boundingBox.min, _box$1.min);

							this.boundingBox.expandByPoint(_vector$8);

							_vector$8.addVectors(this.boundingBox.max, _box$1.max);

							this.boundingBox.expandByPoint(_vector$8);
						} else {
							this.boundingBox.expandByPoint(_box$1.min);
							this.boundingBox.expandByPoint(_box$1.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		}

		computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}

			if (position) {
				// first, find the center of the bounding sphere
				const center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute(position); // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_boxMorphTargets.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);

							_box$1.expandByPoint(_vector$8);

							_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);

							_box$1.expandByPoint(_vector$8);
						} else {
							_box$1.expandByPoint(_boxMorphTargets.min);

							_box$1.expandByPoint(_boxMorphTargets.max);
						}
					}
				}

				_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case


				let maxRadiusSq = 0;

				for (let i = 0, il = position.count; i < il; i++) {
					_vector$8.fromBufferAttribute(position, i);

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
				} // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						const morphTargetsRelative = this.morphTargetsRelative;

						for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
							_vector$8.fromBufferAttribute(morphAttribute, j);

							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);

								_vector$8.add(_offset);
							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
						}
					}
				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		}

		computeFaceNormals() {// backwards compatibility
		}

		computeTangents() {
			const index = this.index;
			const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;
			const nVertices = positions.length / 3;

			if (attributes.tangent === undefined) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}

			const tangents = attributes.tangent.array;
			const tan1 = [],
						tan2 = [];

			for (let i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}

			const vA = new Vector3(),
						vB = new Vector3(),
						vC = new Vector3(),
						uvA = new Vector2(),
						uvB = new Vector2(),
						uvC = new Vector2(),
						sdir = new Vector3(),
						tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}

			let groups = this.groups;

			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
				}
			}

			const tmp = new Vector3(),
						tmp2 = new Vector3();
			const n = new Vector3(),
						n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				const t = tan1[v]; // Gram-Schmidt orthogonalize

				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

				tmp2.crossVectors(n2, t);
				const test = tmp2.dot(tan2[v]);
				const w = test < 0.0 ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleVertex(indices[j + 0]);
					handleVertex(indices[j + 1]);
					handleVertex(indices[j + 2]);
				}
			}
		}

		computeVertexNormals() {
			const index = this.index;
			const positionAttribute = this.getAttribute('position');

			if (positionAttribute !== undefined) {
				let normalAttribute = this.getAttribute('normal');

				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (let i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}

				const pA = new Vector3(),
							pB = new Vector3(),
							pC = new Vector3();
				const nA = new Vector3(),
							nB = new Vector3(),
							nC = new Vector3();
				const cb = new Vector3(),
							ab = new Vector3(); // indexed elements

				if (index) {
					for (let i = 0, il = index.count; i < il; i += 3) {
						const vA = index.getX(i + 0);
						const vB = index.getX(i + 1);
						const vC = index.getX(i + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
						pA.fromBufferAttribute(positionAttribute, i + 0);
						pB.fromBufferAttribute(positionAttribute, i + 1);
						pC.fromBufferAttribute(positionAttribute, i + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
					}
				}

				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		}

		merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;
				console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				if (geometry.attributes[key] === undefined) continue;
				const attribute1 = attributes[key];
				const attributeArray1 = attribute1.array;
				const attribute2 = geometry.attributes[key];
				const attributeArray2 = attribute2.array;
				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

				for (let i = 0, j = attributeOffset; i < length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		}

		normalizeNormals() {
			const normals = this.attributes.normal;

			for (let i = 0, il = normals.count; i < il; i++) {
				_vector$8.fromBufferAttribute(normals, i);

				_vector$8.normalize();

				normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
			}
		}

		toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;
				const array2 = new array.constructor(indices.length * itemSize);
				let index = 0,
						index2 = 0;

				for (let i = 0, l = indices.length; i < l; i++) {
					index = indices[i] * itemSize;

					for (let j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				return new BufferAttribute(array2, itemSize, normalized);
			} //


			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}

			const geometry2 = new BufferGeometry();
			const indices = this.index.array;
			const attributes = this.attributes; // attributes

			for (const name in attributes) {
				const attribute = attributes[name];
				const newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			} // morph attributes


			const morphAttributes = this.morphAttributes;

			for (const name in morphAttributes) {
				const morphArray = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, il = morphAttribute.length; i < il; i++) {
					const attribute = morphAttribute[i];
					const newAttribute = convertBufferAttribute(attribute, indices);
					morphArray.push(newAttribute);
				}

				geometry2.morphAttributes[name] = morphArray;
			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

			const groups = this.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}; // standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				const parameters = this.parameters;

				for (const key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			} // for simplicity the code assumes attributes are not shared across geometries, see #15811


			data.data = {
				attributes: {}
			};
			const index = this.index;

			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				data.data.attributes[key] = attribute.toJSON(data.data);
			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for (const key in this.morphAttributes) {
				const attributeArray = this.morphAttributes[key];
				const array = [];

				for (let i = 0, il = attributeArray.length; i < il; i++) {
					const attribute = attributeArray[i];
					array.push(attribute.toJSON(data.data));
				}

				if (array.length > 0) {
					morphAttributes[key] = array;
					hasMorphAttributes = true;
				}
			}

			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}

			const groups = this.groups;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			const boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}

			return data;
		}

		clone() {
			/*
			 // Handle primitives
				 const parameters = this.parameters;
				 if ( parameters !== undefined ) {
				 const values = [];
				 for ( const key in parameters ) {
				 values.push( parameters[ key ] );
				 }
				 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
				 }
				 return new this.constructor().copy( this );
			 */
			return new BufferGeometry().copy(this);
		}

		copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null; // used for storing cloned, shared data

			const data = {}; // name

			this.name = source.name; // index

			const index = source.index;

			if (index !== null) {
				this.setIndex(index.clone(data));
			} // attributes


			const attributes = source.attributes;

			for (const name in attributes) {
				const attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			} // morph attributes


			const morphAttributes = source.morphAttributes;

			for (const name in morphAttributes) {
				const array = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}

				this.morphAttributes[name] = array;
			}

			this.morphTargetsRelative = source.morphTargetsRelative; // groups

			const groups = source.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);
			} // bounding box


			const boundingBox = source.boundingBox;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			} // bounding sphere


			const boundingSphere = source.boundingSphere;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			} // draw range


			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count; // user data

			this.userData = source.userData;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	BufferGeometry.prototype.isBufferGeometry = true;

	const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

	const _ray$2 = /*@__PURE__*/new Ray();

	const _sphere$3 = /*@__PURE__*/new Sphere();

	const _vA$1 = /*@__PURE__*/new Vector3();

	const _vB$1 = /*@__PURE__*/new Vector3();

	const _vC$1 = /*@__PURE__*/new Vector3();

	const _tempA = /*@__PURE__*/new Vector3();

	const _tempB = /*@__PURE__*/new Vector3();

	const _tempC = /*@__PURE__*/new Vector3();

	const _morphA = /*@__PURE__*/new Vector3();

	const _morphB = /*@__PURE__*/new Vector3();

	const _morphC = /*@__PURE__*/new Vector3();

	const _uvA$1 = /*@__PURE__*/new Vector2();

	const _uvB$1 = /*@__PURE__*/new Vector2();

	const _uvC$1 = /*@__PURE__*/new Vector2();

	const _intersectionPoint = /*@__PURE__*/new Vector3();

	const _intersectionPointWorld = /*@__PURE__*/new Vector3();

	class Mesh extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
			super();
			this.type = 'Mesh';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;
			if (material === undefined) return; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$3.copy(geometry.boundingSphere);

			_sphere$3.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

			_inverseMatrix$2.copy(matrixWorld).invert();

			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing


			if (geometry.boundingBox !== null) {
				if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
			}

			let intersection;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if (index !== null) {
					// indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = index.getX(j);
								const b = index.getX(j + 1);
								const c = index.getX(j + 2);
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(index.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = index.getX(i);
							const b = index.getX(i + 1);
							const c = index.getX(i + 2);
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				} else if (position !== undefined) {
					// non-indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = j;
								const b = j + 1;
								const c = j + 2;
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(position.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = i;
							const b = i + 1;
							const c = i + 2;
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

	}

	Mesh.prototype.isMesh = true;

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		let intersect;

		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
		}

		if (intersect === null) return null;

		_intersectionPointWorld.copy(point);

		_intersectionPointWorld.applyMatrix4(object.matrixWorld);

		const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
		_vA$1.fromBufferAttribute(position, a);

		_vB$1.fromBufferAttribute(position, b);

		_vC$1.fromBufferAttribute(position, c);

		const morphInfluences = object.morphTargetInfluences;

		if (material.morphTargets && morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);

			_morphB.set(0, 0, 0);

			_morphC.set(0, 0, 0);

			for (let i = 0, il = morphPosition.length; i < il; i++) {
				const influence = morphInfluences[i];
				const morphAttribute = morphPosition[i];
				if (influence === 0) continue;

				_tempA.fromBufferAttribute(morphAttribute, a);

				_tempB.fromBufferAttribute(morphAttribute, b);

				_tempC.fromBufferAttribute(morphAttribute, c);

				if (morphTargetsRelative) {
					_morphA.addScaledVector(_tempA, influence);

					_morphB.addScaledVector(_tempB, influence);

					_morphC.addScaledVector(_tempC, influence);
				} else {
					_morphA.addScaledVector(_tempA.sub(_vA$1), influence);

					_morphB.addScaledVector(_tempB.sub(_vB$1), influence);

					_morphC.addScaledVector(_tempC.sub(_vC$1), influence);
				}
			}

			_vA$1.add(_morphA);

			_vB$1.add(_morphB);

			_vC$1.add(_morphC);
		}

		if (object.isSkinnedMesh && material.skinning) {
			object.boneTransform(a, _vA$1);
			object.boneTransform(b, _vB$1);
			object.boneTransform(c, _vC$1);
		}

		const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);

		if (intersection) {
			if (uv) {
				_uvA$1.fromBufferAttribute(uv, a);

				_uvB$1.fromBufferAttribute(uv, b);

				_uvC$1.fromBufferAttribute(uv, c);

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			if (uv2) {
				_uvA$1.fromBufferAttribute(uv2, a);

				_uvB$1.fromBufferAttribute(uv2, b);

				_uvC$1.fromBufferAttribute(uv2, c);

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};
			Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
			intersection.face = face;
		}

		return intersection;
	}

	class BoxGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
			super();
			this.type = 'BoxGeometry';
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
			const scope = this; // segments

			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let numberOfVertices = 0;
			let groupStart = 0; // build each side of the box geometry

			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;
				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;
				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;
				let vertexCounter = 0;
				let groupCount = 0;
				const vector = new Vector3(); // generate vertices, normals and uvs

				for (let iy = 0; iy < gridY1; iy++) {
					const y = iy * segmentHeight - heightHalf;

					for (let ix = 0; ix < gridX1; ix++) {
						const x = ix * segmentWidth - widthHalf; // set values to correct vector component

						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf; // now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z); // uvs

						uvs.push(ix / gridX);
						uvs.push(1 - iy / gridY); // counters

						vertexCounter += 1;
					}
				} // indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment


				for (let iy = 0; iy < gridY; iy++) {
					for (let ix = 0; ix < gridX; ix++) {
						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * (iy + 1);
						const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
						const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // increase counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

				groupStart += groupCount; // update total number of vertices

				numberOfVertices += vertexCounter;
			}
		}

	}

	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		const dst = {};

		for (const u in src) {
			dst[u] = {};

			for (const p in src[u]) {
				const property = src[u][p];

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}
	function mergeUniforms(uniforms) {
		const merged = {};

		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u]);

			for (const p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	} // Legacy

	const UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	class ShaderMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShaderMaterial';
			this.defines = {};
			this.uniforms = {};
			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;
			this.linewidth = 1;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false; // set to use scene fog

			this.lights = false; // set to use scene lights

			this.clipping = false; // set to use user-defined clipping planes

			this.skinning = false; // set to use skinning attribute streams

			this.morphTargets = false; // set to use morph targets

			this.morphNormals = false; // set to use morph normals

			this.extensions = {
				derivatives: false,
				// set to use derivatives
				fragDepth: false,
				// set to use fragment depth values
				drawBuffers: false,
				// set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD

			}; // When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.

			this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			};
			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;
			this.glslVersion = null;

			if (parameters !== undefined) {
				if (parameters.attributes !== undefined) {
					console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
				}

				this.setValues(parameters);
			}
		}

		copy(source) {
			super.copy(source);
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
			this.uniforms = cloneUniforms(source.uniforms);
			this.defines = Object.assign({}, source.defines);
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.lights = source.lights;
			this.clipping = source.clipping;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			this.extensions = Object.assign({}, source.extensions);
			this.glslVersion = source.glslVersion;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for (const name in this.uniforms) {
				const uniform = this.uniforms[name];
				const value = uniform.value;

				if (value && value.isTexture) {
					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					};
				} else if (value && value.isColor) {
					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					};
				} else if (value && value.isVector2) {
					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					};
				} else if (value && value.isVector3) {
					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					};
				} else if (value && value.isVector4) {
					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					};
				} else if (value && value.isMatrix3) {
					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					};
				} else if (value && value.isMatrix4) {
					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					};
				} else {
					data.uniforms[name] = {
						value: value
					}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
				}
			}

			if (Object.keys(this.defines).length > 0) data.defines = this.defines;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
			const extensions = {};

			for (const key in this.extensions) {
				if (this.extensions[key] === true) extensions[key] = true;
			}

			if (Object.keys(extensions).length > 0) data.extensions = extensions;
			return data;
		}

	}

	ShaderMaterial.prototype.isShaderMaterial = true;

	class Camera extends Object3D {
		constructor() {
			super();
			this.type = 'Camera';
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		}

		getWorldDirection(target) {
			if (target === undefined) {
				console.warn('THREE.Camera: .getWorldDirection() target is now required');
				target = new Vector3();
			}

			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		updateWorldMatrix(updateParents, updateChildren) {
			super.updateWorldMatrix(updateParents, updateChildren);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Camera.prototype.isCamera = true;

	class PerspectiveCamera extends Camera {
		constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
			super();
			this.type = 'PerspectiveCamera';
			this.fov = fov;
			this.zoom = 1;
			this.near = near;
			this.far = far;
			this.focus = 10;
			this.aspect = aspect;
			this.view = null;
			this.filmGauge = 35; // width of the film (default in millimeters)

			this.filmOffset = 0; // horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		}
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */


		setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		}
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */


		getFocalLength() {
			const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		}

		getEffectiveFOV() {
			return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
		}

		getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		}

		getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */


		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const near = this.near;
			let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const view = this.view;

			if (this.view !== null && this.view.enabled) {
				const fullWidth = view.fullWidth,
							fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			const skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		}

	}

	PerspectiveCamera.prototype.isPerspectiveCamera = true;

	const fov = 90,
				aspect = 1;

	class CubeCamera extends Object3D {
		constructor(near, far, renderTarget) {
			super();
			this.type = 'CubeCamera';

			if (renderTarget.isWebGLCubeRenderTarget !== true) {
				console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
				return;
			}

			this.renderTarget = renderTarget;
			const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
			cameraPX.layers = this.layers;
			cameraPX.up.set(0, -1, 0);
			cameraPX.lookAt(new Vector3(1, 0, 0));
			this.add(cameraPX);
			const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
			cameraNX.layers = this.layers;
			cameraNX.up.set(0, -1, 0);
			cameraNX.lookAt(new Vector3(-1, 0, 0));
			this.add(cameraNX);
			const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
			cameraPY.layers = this.layers;
			cameraPY.up.set(0, 0, 1);
			cameraPY.lookAt(new Vector3(0, 1, 0));
			this.add(cameraPY);
			const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
			cameraNY.layers = this.layers;
			cameraNY.up.set(0, 0, -1);
			cameraNY.lookAt(new Vector3(0, -1, 0));
			this.add(cameraNY);
			const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraPZ.layers = this.layers;
			cameraPZ.up.set(0, -1, 0);
			cameraPZ.lookAt(new Vector3(0, 0, 1));
			this.add(cameraPZ);
			const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraNZ.layers = this.layers;
			cameraNZ.up.set(0, -1, 0);
			cameraNZ.lookAt(new Vector3(0, 0, -1));
			this.add(cameraNZ);
		}

		update(renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			const renderTarget = this.renderTarget;
			const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
			const currentXrEnabled = renderer.xr.enabled;
			const currentRenderTarget = renderer.getRenderTarget();
			renderer.xr.enabled = false;
			const generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.xr.enabled = currentXrEnabled;
		}

	}

	class CubeTexture extends Texture {
		constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			format = format !== undefined ? format : RGBFormat;
			super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding); // Why CubeTexture._needsFlipEnvMap is necessary:
			//
			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
			// when using WebGLCubeRenderTarget.texture as a cube texture.

			this._needsFlipEnvMap = true;
			this.flipY = false;
		}

		get images() {
			return this.image;
		}

		set images(value) {
			this.image = value;
		}

	}

	CubeTexture.prototype.isCubeTexture = true;

	class WebGLCubeRenderTarget extends WebGLRenderTarget {
		constructor(size, options, dummy) {
			if (Number.isInteger(options)) {
				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
				options = dummy;
			}

			super(size, size, options);
			options = options || {};
			this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.texture._needsFlipEnvMap = false;
		}

		fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859

			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			const shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader:
				/* glsl */
				`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader:
				/* glsl */
				`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};
			const geometry = new BoxGeometry(5, 5, 5);
			const material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			const mesh = new Mesh(geometry, material);
			const currentMinFilter = texture.minFilter; // Avoid blurred poles

			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			const camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		}

		clear(renderer, color, depth, stencil) {
			const currentRenderTarget = renderer.getRenderTarget();

			for (let i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(currentRenderTarget);
		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	class DataTexture extends Texture {
		constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				data: data || null,
				width: width || 1,
				height: height || 1
			};
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture.prototype.isDataTexture = true;

	const _sphere$2 = /*@__PURE__*/new Sphere();

	const _vector$7 = /*@__PURE__*/new Vector3();

	class Frustum {
		constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
			this.planes = [p0, p1, p2, p3, p4, p5];
		}

		set(p0, p1, p2, p3, p4, p5) {
			const planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		}

		copy(frustum) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		}

		setFromProjectionMatrix(m) {
			const planes = this.planes;
			const me = m.elements;
			const me0 = me[0],
						me1 = me[1],
						me2 = me[2],
						me3 = me[3];
			const me4 = me[4],
						me5 = me[5],
						me6 = me[6],
						me7 = me[7];
			const me8 = me[8],
						me9 = me[9],
						me10 = me[10],
						me11 = me[11];
			const me12 = me[12],
						me13 = me[13],
						me14 = me[14],
						me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		}

		intersectsObject(object) {
			const geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSprite(sprite) {
			_sphere$2.center.set(0, 0, 0);

			_sphere$2.radius = 0.7071067811865476;

			_sphere$2.applyMatrix4(sprite.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSphere(sphere) {
			const planes = this.planes;
			const center = sphere.center;
			const negRadius = -sphere.radius;

			for (let i = 0; i < 6; i++) {
				const distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		}

		intersectsBox(box) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				const plane = planes[i]; // corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if (plane.distanceToPoint(_vector$7) < 0) {
					return false;
				}
			}

			return true;
		}

		containsPoint(point) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	function WebGLAnimation() {
		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}

		return {
			start: function () {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function () {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function (callback) {
				animationLoop = callback;
			},
			setContext: function (value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		const buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			const array = attribute.array;
			const usage = attribute.usage;
			const buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			let type = gl.FLOAT;

			if (array instanceof Float32Array) {
				type = gl.FLOAT;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = gl.HALF_FLOAT;
					} else {
						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = gl.UNSIGNED_SHORT;
				}
			} else if (array instanceof Int16Array) {
				type = gl.SHORT;
			} else if (array instanceof Uint32Array) {
				type = gl.UNSIGNED_INT;
			} else if (array instanceof Int32Array) {
				type = gl.INT;
			} else if (array instanceof Int8Array) {
				type = gl.BYTE;
			} else if (array instanceof Uint8Array) {
				type = gl.UNSIGNED_BYTE;
			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			const array = attribute.array;
			const updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);

			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}

				updateRange.count = -1; // reset range
			}
		} //


		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				const cached = buffers.get(attribute);

				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}

				return;
			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}

		return {
			get: get,
			remove: remove,
			update: update
		};
	}

	class PlaneGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
			super();
			this.type = 'PlaneGeometry';
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			const width_half = width / 2;
			const height_half = height / 2;
			const gridX = Math.floor(widthSegments);
			const gridY = Math.floor(heightSegments);
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			const segment_width = width / gridX;
			const segment_height = height / gridY; //

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segment_height - height_half;

				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
				}
			}

			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * (iy + 1);
					const c = ix + 1 + gridX1 * (iy + 1);
					const d = ix + 1 + gridX1 * iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

	var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmissionmap_fragment: transmissionmap_fragment,
		transmissionmap_pars_fragment: transmissionmap_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {
		common: {
			diffuse: {
				value: new Color(0xeeeeee)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			},
			uv2Transform: {
				value: new Matrix3()
			},
			alphaMap: {
				value: null
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			},
			refractionRatio: {
				value: 0.98
			},
			maxMipLevel: {
				value: 0
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(0xeeeeee)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: new Color(0xeeeeee)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		}
	};

	const ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				specular: {
					value: new Color(0x111111)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				roughness: {
					value: 1.0
				},
				metalness: {
					value: 0.0
				},
				envMapIntensity: {
					value: 1
				} // temporary

			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3()
				},
				t2D: {
					value: null
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
		cube: {
			uniforms: mergeUniforms([UniformsLib.envmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3()
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1000
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0x00000)
				},
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new Vector2(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			sheen: {
				value: new Color(0x000000)
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};

	function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
		const clearColor = new Color(0x000000);
		let clearAlpha = 0;
		let planeMesh;
		let boxMesh;
		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render(renderList, scene, camera, forceClear) {
			let background = scene.isScene === true ? scene.background : null;

			if (background && background.isTexture) {
				background = cubemaps.get(background);
			} // Ignore background in AR
			// TODO: Reconsider this.


			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}

			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms(ShaderLib.cube.uniforms),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					}; // enable code injection for non-built-in material


					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function () {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms(ShaderLib.background.uniforms),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

					Object.defineProperty(planeMesh.material, 'map', {
						get: function () {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {
			getClearColor: function () {
				return clearColor;
			},
			setClearColor: function (color, alpha = 1) {
				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function () {
				return clearAlpha;
			},
			setClearAlpha: function (alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;
		const bindingStates = {};
		const defaultState = createBindingState(null);
		let currentState = defaultState;

		function setup(object, material, program, geometry, index) {
			let updateBuffers = false;

			if (vaoAvailable) {
				const state = getBindingState(geometry, program, material);

				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}

				updateBuffers = needsUpdate(geometry, index);
				if (updateBuffers) saveCache(geometry, index);
			} else {
				const wireframe = material.wireframe === true;

				if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}

			if (object.isInstancedMesh === true) {
				updateBuffers = true;
			}

			if (index !== null) {
				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}

			if (updateBuffers) {
				setupVertexAttributes(object, material, program, geometry);

				if (index !== null) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			const wireframe = material.wireframe === true;
			let programMap = bindingStates[geometry.id];

			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}

			let stateMap = programMap[program.id];

			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}

			let state = stateMap[wireframe];

			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}

			return state;
		}

		function createBindingState(vao) {
			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for (let i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}

			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(geometry, index) {
			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in geometryAttributes) {
				const cachedAttribute = cachedAttributes[key];
				const geometryAttribute = geometryAttributes[key];
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}

			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(geometry, index) {
			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in attributes) {
				const attribute = attributes[key];
				const data = {};
				data.attribute = attribute;

				if (attribute.data) {
					data.data = attribute.data;
				}

				cache[key] = data;
				attributesNum++;
			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			const newAttributes = currentState.newAttributes;

			for (let i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for (let i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}

			initAttributes();
			const geometryAttributes = geometry.attributes;
			const programAttributes = program.getAttributes();
			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];

				if (programAttribute >= 0) {
					const geometryAttribute = geometryAttributes[name];

					if (geometryAttribute !== undefined) {
						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;
						const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if (data && data.isInstancedInterleavedBuffer) {
								enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
						}
					} else if (name === 'instanceMatrix') {
						const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						enableAttributeAndDivisor(programAttribute + 0, 1);
						enableAttributeAndDivisor(programAttribute + 1, 1);
						enableAttributeAndDivisor(programAttribute + 2, 1);
						enableAttributeAndDivisor(programAttribute + 3, 1);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
						gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
						gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
						gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
					} else if (name === 'instanceColor') {
						const attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						enableAttributeAndDivisor(programAttribute, 1);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
					} else if (materialDefaultAttributeValues !== undefined) {
						const value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute, value);
									break;

								case 3:
									gl.vertexAttrib3fv(programAttribute, value);
									break;

								case 4:
									gl.vertexAttrib4fv(programAttribute, value);
									break;

								default:
									gl.vertexAttrib1fv(programAttribute, value);
							}
						}
					}
				}
			}

			disableUnusedAttributes();
		}

		function dispose() {
			reset();

			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];

				for (const programId in programMap) {
					const stateMap = programMap[programId];

					for (const wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}

					delete programMap[programId];
				}

				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			const programMap = bindingStates[geometry.id];

			for (const programId in programMap) {
				const stateMap = programMap[programId];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[programId];
			}

			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				const stateMap = programMap[program.id];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		} // for backward-compatilibity


		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}

		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		let maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}
		/* eslint-disable no-undef */


		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
		const floatVertexTextures = vertexTextures && floatFragmentTextures;
		const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
		return {
			isWebGL2: isWebGL2,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		const scope = this;
		let globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false;
		const plane = new Plane(),
					viewNormalMatrix = new Matrix3(),
					uniform = {
			value: null,
			needsUpdate: false
		};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 || localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;
			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (material, camera, useCache) {
			const planes = material.clippingPlanes,
						clipIntersection = material.clipIntersection,
						clipShadows = material.clipShadows;
			const materialProperties = properties.get(material);

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
							lGlobal = nGlobal * 4;
				let dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache);

				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4,
								viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		let cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}

			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture) {
				const mapping = texture.mapping;

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						const cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						const image = texture.image;

						if (image && image.height > 0) {
							const currentRenderTarget = renderer.getRenderTarget();
							const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemap = cubemaps.get(texture);

			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		const extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}

			let extension;

			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
			}

			extensions[name] = extension;
			return extension;
		}

		return {
			has: function (name) {
				return getExtension(name) !== null;
			},
			init: function (capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}

				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
			},
			get: function (name) {
				const extension = getExtension(name);

				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}

				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			const geometry = event.target;

			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}

			for (const name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			const attribute = wireframeAttributes.get(geometry);

			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}

			bindingStates.releaseStatesOfGeometry(geometry);

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			} //


			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

			for (const name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			} // morph targets


			const morphAttributes = geometry.morphAttributes;

			for (const name in morphAttributes) {
				const array = morphAttributes[name];

				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			const indices = [];
			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if (geometryIndex !== null) {
				const array = geometryIndex.array;
				version = geometryIndex.version;

				for (let i = 0, l = array.length; i < l; i += 3) {
					const a = array[i + 0];
					const b = array[i + 1];
					const c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				const array = geometryPosition.array;
				version = geometryPosition.version;

				for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
					const a = i + 0;
					const b = i + 1;
					const c = i + 2;
					indices.push(a, b, b, c, c, a);
				}
			}

			const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
			//

			const previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute); //

			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			const currentAttribute = wireframeAttributes.get(geometry);

			if (currentAttribute) {
				const geometryIndex = geometry.index;

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}

			return wireframeAttributes.get(geometry);
		}

		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		let type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		const memory = {
			geometries: 0,
			textures: 0
		};
		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;

			switch (mode) {
				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3);
					break;

				case gl.LINES:
					render.lines += instanceCount * (count / 2);
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function WebGLMorphtargets(gl) {
		const influencesList = {};
		const morphInfluences = new Float32Array(8);
		const workInfluences = [];

		for (let i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, material, program) {
			const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;
			let influences = influencesList[geometry.id];

			if (influences === undefined) {
				// initialise list
				influences = [];

				for (let i = 0; i < length; i++) {
					influences[i] = [i, 0];
				}

				influencesList[geometry.id] = influences;
			} // Collect influences


			for (let i = 0; i < length; i++) {
				const influence = influences[i];
				influence[0] = i;
				influence[1] = objectInfluences[i];
			}

			influences.sort(absNumericalSort);

			for (let i = 0; i < 8; i++) {
				if (i < length && influences[i][1]) {
					workInfluences[i][0] = influences[i][0];
					workInfluences[i][1] = influences[i][1];
				} else {
					workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
					workInfluences[i][1] = 0;
				}
			}

			workInfluences.sort(numericalSort);
			const morphTargets = material.morphTargets && geometry.morphAttributes.position;
			const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
			let morphInfluencesSum = 0;

			for (let i = 0; i < 8; i++) {
				const influence = workInfluences[i];
				const index = influence[0];
				const value = influence[1];

				if (index !== Number.MAX_SAFE_INTEGER && value) {
					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
						geometry.setAttribute('morphTarget' + i, morphTargets[index]);
					}

					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
						geometry.setAttribute('morphNormal' + i, morphNormals[index]);
					}

					morphInfluences[i] = value;
					morphInfluencesSum += value;
				} else {
					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
						geometry.deleteAttribute('morphTarget' + i);
					}

					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
						geometry.deleteAttribute('morphNormal' + i);
					}

					morphInfluences[i] = 0;
				}
			} // GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}

		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		let updateMap = new WeakMap();

		function update(object) {
			const frame = info.render.frame;
			const geometry = object.geometry;
			const buffergeometry = geometries.get(object, geometry); // Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}

			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}

				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);

				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				}
			}

			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			const instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}

		return {
			update: update,
			dispose: dispose
		};
	}

	class DataTexture2DArray extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	class DataTexture3D extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	const emptyTexture = new Texture();
	const emptyTexture2dArray = new DataTexture2DArray();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array(16);
	const mat3array = new Float32Array(9);
	const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		const firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	} // Texture unit allocation


	function allocTexUnits(textures, n) {
		let r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (let i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}

		return r;
	} // --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar


	function setValueV1f(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	} // Single float vector (from flat array or THREE.VectorN)


	function setValueV2f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	} // Single matrix (from flat array or THREE.MatrixN)


	function setValueM2(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	} // Single integer / boolean


	function setValueV1i(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	} // Single integer / boolean vector (from flat array)


	function setValueV2i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	} // Single unsigned integer


	function setValueV1ui(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	} // Single unsigned integer vector (from flat array)


	function setValueV2ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	} // Single texture (2D / Cube)


	function setValueT1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	} // Helper to pick the right setter for the singular case


	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f;
			// FLOAT

			case 0x8b50:
				return setValueV2f;
			// _VEC2

			case 0x8b51:
				return setValueV3f;
			// _VEC3

			case 0x8b52:
				return setValueV4f;
			// _VEC4

			case 0x8b5a:
				return setValueM2;
			// _MAT2

			case 0x8b5b:
				return setValueM3;
			// _MAT3

			case 0x8b5c:
				return setValueM4;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2i;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3i;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4i;
			// _VEC4

			case 0x1405:
				return setValueV1ui;
			// UINT

			case 0x8dc6:
				return setValueV2ui;
			// _VEC2

			case 0x8dc7:
				return setValueV3ui;
			// _VEC3

			case 0x8dc8:
				return setValueV4ui;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	} // Array of scalars


	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	} // Array of vectors (from flat array or array of THREE.VectorN)


	function setValueV2fArray(gl, v) {
		const data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		const data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	} // Array of matrices (from flat array or array of THREE.MatrixN)


	function setValueM2Array(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		const data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		const data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	} // Array of integer / boolean


	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	} // Array of integer / boolean vectors (from flat array)


	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	} // Array of unsigned integer


	function setValueV1uiArray(gl, v) {
		gl.uniform1uiv(this.addr, v);
	} // Array of unsigned integer vectors (from flat array)


	function setValueV2uiArray(gl, v) {
		gl.uniform2uiv(this.addr, v);
	}

	function setValueV3uiArray(gl, v) {
		gl.uniform3uiv(this.addr, v);
	}

	function setValueV4uiArray(gl, v) {
		gl.uniform4uiv(this.addr, v);
	} // Array of textures (2D / Cube)


	function setValueT1Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	} // Helper to pick the right setter for a pure (bottom-level) array


	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray;
			// FLOAT

			case 0x8b50:
				return setValueV2fArray;
			// _VEC2

			case 0x8b51:
				return setValueV3fArray;
			// _VEC3

			case 0x8b52:
				return setValueV4fArray;
			// _VEC4

			case 0x8b5a:
				return setValueM2Array;
			// _MAT2

			case 0x8b5b:
				return setValueM3Array;
			// _MAT3

			case 0x8b5c:
				return setValueM4Array;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray;
			// _VEC4

			case 0x1405:
				return setValueV1uiArray;
			// UINT

			case 0x8dc6:
				return setValueV2uiArray;
			// _VEC2

			case 0x8dc7:
				return setValueV3uiArray;
			// _VEC3

			case 0x8dc8:
				return setValueV4uiArray;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6Array;
		}
	} // --- Uniform Classes ---


	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		const cache = this.cache;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		const seq = this.seq;

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}; // --- Top-level ---
	// Parser - builds up the property tree from the path strings


	const RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
	// 	- the identifier (member name or array index)
	//	- followed by an optional right bracket (found when array index)
	//	- followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		const path = activeInfo.name,
					pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

		RePathPart.lastIndex = 0;

		while (true) {
			const match = RePathPart.exec(path),
						matchEnd = RePathPart.lastIndex;
			let id = match[1];
			const idIsIndex = match[2] === ']',
						subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				const map = container.map;
				let next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	} // Root Container


	function WebGLUniforms(gl, program) {
		this.seq = [];
		this.map = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
						addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		const u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		const v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}; // Static interface


	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
						v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		const r = [];

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	function WebGLShader(gl, type, string) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}

	let programIdCount = 0;

	function addLineNumbers(string) {
		const lines = string.split('\n');

		for (let i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i];
		}

		return lines.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];

			case sRGBEncoding:
				return ['sRGB', '( value )'];

			case RGBEEncoding:
				return ['RGBE', '( value )'];

			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )'];

			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )'];

			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )'];

			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

			case LogLuvEncoding:
				return ['LogLuv', '( value )'];

			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		const log = gl.getShaderInfoLog(shader).trim();
		if (status && log === '') return ''; // --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource(shader);
		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
	}

	function getTexelDecodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
	}

	function getTexelEncodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		let toneMappingName;

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		const chunks = [];

		for (const name in defines) {
			const value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		const attributes = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i);
			const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name);
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	} // Resolve Includes


	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		const string = ShaderChunk[include];

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}

		return resolveIncludes(string);
	} // Unroll Loops


	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
	}

	function deprecatedLoopReplacer(match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
		return loopReplacer(match, start, end, snippet);
	}

	function loopReplacer(match, start, end, snippet) {
		let string = '';

		for (let i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
		}

		return string;
	} //


	function generatePrecision(parameters) {
		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}

		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}

		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}

		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}

		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}

		return envMapBlendingDefine;
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		const gl = renderer.getContext();
		const defines = parameters.defines;
		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;
		const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		const envMapModeDefine = generateEnvMapModeDefine(parameters);
		const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		const customDefines = generateDefines(defines);
		const program = gl.createProgram();
		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
			prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
			'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
		}

		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
			prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
		const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program); // check for link errors

		if (renderer.debug.checkShaderErrors) {
			const programLog = gl.getProgramInfoLog(program).trim();
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			let runnable = true;
			let haveDiagnostics = true;

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		} // Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );


		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader); // set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}

			return cachedUniforms;
		}; // set up caching for attribute locations


		let cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		}; // free resource


		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		}; //


		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}

	function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
		const programs = [];
		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;
		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
		const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmissionMap'];

		function getMaxBones(object) {
			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if (floatVertexTextures) {
				return 1024;
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//	- leave some extra space for other uniforms
				//	- limit here is ANGLE's 254 max uniform vectors
				//		(up to 54 should be safe)
				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
				const maxBones = Math.min(nVertexMatrices, bones.length);

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
					return 0;
				}

				return maxBones;
			}
		}

		function getTextureEncodingFromMap(map) {
			let encoding;

			if (map && map.isTexture) {
				encoding = map.encoding;
			} else if (map && map.isWebGLRenderTarget) {
				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
				encoding = map.texture.encoding;
			} else {
				encoding = LinearEncoding;
			}

			return encoding;
		}

		function getParameters(material, lights, shadows, scene, object) {
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const envMap = cubemaps.get(material.envMap || environment);
			const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			let vertexShader, fragmentShader;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
			}

			const currentRenderTarget = renderer.getRenderTarget();
			const parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !!material.clearcoatMap,
				clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				alphaMap: !!material.alphaMap,
				gradientMap: !!material.gradientMap,
				sheen: !!material.sheen,
				transmissionMap: !!material.transmissionMap,
				combine: material.combine,
				vertexTangents: material.normalMap && material.vertexTangents,
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: !!material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
				premultipliedAlpha: material.premultipliedAlpha,
				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			const array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(parameters.fragmentShader);
				array.push(parameters.vertexShader);
			}

			if (parameters.defines !== undefined) {
				for (const name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (let i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]]);
				}

				array.push(renderer.outputEncoding);
				array.push(renderer.gammaFactor);
			}

			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getUniforms(material) {
			const shaderID = shaderIDs[material.type];
			let uniforms;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}

			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			let program; // Check if code has been already compiled

			for (let p = 0, pl = programs.length; p < pl; p++) {
				const preexistingProgram = programs[p];

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}

			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop(); // Free WebGL resources

				program.destroy();
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};
	}

	function WebGLProperties() {
		let properties = new WeakMap();

		function get(object) {
			let map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.program !== b.program) {
			return a.program.id - b.program.id;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList(properties) {
		const renderItems = [];
		let renderItemsIndex = 0;
		const opaque = [];
		const transparent = [];
		const defaultProgram = {
			id: -1
		};

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			let renderItem = renderItems[renderItemsIndex];
			const materialProperties = properties.get(material);

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			(material.transparent === true ? transparent : opaque).push(renderItem);
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			(material.transparent === true ? transparent : opaque).unshift(renderItem);
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				const renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;
			}
		}

		return {
			opaque: opaque,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists(properties) {
		let lists = new WeakMap();

		function get(scene, renderCallDepth) {
			let list;

			if (lists.has(scene) === false) {
				list = new WebGLRenderList(properties);
				lists.set(scene, [list]);
			} else {
				if (renderCallDepth >= lists.get(scene).length) {
					list = new WebGLRenderList(properties);
					lists.get(scene).push(list);
				} else {
					list = lists.get(scene)[renderCallDepth];
				}
			}

			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	let nextVersion = 0;

	function shadowCastingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		const cache = new UniformsCache();
		const shadowCache = ShadowUniformsCache();
		const state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};

		for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup(lights) {
			let r = 0,
					g = 0,
					b = 0;

			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			lights.sort(shadowCastingLightsFirst);

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];
				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;
				const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
				} else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}

					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = cache.get(light);
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.distance = distance;
					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.spotShadow[spotLength] = shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						state.spotShadowMatrix[spotLength] = light.shadow.matrix;
						numSpotShadows++;
					}

					state.spot[spotLength] = uniforms;
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
					// (b) intensity is the brightness of the light

					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					state.rectArea[rectAreaLength] = uniforms;
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;
						state.pointShadow[pointLength] = shadowUniforms;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}

					state.point[pointLength] = uniforms;
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = cache.get(light);
					uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
					state.hemi[hemiLength] = uniforms;
					hemiLength++;
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			const hash = state.hash;

			if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			const viewMatrix = camera.matrixWorldInverse;

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];

				if (light.isDirectionalLight) {
					const uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = state.spot[spotLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = state.rectArea[rectAreaLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					uniforms.halfWidth.applyMatrix4(matrix42);
					uniforms.halfHeight.applyMatrix4(matrix42);
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = state.point[pointLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = state.hemi[hemiLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					uniforms.direction.normalize();
					hemiLength++;
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		const lights = new WebGLLights(extensions, capabilities);
		const lightsArray = [];
		const shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights() {
			lights.setup(lightsArray);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		let renderStates = new WeakMap();

		function get(scene, renderCallDepth = 0) {
			let renderState;

			if (renderStates.has(scene) === false) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, [renderState]);
			} else {
				if (renderCallDepth >= renderStates.get(scene).length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStates.get(scene).push(renderState);
				} else {
					renderState = renderStates.get(scene)[renderCallDepth];
				}
			}

			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	/**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */

	class MeshDepthMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDepthMaterial';
			this.depthPacking = BasicDepthPacking;
			this.skinning = false;
			this.morphTargets = false;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.depthPacking = source.depthPacking;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			return this;
		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */

	class MeshDistanceMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDistanceMaterial';
			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;
			this.skinning = false;
			this.morphTargets = false;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.referencePosition.copy(source.referencePosition);
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			return this;
		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	function WebGLShadowMap(_renderer, _objects, _capabilities) {
		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
					_viewportSize = new Vector2(),
					_viewport = new Vector4(),
					_depthMaterials = [],
					_distanceMaterials = [],
					_materialCache = {},
					_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = {
			0: BackSide,
			1: FrontSide,
			2: DoubleSide
		};
		const shadowMaterialVertical = new ShaderMaterial({
			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				}
			},
			vertexShader: vsm_vert,
			fragmentShader: vsm_frag
		});
		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		const scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;

			const currentRenderTarget = _renderer.getRenderTarget();

			const activeCubeFace = _renderer.getActiveCubeFace();

			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state; // Set GL state for depth map.

			_state.setBlending(NoBlending);

			_state.buffers.color.setClear(1, 1, 1, 1);

			_state.buffers.depth.setTest(true);

			_state.setScissorTest(false); // render depth map


			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i];
				const shadow = light.shadow;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

				_shadowMapSize.copy(shadow.mapSize);

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply(shadowFrameExtents);

				_viewportSize.copy(shadow.mapSize);

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}

					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					const pars = {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.camera.updateProjectionMatrix();
				}

				if (shadow.map === null) {
					const pars = {
						minFilter: NearestFilter,
						magFilter: NearestFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}

				_renderer.setRenderTarget(shadow.map);

				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for (let vp = 0; vp < viewportCount; vp++) {
					const viewport = shadow.getViewport(vp);

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

					_state.viewport(_viewport);

					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				} // do blur pass for VSM


				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}

				shadow.needsUpdate = false;
			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			const geometry = _objects.update(fullScreenMesh); // vertical pass


			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.mapPass);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.map);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
			const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
			let material = _depthMaterials[index];

			if (material === undefined) {
				material = new MeshDepthMaterial({
					depthPacking: RGBADepthPacking,
					morphTargets: useMorphing,
					skinning: useSkinning
				});
				_depthMaterials[index] = material;
			}

			return material;
		}

		function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
			const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
			let material = _distanceMaterials[index];

			if (material === undefined) {
				material = new MeshDistanceMaterial({
					morphTargets: useMorphing,
					skinning: useSkinning
				});
				_distanceMaterials[index] = material;
			}

			return material;
		}

		function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			let result = null;
			let getMaterialVariant = getDepthMaterialVariant;
			let customMaterial = object.customDepthMaterial;

			if (light.isPointLight === true) {
				getMaterialVariant = getDistanceMaterialVariant;
				customMaterial = object.customDistanceMaterial;
			}

			if (customMaterial === undefined) {
				let useMorphing = false;

				if (material.morphTargets === true) {
					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
				}

				let useSkinning = false;

				if (object.isSkinnedMesh === true) {
					if (material.skinning === true) {
						useSkinning = true;
					} else {
						console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
					}
				}

				const useInstancing = object.isInstancedMesh === true;
				result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
			} else {
				result = customMaterial;
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state
				const keyA = result.uuid,
							keyB = material.uuid;
				let materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				let cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side;
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					const geometry = _objects.update(object);

					const material = object.material;

					if (Array.isArray(material)) {
						const groups = geometry.groups;

						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k];
							const groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			let locked = false;
			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function (colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function () {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			let locked = false;
			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;
			return {
				setTest: function (depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST);
					} else {
						disable(gl.DEPTH_TEST);
					}
				},
				setMask: function (depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function (depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(gl.NEVER);
									break;

								case AlwaysDepth:
									gl.depthFunc(gl.ALWAYS);
									break;

								case LessDepth:
									gl.depthFunc(gl.LESS);
									break;

								case LessEqualDepth:
									gl.depthFunc(gl.LEQUAL);
									break;

								case EqualDepth:
									gl.depthFunc(gl.EQUAL);
									break;

								case GreaterEqualDepth:
									gl.depthFunc(gl.GEQUAL);
									break;

								case GreaterDepth:
									gl.depthFunc(gl.GREATER);
									break;

								case NotEqualDepth:
									gl.depthFunc(gl.NOTEQUAL);
									break;

								default:
									gl.depthFunc(gl.LEQUAL);
							}
						} else {
							gl.depthFunc(gl.LEQUAL);
						}

						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function () {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			let locked = false;
			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;
			return {
				setTest: function (stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST);
						} else {
							disable(gl.STENCIL_TEST);
						}
					}
				},
				setMask: function (stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function (stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function (stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function () {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		} //


		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();
		let enabledCapabilities = {};
		let xrFramebuffer = null;
		let currentBoundFramebuffers = {};
		let currentProgram = null;
		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;
		let currentFlipSided = null;
		let currentCullFace = null;
		let currentLineWidth = null;
		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;
		const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter(gl.VERSION);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 2.0;
		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};
		const currentScissor = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
		const currentViewport = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);

		function createTexture(type, target, count) {
			const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

			const texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
			}

			return texture;
		}

		const emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(gl.CULL_FACE);
		setBlending(NoBlending); //

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function bindXRFramebuffer(framebuffer) {
			if (framebuffer !== xrFramebuffer) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				xrFramebuffer = framebuffer;
			}
		}

		function bindFramebuffer(target, framebuffer) {
			if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available

			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer);
				currentBoundFramebuffers[target] = framebuffer;

				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
					}

					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
					}
				}
			}
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}

			return false;
		}

		const equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		};

		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN;
			equationToGL[MaxEquation] = gl.MAX;
		} else {
			const extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}

		const factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (currentBlendingEnabled === false) {
				enable(gl.BLEND);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
								break;

							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			} // custom blending


			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
			let flipSided = material.side === BackSide;
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);

			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
			material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		} //


		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW);
				} else {
					gl.frontFace(gl.CCW);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT);
					} else {
						gl.cullFace(gl.FRONT_AND_BACK);
					}
				}
			} else {
				disable(gl.CULL_FACE);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST);
			} else {
				disable(gl.SCISSOR_TEST);
			}
		} // texture


		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			let boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			const boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		} //


		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		} //


		function reset() {
			// reset state
			gl.disable(gl.BLEND);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.POLYGON_OFFSET_FILL);
			gl.disable(gl.SCISSOR_TEST);
			gl.disable(gl.STENCIL_TEST);
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
			gl.colorMask(true, true, true, true);
			gl.clearColor(0, 0, 0, 0);
			gl.depthMask(true);
			gl.depthFunc(gl.LESS);
			gl.clearDepth(1);
			gl.stencilMask(0xffffffff);
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.clearStencil(0);
			gl.cullFace(gl.BACK);
			gl.frontFace(gl.CCW);
			gl.polygonOffset(0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			}

			gl.useProgram(null);
			gl.lineWidth(1);
			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			xrFramebuffer = null;
			currentBoundFramebuffers = {};
			currentProgram = null;
			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;

		const _videoTextures = new WeakMap();

		let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


		let useOffscreenCanvas = false;

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
		} catch (err) {// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			let scale = 1; // handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			} // only perform resize if necessary


			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
					const width = floor(scale * image.width);
					const height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					const context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}

					return image;
				}
			}

			return image;
		}

		function isPowerOfTwo$1(image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target, texture, width, height) {
			_gl.generateMipmap(target);

			const textureProperties = properties.get(texture);
			textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
		}

		function getInternalFormat(internalFormatName, glFormat, glType) {
			if (isWebGL2 === false) return glFormat;

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}

			let internalFormat = glFormat;

			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
			}

			if (glFormat === _gl.RGB) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
			}

			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
			}

			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float');
			}

			return internalFormat;
		} // Fallback filters for non-power-of-2 textures


		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST;
			}

			return _gl.LINEAR;
		} //


		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			const renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
			info.memory.textures--;
		} //


		function deallocateTexture(texture) {
			const textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;

			_gl.deleteTexture(textureProperties.__webglTexture);

			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}

			properties.remove(texture);
			properties.remove(renderTarget);
		} //


		let textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			const textureUnit = textureUnits;

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}

			textureUnits += 1;
			return textureUnit;
		} //


		function setTexture2D(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				const image = texture.image;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
		}

		function setTexture2DArray(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
		}

		function setTextureCube(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
		}

		const wrappingToGL = {
			[RepeatWrapping]: _gl.REPEAT,
			[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
		};
		const filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: _gl.LINEAR,
			[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

				if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
				textureProperties.__webglTexture = _gl.createTexture();
				info.memory.textures++;
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			let textureType = _gl.TEXTURE_2D;
			if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
			if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(textureType, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format);
			let glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmap;
			const mipmaps = texture.mipmaps;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data
				glInternalFormat = _gl.DEPTH_COMPONENT;

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				} // validation checks for WebGL 1


				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				} //


				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					textureProperties.__maxMipLevel = 0;
				}
			} else if (texture.isCompressedTexture) {
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else if (texture.isDataTexture3D) {
				state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else {
				// regular Texture (image, video, canvas)
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					textureProperties.__maxMipLevel = 0;
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			const cubeImage = [];

			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
			}

			const image = cubeImage[0],
						supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format),
						glType = utils.convert(texture.type),
						glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			let mipmaps;

			if (isCompressed) {
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;

					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {
				mipmaps = texture.mipmaps;

				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							const mipmapImage = mipmap.image[i].image;
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
						}
					} else {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length;
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		} // Render targets
		// Setup storage for target texture and bind it to correct framebuffer


		function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
			const texture = renderTarget.texture;
			const glFormat = utils.convert(texture.format);
			const glType = utils.convert(texture.type);
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if (isMultisample) {
					const depthTexture = renderTarget.depthTexture;

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						}
					}

					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else {
				const texture = renderTarget.texture;
				const glFormat = utils.convert(texture.format);
				const glType = utils.convert(texture.type);
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
		} // Setup resources for a Depth Texture for a FBO (needs an extension)


		function setupDepthTexture(framebuffer, renderTarget) {
			const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			} // upload an empty depth texture with framebuffer size


			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else {
				throw new Error('Unknown depthTexture format');
			}
		} // Setup GL resources for a non-texture depth buffer


		function setupDepthRenderbuffer(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];

					for (let i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Set up GL resources for the render target


		function setupRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);
			textureProperties.__webglTexture = _gl.createTexture();
			textureProperties.__version = texture.version;
			info.memory.textures++;
			const isCube = renderTarget.isWebGLCubeRenderTarget === true;
			const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
				texture.format = RGBAFormat;
				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
			} // Setup framebuffer


			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (let i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if (isMultisample) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						const glFormat = utils.convert(texture.format);
						const glType = utils.convert(texture.type);
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
						const samples = getRenderTargetSamples(renderTarget);

						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
					}
				}
			} // Setup color buffer


			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

				for (let i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
			} else {
				let glTextureType = _gl.TEXTURE_2D;

				if (isRenderTarget3D) {
					// Render targets containing layers, i.e: Texture 3D and 2d arrays
					if (isWebGL2) {
						const isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
					} else {
						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
					}
				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture);
				setTextureParameters(glTextureType, texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, glTextureType);

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(_gl.TEXTURE_2D, null);
			} // Setup depth and stencil buffers


			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			const texture = renderTarget.texture;
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

				const webglTexture = properties.get(texture).__webglTexture;

				state.bindTexture(target, webglTexture);
				generateMipmap(target, texture, renderTarget.width, renderTarget.height);
				state.bindTexture(target, null);
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if (renderTarget.isWebGLMultisampleRenderTarget) {
				if (isWebGL2) {
					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;
					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					const renderTargetProperties = properties.get(renderTarget);
					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
		}

		function updateVideoTexture(texture) {
			const frame = info.render.frame; // Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);

				texture.update();
			}
		} // backwards compatibility


		let warnedTexture2D = false;
		let warnedTextureCube = false;

		function safeSetTexture2D(texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
					warnedTexture2D = true;
				}

				texture = texture.texture;
			}

			setTexture2D(texture, slot);
		}

		function safeSetTextureCube(texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
					warnedTextureCube = true;
				}

				texture = texture.texture;
			}

			setTextureCube(texture, slot);
		} //


		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function convert(p) {
			let extension;
			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
			if (p === ByteType) return gl.BYTE;
			if (p === ShortType) return gl.SHORT;
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
			if (p === IntType) return gl.INT;
			if (p === UnsignedIntType) return gl.UNSIGNED_INT;
			if (p === FloatType) return gl.FLOAT;

			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT;
				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}

			if (p === AlphaFormat) return gl.ALPHA;
			if (p === RGBFormat) return gl.RGB;
			if (p === RGBAFormat) return gl.RGBA;
			if (p === LuminanceFormat) return gl.LUMINANCE;
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
			if (p === DepthFormat) return gl.DEPTH_COMPONENT;
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
			if (p === RedFormat) return gl.RED; // WebGL2 formats.

			if (p === RedIntegerFormat) return gl.RED_INTEGER;
			if (p === RGFormat) return gl.RG;
			if (p === RGIntegerFormat) return gl.RG_INTEGER;
			if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
				}
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8;
				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
		}

		return {
			convert: convert
		};
	}

	class ArrayCamera extends PerspectiveCamera {
		constructor(array = []) {
			super();
			this.cameras = array;
		}

	}

	ArrayCamera.prototype.isArrayCamera = true;

	class Group extends Object3D {
		constructor() {
			super();
			this.type = 'Group';
		}

	}

	Group.prototype.isGroup = true;

	const _moveEvent = {
		type: 'move'
	};

	class WebXRController {
		constructor() {
			this._targetRay = null;
			this._grip = null;
			this._hand = null;
		}

		getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}

			return this._hand;
		}

		getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();
			}

			return this._targetRay;
		}

		getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();
			}

			return this._grip;
		}

		dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}

			return this;
		}

		disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});

			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}

			if (this._grip !== null) {
				this._grip.visible = false;
			}

			if (this._hand !== null) {
				this._hand.visible = false;
			}

			return this;
		}

		update(inputSource, frame, referenceSpace) {
			let inputPose = null;
			let gripPose = null;
			let handPose = null;
			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix);
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy(inputPose.linearVelocity);
						} else {
							targetRay.hasLinearVelocity = false;
						}

						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy(inputPose.angularVelocity);
						} else {
							targetRay.hasAngularVelocity = false;
						}

						this.dispatchEvent(_moveEvent);
					}
				}

				if (hand && inputSource.hand) {
					handPose = true;

					for (const inputjoint of inputSource.hand.values()) {
						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace);

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[inputjoint.jointName] = joint; // ??

							hand.add(joint);
						}

						const joint = hand.joints[inputjoint.jointName];

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}

						joint.visible = jointPose !== null;
					} // Custom events
					// Check pinchz


					const indexTip = hand.joints['index-finger-tip'];
					const thumbTip = hand.joints['thumb-tip'];
					const distance = indexTip.position.distanceTo(thumbTip.position);
					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy(gripPose.linearVelocity);
							} else {
								grip.hasLinearVelocity = false;
							}

							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy(gripPose.angularVelocity);
							} else {
								grip.hasAngularVelocity = false;
							}
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null;
			}

			if (grip !== null) {
				grip.visible = gripPose !== null;
			}

			if (hand !== null) {
				hand.visible = handPose !== null;
			}

			return this;
		}

	}

	class WebXRManager extends EventDispatcher {
		constructor(renderer, gl) {
			super();
			const scope = this;
			const state = renderer.state;
			let session = null;
			let framebufferScaleFactor = 1.0;
			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			let pose = null;
			const controllers = [];
			const inputSourcesMap = new Map(); //

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable(1);
			cameraL.viewport = new Vector4();
			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable(2);
			cameraR.viewport = new Vector4();
			const cameras = [cameraL, cameraR];
			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable(1);
			cameraVR.layers.enable(2);
			let _currentDepthNear = null;
			let _currentDepthFar = null; //

			this.enabled = false;
			this.isPresenting = false;

			this.getController = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getTargetRaySpace();
			};

			this.getControllerGrip = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getGripSpace();
			};

			this.getHand = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getHandSpace();
			}; //


			function onSessionEvent(event) {
				const controller = inputSourcesMap.get(event.inputSource);

				if (controller) {
					controller.dispatchEvent({
						type: event.type,
						data: event.inputSource
					});
				}
			}

			function onSessionEnd() {
				inputSourcesMap.forEach(function (controller, inputSource) {
					controller.disconnect(inputSource);
				});
				inputSourcesMap.clear();
				_currentDepthNear = null;
				_currentDepthFar = null; // restore framebuffer/rendering state

				state.bindXRFramebuffer(null);
				renderer.setRenderTarget(renderer.getRenderTarget()); //

				animation.stop();
				scope.isPresenting = false;
				scope.dispatchEvent({
					type: 'sessionend'
				});
			}

			this.setFramebufferScaleFactor = function (value) {
				framebufferScaleFactor = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
				}
			};

			this.setReferenceSpaceType = function (value) {
				referenceSpaceType = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
				}
			};

			this.getReferenceSpace = function () {
				return referenceSpace;
			};

			this.getSession = function () {
				return session;
			};

			this.setSession = async function (value) {
				session = value;

				if (session !== null) {
					session.addEventListener('select', onSessionEvent);
					session.addEventListener('selectstart', onSessionEvent);
					session.addEventListener('selectend', onSessionEvent);
					session.addEventListener('squeeze', onSessionEvent);
					session.addEventListener('squeezestart', onSessionEvent);
					session.addEventListener('squeezeend', onSessionEvent);
					session.addEventListener('end', onSessionEnd);
					session.addEventListener('inputsourceschange', onInputSourcesChange);
					const attributes = gl.getContextAttributes();

					if (attributes.xrCompatible !== true) {
						await gl.makeXRCompatible();
					}

					const layerInit = {
						antialias: attributes.antialias,
						alpha: attributes.alpha,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					}; // eslint-disable-next-line no-undef

					const baseLayer = new XRWebGLLayer(session, gl, layerInit);
					session.updateRenderState({
						baseLayer: baseLayer
					});
					referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
					animation.setContext(session);
					animation.start();
					scope.isPresenting = true;
					scope.dispatchEvent({
						type: 'sessionstart'
					});
				}
			};

			function onInputSourcesChange(event) {
				const inputSources = session.inputSources; // Assign inputSources to available controllers

				for (let i = 0; i < controllers.length; i++) {
					inputSourcesMap.set(inputSources[i], controllers[i]);
				} // Notify disconnected


				for (let i = 0; i < event.removed.length; i++) {
					const inputSource = event.removed[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'disconnected',
							data: inputSource
						});
						inputSourcesMap.delete(inputSource);
					}
				} // Notify connected


				for (let i = 0; i < event.added.length; i++) {
					const inputSource = event.added[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'connected',
							data: inputSource
						});
					}
				}
			} //


			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();
			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */

			function setProjectionFromUnion(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				const ipd = cameraLPos.distanceTo(cameraRPos);
				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.

				const near = projL[14] / (projL[10] - 1);
				const far = projL[14] / (projL[10] + 1);
				const topFov = (projL[9] + 1) / projL[5];
				const bottomFov = (projL[9] - 1) / projL[5];
				const leftFov = (projL[8] - 1) / projL[0];
				const rightFov = (projR[8] + 1) / projR[0];
				const left = near * leftFov;
				const right = near * rightFov; // Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.

				const zOffset = ipd / (-leftFov + rightFov);
				const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
				camera.translateX(xOffset);
				camera.translateZ(zOffset);
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.

				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + (ipd - xOffset);
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
			}

			function updateCamera(camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix);
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			}

			this.getCamera = function (camera) {
				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320
					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					});
					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;
				}

				const parent = camera.parent;
				const cameras = cameraVR.cameras;
				updateCamera(cameraVR, parent);

				for (let i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				} // update camera and its children


				camera.matrixWorld.copy(cameraVR.matrixWorld);
				camera.matrix.copy(cameraVR.matrix);
				camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
				const children = camera.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true);
				} // update projection matrix for proper view frustum culling


				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR);
				} else {
					// assume single camera setup (AR)
					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
				}

				return cameraVR;
			}; // Animation Loop


			let onAnimationFrameCallback = null;

			function onAnimationFrame(time, frame) {
				pose = frame.getViewerPose(referenceSpace);

				if (pose !== null) {
					const views = pose.views;
					const baseLayer = session.renderState.baseLayer;
					state.bindXRFramebuffer(baseLayer.framebuffer);
					let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;
					}

					for (let i = 0; i < views.length; i++) {
						const view = views[i];
						const viewport = baseLayer.getViewport(view);
						const camera = cameras[i];
						camera.matrix.fromArray(view.transform.matrix);
						camera.projectionMatrix.fromArray(view.projectionMatrix);
						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix);
						}

						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera);
						}
					}
				} //


				const inputSources = session.inputSources;

				for (let i = 0; i < controllers.length; i++) {
					const controller = controllers[i];
					const inputSource = inputSources[i];
					controller.update(inputSource, frame, referenceSpace);
				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop(onAnimationFrame);

			this.setAnimationLoop = function (callback) {
				onAnimationFrameCallback = callback;
			};

			this.dispose = function () {};
		}

	}

	function WebGLMaterials(properties) {
		function refreshFogUniforms(uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color);

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsLambert(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material);
				} else {
					refreshUniformsStandard(uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDepth(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsNormal(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				const maxMipLevel = properties.get(envMap).__maxMipLevel;

				if (maxMipLevel !== undefined) {
					uniforms.maxMipLevel.value = maxMipLevel;
				}
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			} // uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map


			let uv2ScaleMap;

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material) {
			refreshUniformsStandard(uniforms, material);
			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.sheen) uniforms.sheen.value.copy(material.sheen);

			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
			}

			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
			}

			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate();
				}
			}

			uniforms.transmission.value = material.transmission;

			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function createCanvasElement() {
		const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters) {
		parameters = parameters || {};

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
					_context = parameters.context !== undefined ? parameters.context : null,
					_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
					_depth = parameters.depth !== undefined ? parameters.depth : true,
					_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
					_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
					_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
					_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
					_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
					_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let currentRenderList = null;
		let currentRenderState = null; // render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = []; // public properties

		this.domElement = _canvas; // Debug configuration container

		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}; // clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true; // scene graph

		this.sortObjects = true; // user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false; // physically based shading

		this.gammaFactor = 2.0; // for backwards compatibility

		this.outputEncoding = LinearEncoding; // physical lights

		this.physicallyCorrectLights = false; // tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0; // internal properties

		const _this = this;

		let _isContextLost = false; // internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;

		let _currentMaterialId = -1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();

		const _currentScissor = new Vector4();

		let _currentScissorTest = null; //

		let _width = _canvas.width;
		let _height = _canvas.height;
		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4(0, 0, _width, _height);

		const _scissor = new Vector4(0, 0, _width, _height);

		let _scissorTest = false; // frustum

		const _frustum = new Frustum(); // clipping


		let _clippingEnabled = false;
		let _localClippingEnabled = false; // camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		} // initialize


		let _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				const contextName = contextNames[i];

				const context = _canvas.getContext(contextName, contextAttributes);

				if (context !== null) return context;
			}

			return null;
		}

		try {
			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}; // event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			if (_gl === null) {
				const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}

				_gl = getContext(contextNames, contextAttributes);

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			} // Some experimental-webgl implementations do not have getShaderPrecisionFormat


			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;
		let background, morphtargets, bufferRenderer, indexedBufferRenderer;
		let utils, bindingStates;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(properties);
			renderLists = new WebGLRenderLists(properties);
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;
		}

		initGLContext(); // xr

		const xr = new WebXRManager(_this, _gl);
		this.xr = xr; // API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};

		this.getSize = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
				target = new Vector2();
			}

			return target.set(_width, _height);
		};

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
				target = new Vector2();
			}

			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
				target = new Vector4();
			}

			return target.copy(_currentViewport);
		};

		this.getViewport = function (target) {
			return target.copy(_viewport);
		};

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissor = function (target) {
			return target.copy(_scissor);
		};

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissorTest = function () {
			return _scissorTest;
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		this.setOpaqueSort = function (method) {
			_opaqueSort = method;
		};

		this.setTransparentSort = function (method) {
			_transparentSort = method;
		}; // Clearing


		this.getClearColor = function (target) {
			if (target === undefined) {
				console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');
				target = new Color();
			}

			return target.copy(background.getClearColor());
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			let bits = 0;
			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		}; //


		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			xr.dispose();
			xr.removeEventListener('sessionstart', onXRSessionStart);
			xr.removeEventListener('sessionend', onXRSessionEnd);
			animation.stop();
		}; // Events


		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore()
		/* event */
		{
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}

		function onMaterialDispose(event) {
			const material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		} // Buffer deallocation


		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReferences(material) {
			const programs = properties.get(material).programs;

			if (programs !== undefined) {
				programs.forEach(function (program) {
					programCache.releaseProgram(program);
				});
			}
		} // Buffer rendering


		function renderObjectImmediate(object, program) {
			object.render(function (object) {
				_this.renderBufferImmediate(object, program);
			});
		}

		this.renderBufferImmediate = function (object, program) {
			bindingStates.initAttributes();
			const buffers = properties.get(object);
			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
			const programAttributes = program.getAttributes();

			if (object.hasPositions) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.position);

				_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasNormals) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.normal);

				_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasUvs) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.uv);

				_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasColors) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.color);

				_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays(_gl.TRIANGLES, 0, object.count);

			object.count = 0;
		};

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			const program = setProgram(camera, scene, material, object);
			state.setMaterial(material, frontFaceCW); //

			let index = geometry.index;
			const position = geometry.attributes.position; //

			if (index === null) {
				if (position === undefined || position.count === 0) return;
			} else if (index.count === 0) {
				return;
			} //


			let rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			if (material.morphTargets || material.morphNormals) {
				morphtargets.update(object, geometry, material, program);
			}

			bindingStates.setup(object, material, program, geometry, index);
			let attribute;
			let renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			} //


			const dataCount = index !== null ? index.count : position.count;
			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;
			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;
			const drawStart = Math.max(rangeStart, groupStart);
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
			const drawCount = Math.max(0, drawEnd - drawStart + 1);
			if (drawCount === 0) return; //

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {
					renderer.setMode(_gl.TRIANGLES);
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP);
				} else {
					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES);
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		}; // Compile


		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights();
			scene.traverse(function (object) {
				const material = object.material;

				if (material) {
					if (Array.isArray(material)) {
						for (let i = 0; i < material.length; i++) {
							const material2 = material[i];
							getProgram(material2, scene, object);
						}
					} else {
						getProgram(material, scene, object);
					}
				}
			});
		}; // Animation Loop


		let onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		function onXRSessionStart() {
			animation.stop();
		}

		function onXRSessionEnd() {
			animation.start();
		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		};

		xr.addEventListener('sessionstart', onXRSessionStart);
		xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

		this.render = function (scene, camera) {
			let renderTarget, forceClear;

			if (arguments[2] !== undefined) {
				console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
				renderTarget = arguments[2];
			}

			if (arguments[3] !== undefined) {
				console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
				forceClear = arguments[3];
			}

			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost === true) return; // update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (xr.enabled === true && xr.isPresenting === true) {
				camera = xr.getCamera(camera);
			} //


			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			_frustum.setFromProjectionMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			} //


			if (_clippingEnabled === true) clipping.beginShadows();
			const shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			currentRenderState.setupLights();
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping.endShadows(); //

			if (this.info.autoReset === true) this.info.reset();

			if (renderTarget !== undefined) {
				this.setRenderTarget(renderTarget);
			} //


			background.render(currentRenderList, scene, camera, forceClear); // render scene

			const opaqueObjects = currentRenderList.opaque;
			const transparentObjects = currentRenderList.transparent;
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

			if (_currentRenderTarget !== null) {
				// Generate mipmap if we're using any kind of mipmap filtering
				textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget(_currentRenderTarget);
			} //


			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false); // _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}

			renderListStack.pop();

			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1];
			} else {
				currentRenderList = null;
			}
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (Array.isArray(material)) {
							const groups = geometry.groups;

							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, groupOrder, sortObjects);
			}
		}

		function renderObjects(renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for (let i = 0, l = renderList.length; i < l; i++) {
				const renderItem = renderList[i];
				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if (camera.isArrayCamera) {
					const cameras = camera.cameras;

					for (let j = 0, jl = cameras.length; j < jl; j++) {
						const camera2 = cameras[j];

						if (object.layers.test(camera2.layers)) {
							state.viewport(_currentViewport.copy(camera2.viewport));
							currentRenderState.setupLightsView(camera2);
							renderObject(object, scene, camera2, geometry, material, group);
						}
					}
				} else {
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

			if (object.isImmediateRenderObject) {
				const program = setProgram(camera, scene, material, object);
				state.setMaterial(material);
				bindingStates.reset();
				renderObjectImmediate(object, program);
			} else {
				_this.renderBufferDirect(camera, scene, geometry, material, object, group);
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;
			const lightsStateVersion = lights.state.version;
			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			const programCacheKey = programCache.getProgramCacheKey(parameters);
			let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);

			if (programs === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
				programs = new Map();
				materialProperties.programs = programs;
			}

			let program = programs.get(programCacheKey);

			if (program !== undefined) {
				// early out if program and light state is identical
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters);
					return program;
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBuild(parameters, _this);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters.uniforms;
			}

			const uniforms = materialProperties.uniforms;

			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform;
			}

			updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
			}

			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;
			return program;
		}

		function updateCommonMaterialProperties(material, parameters) {
			const materialProperties = properties.get(material);
			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
		}

		function setProgram(camera, scene, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			const envMap = cubemaps.get(material.envMap || environment);
			const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)

					clipping.setState(material, camera, useCache);
				}
			} //


			let needsProgramChange = false;

			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					needsProgramChange = true;
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true;
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true;
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true;
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true;
				} else if (material.fog && materialProperties.fog !== fog) {
					needsProgramChange = true;
				} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
					needsProgramChange = true;
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true;
				}
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			} //


			let program = materialProperties.currentProgram;

			if (needsProgramChange === true) {
				program = getProgram(material, scene, object);
			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;
			const p_uniforms = program.getUniforms(),
						m_uniforms = materialProperties.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true; // set to true on material change

					refreshLights = true; // remains set until update done
				} // load material specific uniforms
				// (shader material also gets them for the sake of genericity)


				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			} // skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures


			if (material.skinning) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				const skeleton = object.skeleton;

				if (skeleton) {
					const bones = skeleton.bones;

					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) {
							// layout (1 matrix = 4 pixels)
							//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
							//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
							//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
							//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
							let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

							size = ceilPowerOfTwo(size);
							size = Math.max(size, 4);
							const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

							boneMatrices.set(skeleton.boneMatrices); // copy current values

							const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;
						}

						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				} // refresh uniforms common to several materials


				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			} // common matrices


			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			return program;
		} // If uniforms are marked as clean, they don't need to be loaded to the GPU.


		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		}

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace;
		};

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			}

			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if (renderTarget) {
				const texture = renderTarget.texture;

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
					isRenderTarget3D = true;
				}

				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.isWebGLMultisampleRenderTarget) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);

				_currentScissor.copy(renderTarget.scissor);

				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

				_currentScissorTest = _scissorTest;
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);

				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				const textureProperties = properties.get(renderTarget.texture);
				const layer = activeCubeFace || 0;

				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
			}
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			let framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}

			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

				try {
					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
					!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
					!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					// restore framebuffer of current render target if necessary
					const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level = 0) {
			const levelScale = Math.pow(2, -level);
			const width = Math.floor(texture.image.width * levelScale);
			const height = Math.floor(texture.image.height * levelScale);
			const glFormat = utils.convert(texture.format);
			textures.setTexture2D(texture, 0);

			_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);

			state.unbindTexture();
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			} // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
			state.unbindTexture();
		};

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
				return;
			}

			const {
				width,
				height,
				data
			} = srcTexture.image;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			let glTarget;

			if (dstTexture.isDataTexture3D) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataTexture2DArray) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
				return;
			}

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);

			const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);

			const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);

			const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);

			const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, width);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, height);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);

			_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0);
			state.unbindTexture();
		};

		this.resetState = function () {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			})); // eslint-disable-line no-undef

		}
	}

	class WebGL1Renderer extends WebGLRenderer {}

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	class FogExp2 {
		constructor(color, density = 0.00025) {
			this.name = '';
			this.color = new Color(color);
			this.density = density;
		}

		clone() {
			return new FogExp2(this.color, this.density);
		}

		toJSON()
		/* meta */
		{
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		}

	}

	FogExp2.prototype.isFogExp2 = true;

	class Fog {
		constructor(color, near = 1, far = 1000) {
			this.name = '';
			this.color = new Color(color);
			this.near = near;
			this.far = far;
		}

		clone() {
			return new Fog(this.color, this.near, this.far);
		}

		toJSON()
		/* meta */
		{
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		}

	}

	Fog.prototype.isFog = true;

	class Scene extends Object3D {
		constructor() {
			super();
			this.type = 'Scene';
			this.background = null;
			this.environment = null;
			this.fog = null;
			this.overrideMaterial = null;
			this.autoUpdate = true; // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: this
				})); // eslint-disable-line no-undef

			}
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.background !== null) data.object.background = this.background.toJSON(meta);
			if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			return data;
		}

	}

	Scene.prototype.isScene = true;

	class InterleavedBuffer {
		constructor(array, stride) {
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
			this.uuid = generateUUID();

			this.onUploadCallback = function () {};
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (let i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}

			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}

			const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			const ib = new InterleavedBuffer(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			} // generate UUID for array buffer if necessary


			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
			} //


			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		}

	}

	InterleavedBuffer.prototype.isInterleavedBuffer = true;

	const _vector$6 = new /*@__PURE__*/Vector3();

	class InterleavedBufferAttribute {
		constructor(interleavedBuffer, itemSize, offset, normalized) {
			this.name = '';
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
			this.normalized = normalized === true;
		}

		get count() {
			return this.data.count;
		}

		get array() {
			return this.data.array;
		}

		set needsUpdate(value) {
			this.data.needsUpdate = value;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.data.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyMatrix4(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyNormalMatrix(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.transformDirection(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		}

		setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		}

		setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		}

		setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		}

		getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		}

		getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		}

		getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		}

		getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		}

		setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		}

		clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		}

		toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				} // deinterleave data and save it as an ordinary buffer attribute for now


				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interlaved attribtue
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		}

	}

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */

	class SpriteMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'SpriteMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.rotation = 0;
			this.sizeAttenuation = true;
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.rotation = source.rotation;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true;

	let _geometry;

	const _intersectPoint = /*@__PURE__*/new Vector3();

	const _worldScale = /*@__PURE__*/new Vector3();

	const _mvPosition = /*@__PURE__*/new Vector3();

	const _alignedPosition = /*@__PURE__*/new Vector2();

	const _rotatedPosition = /*@__PURE__*/new Vector2();

	const _viewWorldMatrix = /*@__PURE__*/new Matrix4();

	const _vA = /*@__PURE__*/new Vector3();

	const _vB = /*@__PURE__*/new Vector3();

	const _vC = /*@__PURE__*/new Vector3();

	const _uvA = /*@__PURE__*/new Vector2();

	const _uvB = /*@__PURE__*/new Vector2();

	const _uvC = /*@__PURE__*/new Vector2();

	class Sprite extends Object3D {
		constructor(material) {
			super();
			this.type = 'Sprite';

			if (_geometry === undefined) {
				_geometry = new BufferGeometry();
				const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
				const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

				_geometry.setIndex([0, 1, 2, 0, 2, 3]);

				_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

				_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
			}

			this.geometry = _geometry;
			this.material = material !== undefined ? material : new SpriteMaterial();
			this.center = new Vector2(0.5, 0.5);
		}

		raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}

			_worldScale.setFromMatrixScale(this.matrixWorld);

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);

			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}

			const rotation = this.material.rotation;
			let sin, cos;

			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}

			const center = this.center;
			transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

			_uvA.set(0, 0);

			_uvB.set(1, 0);

			_uvC.set(1, 1); // check first triangle


			let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);

			if (intersect === null) {
				// check second triangle
				transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

				_uvB.set(0, 1);

				intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);

				if (intersect === null) {
					return;
				}
			}

			const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
				face: null,
				object: this
			});
		}

		copy(source) {
			super.copy(source);
			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		}

	}

	Sprite.prototype.isSprite = true;

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


		if (sin !== undefined) {
			_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
			_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}

		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y; // transform to world space

		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}

	const _v1$2 = /*@__PURE__*/new Vector3();

	const _v2$1 = /*@__PURE__*/new Vector3();

	class LOD extends Object3D {
		constructor() {
			super();
			this._currentLevel = 0;
			this.type = 'LOD';
			Object.defineProperties(this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true
				}
			});
			this.autoUpdate = true;
		}

		copy(source) {
			super.copy(source, false);
			const levels = source.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				this.addLevel(level.object.clone(), level.distance);
			}

			this.autoUpdate = source.autoUpdate;
			return this;
		}

		addLevel(object, distance = 0) {
			distance = Math.abs(distance);
			const levels = this.levels;
			let l;

			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, {
				distance: distance,
				object: object
			});
			this.add(object);
			return this;
		}

		getCurrentLevel() {
			return this._currentLevel;
		}

		getObjectForDistance(distance) {
			const levels = this.levels;

			if (levels.length > 0) {
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance < levels[i].distance) {
						break;
					}
				}

				return levels[i - 1].object;
			}

			return null;
		}

		raycast(raycaster, intersects) {
			const levels = this.levels;

			if (levels.length > 0) {
				_v1$2.setFromMatrixPosition(this.matrixWorld);

				const distance = raycaster.ray.origin.distanceTo(_v1$2);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		}

		update(camera) {
			const levels = this.levels;

			if (levels.length > 1) {
				_v1$2.setFromMatrixPosition(camera.matrixWorld);

				_v2$1.setFromMatrixPosition(this.matrixWorld);

				const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
				levels[0].object.visible = true;
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance >= levels[i].distance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}

				this._currentLevel = i - 1;

				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			const levels = this.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});
			}

			return data;
		}

	}

	const _basePosition = /*@__PURE__*/new Vector3();

	const _skinIndex = /*@__PURE__*/new Vector4();

	const _skinWeight = /*@__PURE__*/new Vector4();

	const _vector$5 = /*@__PURE__*/new Vector3();

	const _matrix = /*@__PURE__*/new Matrix4();

	class SkinnedMesh extends Mesh {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'SkinnedMesh';
			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
		}

		copy(source) {
			super.copy(source);
			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		}

		bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		}

		pose() {
			this.skeleton.pose();
		}

		normalizeSkinWeights() {
			const vector = new Vector4();
			const skinWeight = this.geometry.attributes.skinWeight;

			for (let i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);
				const scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		}

		boneTransform(index, target) {
			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

			_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);

			target.set(0, 0, 0);

			for (let i = 0; i < 4; i++) {
				const weight = _skinWeight.getComponent(i);

				if (weight !== 0) {
					const boneIndex = _skinIndex.getComponent(i);

					_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

					target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
				}
			}

			return target.applyMatrix4(this.bindMatrixInverse);
		}

	}

	SkinnedMesh.prototype.isSkinnedMesh = true;

	class Bone extends Object3D {
		constructor() {
			super();
			this.type = 'Bone';
		}

	}

	Bone.prototype.isBone = true;

	const _offsetMatrix = /*@__PURE__*/new Matrix4();

	const _identityMatrix = /*@__PURE__*/new Matrix4();

	class Skeleton {
		constructor(bones = [], boneInverses = []) {
			this.uuid = generateUUID();
			this.bones = bones.slice(0);
			this.boneInverses = boneInverses;
			this.boneMatrices = null;
			this.boneTexture = null;
			this.boneTextureSize = 0;
			this.frame = -1;
			this.init();
		}

		init() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];

					for (let i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		}

		calculateInverses() {
			this.boneInverses.length = 0;

			for (let i = 0, il = this.bones.length; i < il; i++) {
				const inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}

				this.boneInverses.push(inverse);
			}
		}

		pose() {
			// recover the bind-time world matrices
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			} // compute the local matrices, positions, rotations and scales


			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					if (bone.parent && bone.parent.isBone) {
						bone.matrix.copy(bone.parent.matrixWorld).invert();
						bone.matrix.multiply(bone.matrixWorld);
					} else {
						bone.matrix.copy(bone.matrixWorld);
					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
				}
			}
		}

		update() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture; // flatten bone matrices to array

			for (let i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

				_offsetMatrix.toArray(boneMatrices, i * 16);
			}

			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		}

		clone() {
			return new Skeleton(this.bones, this.boneInverses);
		}

		getBoneByName(name) {
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		}

		dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		}

		fromJSON(json, bones) {
			this.uuid = json.uuid;

			for (let i = 0, l = json.bones.length; i < l; i++) {
				const uuid = json.bones[i];
				let bone = bones[uuid];

				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}

				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}

			this.init();
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for (let i = 0, l = bones.length; i < l; i++) {
				const bone = bones[i];
				data.bones.push(bone.uuid);
				const boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}

			return data;
		}

	}

	const _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

	const _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

	const _instanceIntersects = [];

	const _mesh = /*@__PURE__*/new Mesh();

	class InstancedMesh extends Mesh {
		constructor(geometry, material, count) {
			super(geometry, material);
			this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
			this.instanceColor = null;
			this.count = count;
			this.frustumCulled = false;
		}

		copy(source) {
			super.copy(source);
			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		}

		getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		}

		getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		}

		raycast(raycaster, intersects) {
			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;

			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
					const intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}

				_instanceIntersects.length = 0;
			}
		}

		setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
			}

			color.toArray(this.instanceColor.array, index * 3);
		}

		setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		}

		updateMorphTargets() {}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	InstancedMesh.prototype.isInstancedMesh = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */

	class LineBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'LineBasicMaterial';
			this.color = new Color(0xffffff);
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
			this.morphTargets = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
			this.morphTargets = source.morphTargets;
			return this;
		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	const _start$1 = /*@__PURE__*/new Vector3();

	const _end$1 = /*@__PURE__*/new Vector3();

	const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

	const _ray$1 = /*@__PURE__*/new Ray();

	const _sphere$1 = /*@__PURE__*/new Sphere();

	class Line extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
			super();
			this.type = 'Line';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [0];

					for (let i = 1, l = positionAttribute.count; i < l; i++) {
						_start$1.fromBufferAttribute(positionAttribute, i - 1);

						_end$1.fromBufferAttribute(positionAttribute, i);

						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += _start$1.distanceTo(_end$1);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$1.copy(geometry.boundingSphere);

			_sphere$1.applyMatrix4(matrixWorld);

			_sphere$1.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

			_inverseMatrix$1.copy(matrixWorld).invert();

			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;
			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						const a = index.getX(i);
						const b = index.getX(i + 1);
						vStart.fromBufferAttribute(positionAttribute, a);
						vEnd.fromBufferAttribute(positionAttribute, b);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						vStart.fromBufferAttribute(positionAttribute, i);
						vEnd.fromBufferAttribute(positionAttribute, i + 1);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Line.prototype.isLine = true;

	const _start = /*@__PURE__*/new Vector3();

	const _end = /*@__PURE__*/new Vector3();

	class LineSegments extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineSegments';
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
						_start.fromBufferAttribute(positionAttribute, i);

						_end.fromBufferAttribute(positionAttribute, i + 1);

						lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

	}

	LineSegments.prototype.isLineSegments = true;

	class LineLoop extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineLoop';
		}

	}

	LineLoop.prototype.isLineLoop = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 *	morphTargets: <bool>
	 * }
	 */

	class PointsMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'PointsMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.size = 1;
			this.sizeAttenuation = true;
			this.morphTargets = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
			this.morphTargets = source.morphTargets;
			return this;
		}

	}

	PointsMaterial.prototype.isPointsMaterial = true;

	const _inverseMatrix = /*@__PURE__*/new Matrix4();

	const _ray = /*@__PURE__*/new Ray();

	const _sphere = /*@__PURE__*/new Sphere();

	const _position$2 = /*@__PURE__*/new Vector3();

	class Points extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
			super();
			this.type = 'Points';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere);

			_sphere.applyMatrix4(matrixWorld);

			_sphere.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

			_inverseMatrix.copy(matrixWorld).invert();

			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, il = end; i < il; i++) {
						const a = index.getX(i);

						_position$2.fromBufferAttribute(positionAttribute, a);

						testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end; i < l; i++) {
						_position$2.fromBufferAttribute(positionAttribute, i);

						testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				}
			} else {
				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Points.prototype.isPoints = true;

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		const rayPointDistanceSq = _ray.distanceSqToPoint(point);

		if (rayPointDistanceSq < localThresholdSq) {
			const intersectPoint = new Vector3();

			_ray.closestPointToPoint(point, intersectPoint);

			intersectPoint.applyMatrix4(matrixWorld);
			const distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}

	class VideoTexture extends Texture {
		constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.format = format !== undefined ? format : RGBFormat;
			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.generateMipmaps = false;
			const scope = this;

			function updateVideo() {
				scope.needsUpdate = true;
				video.requestVideoFrameCallback(updateVideo);
			}

			if ('requestVideoFrameCallback' in video) {
				video.requestVideoFrameCallback(updateVideo);
			}
		}

		clone() {
			return new this.constructor(this.image).copy(this);
		}

		update() {
			const video = this.image;
			const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		}

	}

	VideoTexture.prototype.isVideoTexture = true;

	class CompressedTexture extends Texture {
		constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				width: width,
				height: height
			};
			this.mipmaps = mipmaps; // no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false; // can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;
		}

	}

	CompressedTexture.prototype.isCompressedTexture = true;

	class CanvasTexture extends Texture {
		constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.needsUpdate = true;
		}

	}

	CanvasTexture.prototype.isCanvasTexture = true;

	class DepthTexture extends Texture {
		constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
			format = format !== undefined ? format : DepthFormat;

			if (format !== DepthFormat && format !== DepthStencilFormat) {
				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
			}

			if (type === undefined && format === DepthFormat) type = UnsignedShortType;
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.image = {
				width: width,
				height: height
			};
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			this.flipY = false;
			this.generateMipmaps = false;
		}

	}

	DepthTexture.prototype.isDepthTexture = true;

	class CircleGeometry extends BufferGeometry {
		constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CircleGeometry';
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const uv = new Vector2(); // center point

			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);

			for (let s = 0, i = 3; s <= segments; s++, i += 3) {
				const segment = thetaStart + s / segments * thetaLength; // vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z); // normal

				normals.push(0, 0, 1); // uvs

				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			} // indices


			for (let i = 1; i <= segments; i++) {
				indices.push(i, i + 1, 0);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class CylinderGeometry extends BufferGeometry {
		constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CylinderGeometry';
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			const scope = this;
			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0; // generate geometry

			generateTorso();

			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				const normal = new Vector3();
				const vertex = new Vector3();
				let groupCount = 0; // this will be used to calculate the normal

				const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

				for (let y = 0; y <= heightSegments; y++) {
					const indexRow = [];
					const v = y / heightSegments; // calculate the radius of the current row

					const radius = v * (radiusBottom - radiusTop) + radiusTop;

					for (let x = 0; x <= radialSegments; x++) {
						const u = x / radialSegments;
						const theta = u * thetaLength + thetaStart;
						const sinTheta = Math.sin(theta);
						const cosTheta = Math.cos(theta); // vertex

						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z); // normal

						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z); // uv

						uvs.push(u, 1 - v); // save index of vertex in respective row

						indexRow.push(index++);
					} // now save vertices of the row in our index array


					indexArray.push(indexRow);
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					for (let y = 0; y < heightSegments; y++) {
						// we use the index array to access the correct indices
						const a = indexArray[y][x];
						const b = indexArray[y + 1][x];
						const c = indexArray[y + 1][x + 1];
						const d = indexArray[y][x + 1]; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // update group counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				const centerIndexStart = index;
				const uv = new Vector2();
				const vertex = new Vector3();
				let groupCount = 0;
				const radius = top === true ? radiusTop : radiusBottom;
				const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (let x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0); // normal

					normals.push(0, sign, 0); // uv

					uvs.push(0.5, 0.5); // increase index

					index++;
				} // save the index of the last center vertex


				const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const cosTheta = Math.cos(theta);
					const sinTheta = Math.sin(theta); // vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, sign, 0); // uv

					uv.x = cosTheta * 0.5 + 0.5;
					uv.y = sinTheta * 0.5 * sign + 0.5;
					uvs.push(uv.x, uv.y); // increase index

					index++;
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}

					groupCount += 3;
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

				groupStart += groupCount;
			}
		}

	}

	class ConeGeometry extends CylinderGeometry {
		constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
			this.type = 'ConeGeometry';
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
		}

	}

	class PolyhedronGeometry extends BufferGeometry {
		constructor(vertices, indices, radius = 1, detail = 0) {
			super();
			this.type = 'PolyhedronGeometry';
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}; // default buffer data

			const vertexBuffer = [];
			const uvBuffer = []; // the subdivision creates the vertex buffer data

			subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius); // finally, create the uv data

			generateUVs(); // build non-indexed geometry

			this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
			this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

			if (detail === 0) {
				this.computeVertexNormals(); // flat normals
			} else {
				this.normalizeNormals(); // smooth normals
			} // helper functions


			function subdivide(detail) {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

				for (let i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c); // perform subdivision

					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

				const v = []; // construct all of the vertices for this subdivision

				for (let i = 0; i <= cols; i++) {
					v[i] = [];
					const aj = a.clone().lerp(c, i / cols);
					const bj = b.clone().lerp(c, i / cols);
					const rows = cols - i;

					for (let j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				} // construct all of the faces


				for (let i = 0; i < cols; i++) {
					for (let j = 0; j < 2 * (cols - i) - 1; j++) {
						const k = Math.floor(j / 2);

						if (j % 2 === 0) {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k]);
							pushVertex(v[i][k]);
						} else {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k + 1]);
							pushVertex(v[i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				const vertex = new Vector3();

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					const u = azimuth(vertex) / 2 / Math.PI + 0.5;
					const v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}

				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (let i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					const x0 = uvBuffer[i + 0];
					const x1 = uvBuffer[i + 2];
					const x2 = uvBuffer[i + 4];
					const max = Math.max(x0, x1, x2);
					const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				const stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();
				const centroid = new Vector3();
				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					const azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if (azimuth < 0 && uv.x === 1) {
					uvBuffer[stride] = uv.x - 1;
				}

				if (vector.x === 0 && vector.z === 0) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			} // Angle around the Y axis, counter-clockwise when looking from above.


			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			} // Angle above the XZ plane.


			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
			}
		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const r = 1 / t;
			const vertices = [// (±1, ±1, ±1)
			-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
			0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
			-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
			-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
			const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			super(vertices, indices, radius, detail);
			this.type = 'DodecahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

	}

	const _v0 = new Vector3();

	const _v1$1 = new Vector3();

	const _normal = new Vector3();

	const _triangle = new Triangle();

	class EdgesGeometry extends BufferGeometry {
		constructor(geometry, thresholdAngle) {
			super();
			this.type = 'EdgesGeometry';
			this.parameters = {
				thresholdAngle: thresholdAngle
			};
			thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

			if (geometry.isGeometry === true) {
				console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return;
			}

			const precisionPoints = 4;
			const precision = Math.pow(10, precisionPoints);
			const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute('position');
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
			const indexArr = [0, 0, 0];
			const vertKeys = ['a', 'b', 'c'];
			const hashes = new Array(3);
			const edgeData = {};
			const vertices = [];

			for (let i = 0; i < indexCount; i += 3) {
				if (indexAttr) {
					indexArr[0] = indexAttr.getX(i);
					indexArr[1] = indexAttr.getX(i + 1);
					indexArr[2] = indexAttr.getX(i + 2);
				} else {
					indexArr[0] = i;
					indexArr[1] = i + 1;
					indexArr[2] = i + 2;
				}

				const {
					a,
					b,
					c
				} = _triangle;
				a.fromBufferAttribute(positionAttr, indexArr[0]);
				b.fromBufferAttribute(positionAttr, indexArr[1]);
				c.fromBufferAttribute(positionAttr, indexArr[2]);

				_triangle.getNormal(_normal); // create hashes for the edge from the vertices


				hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
				hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
				hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles

				if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
					continue;
				} // iterate over every edge


				for (let j = 0; j < 3; j++) {
					// get the first and next vertex making up the edge
					const jNext = (j + 1) % 3;
					const vecHash0 = hashes[j];
					const vecHash1 = hashes[jNext];
					const v0 = _triangle[vertKeys[j]];
					const v1 = _triangle[vertKeys[jNext]];
					const hash = `${vecHash0}_${vecHash1}`;
					const reverseHash = `${vecHash1}_${vecHash0}`;

					if (reverseHash in edgeData && edgeData[reverseHash]) {
						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
							vertices.push(v0.x, v0.y, v0.z);
							vertices.push(v1.x, v1.y, v1.z);
						}

						edgeData[reverseHash] = null;
					} else if (!(hash in edgeData)) {
						// if we've already got an edge here then skip adding a new one
						edgeData[hash] = {
							index0: indexArr[j],
							index1: indexArr[jNext],
							normal: _normal.clone()
						};
					}
				}
			} // iterate over all remaining, unmatched edges and add them to the vertex array


			for (const key in edgeData) {
				if (edgeData[key]) {
					const {
						index0,
						index1
					} = edgeData[key];

					_v0.fromBufferAttribute(positionAttr, index0);

					_v1$1.fromBufferAttribute(positionAttr, index1);

					vertices.push(_v0.x, _v0.y, _v0.z);
					vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
				}
			}

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}

	}

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */
	const Earcut = {
		triangulate: function (data, holeIndices, dim) {
			dim = dim || 2;
			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			let outerNode = linkedList(data, 0, outerLen, dim, true);
			const triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			let minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (let i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				} // minX, minY and invSize are later used to transform coords into integers for z-order calculation


				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		let i, last;

		if (clockwise === signedArea(data, start, end, dim) > 0) {
			for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
		} else {
			for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		let p = start,
				again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return; // interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		let stop = ear,
				prev,
				next; // iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				removeNode(ear); // skipping the next vertex leads to less sliver triangles

				ear = next.next;
				stop = next.next;
				continue;
			}

			ear = next; // if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear

		let p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// triangle bbox; min & max are calculated like this for speed

		const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
					minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
					maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
					maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

		const minZ = zOrder(minTX, minTY, minX, minY, invSize),
					maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
		let p = ear.prevZ,
				n = ear.nextZ; // look for points inside the triangle in both directions

		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		} // look for remaining points in decreasing z-order


		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		} // look for remaining points in increasing z-order


		while (n && n.z <= maxZ) {
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}

		return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
		let p = start;

		do {
			const a = p.prev,
						b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim); // remove two nodes involved

				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return filterPoints(p);
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		let a = start;

		do {
			let b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					let c = splitPolygon(a, b); // filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next); // run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
		const queue = [];
		let i, len, start, end, list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX); // process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

			filterPoints(outerNode, outerNode.next);
			filterPoints(b, b.next);
		}
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = -Infinity,
				m; // find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;
		if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
					mx = m.x,
					my = m.y;
		let tanMin = Infinity,
				tan;
		p = m;

		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		} while (p !== stop);

		return m;
	} // whether sector in vertex m contains sector in vertex p in the same coordinates


	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
		let p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
		let i,
				p,
				q,
				e,
				tail,
				numMerges,
				pSize,
				qSize,
				inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || qSize > 0 && q) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;else list = e;
					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;
		x = (x | x << 8) & 0x00FF00FF;
		x = (x | x << 4) & 0x0F0F0F0F;
		x = (x | x << 2) & 0x33333333;
		x = (x | x << 1) & 0x55555555;
		y = (y | y << 8) & 0x00FF00FF;
		y = (y | y << 4) & 0x0F0F0F0F;
		y = (y | y << 2) & 0x33333333;
		y = (y | y << 1) & 0x55555555;
		return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
		let p = start,
				leftmost = start;

		do {
			if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
		locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
		area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
		equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	} // signed area of a triangle


	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
		const o1 = sign(area(p1, q1, p2));
		const o2 = sign(area(p1, q1, q2));
		const o3 = sign(area(p2, q2, p1));
		const o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case

		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;
	} // for collinear points p, q, r, check if point q lies on segment pr


	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
		let p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);

		return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
		let p = a,
				inside = false;
		const px = (a.x + b.x) / 2,
					py = (a.y + b.y) / 2;

		do {
			if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
			p = p.next;
		} while (p !== a);

		return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
		const a2 = new Node(a.i, a.x, a.y),
					b2 = new Node(b.i, b.x, b.y),
					an = a.next,
					bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
		const p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i; // vertex coordinates

		this.x = x;
		this.y = y; // previous and next vertex nodes in a polygon ring

		this.prev = null;
		this.next = null; // z-order curve value

		this.z = null; // previous and next nodes in z-order

		this.prevZ = null;
		this.nextZ = null; // indicates whether this is a steiner point

		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		let sum = 0;

		for (let i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	class ShapeUtils {
		// calculate area of the contour polygon
		static area(contour) {
			const n = contour.length;
			let a = 0.0;

			for (let p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		}

		static isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		}

		static triangulateShape(contour, holes) {
			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

			const holeIndices = []; // array of hole indices

			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour); //

			let holeIndex = contour.length;
			holes.forEach(removeDupEndPts);

			for (let i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			} //


			const triangles = Earcut.triangulate(vertices, holeIndices); //

			for (let i = 0; i < triangles.length; i += 3) {
				faces.push(triangles.slice(i, i + 3));
			}

			return faces;
		}

	}

	function removeDupEndPts(points) {
		const l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (let i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves
	 *	steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *	depth: <float>, // Depth to extrude the shape
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into the original shape bevel goes
	 *	bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *	bevelOffset: <float>, // how far from shape outline does bevel start
	 *	bevelSegments: <int>, // number of bevel layers
	 *
	 *	extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *	UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {
		constructor(shapes, options) {
			super();
			this.type = 'ExtrudeGeometry';
			this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];
			const scope = this;
			const verticesArray = [];
			const uvArray = [];

			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				addShape(shape);
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
			this.computeVertexNormals(); // functions

			function addShape(shape) {
				const placeholder = []; // options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				let depth = options.depth !== undefined ? options.depth : 100;
				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				const extrudePath = options.extrudePath;
				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

				if (options.amount !== undefined) {
					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
					depth = options.amount;
				} //


				let extrudePts,
						extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				} // Safeguards if bevels are not enabled


				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				} // Variables initialization


				const shapePoints = shape.extractPoints(curveSegments);
				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;
				const reverse = !ShapeUtils.isClockWise(vertices);

				if (reverse) {
					vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];

						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}

				const faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					vertices = vertices.concat(ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return vec.clone().multiplyScalar(size).add(pt);
				}

				const vlen = vertices.length,
							flen = faces.length; // Find directions for point movement

				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//	 shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//	adjacent edges of inPt at a distance of 1 unit on the left side.
					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
								v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
								v_next_y = inNext.y - inPt.y;
					const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

					const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						const v_prev_len = Math.sqrt(v_prev_lensq);
						const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

						const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
						const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
						const ptNextShift_x = inNext.x - v_next_y / v_next_len;
						const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

						const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

						v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
						v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
						//	but prevent crazy spikes

						const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						let direction_eq = false; // assumes: opposite

						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}

						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				const contourMovements = [];

				for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0; //	(j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
				}

				const holesMovements = [];
				let oneHoleMovements,
						verticesMovements = contourMovements.concat();

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = [];

					for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
						if (j === il) j = 0;
						if (k === il) k = 0; //	(j)---(i)---(k)

						oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
					}

					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				} // Loop bevelSegments, 1 for the front, 1 for the back


				for (let b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, -z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
							v(vert.x, vert.y, -z);
						}
					}
				}

				const bs = bevelSize + bevelOffset; // Back facing vertices

				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

					if (!extrudeByPath) {
						v(vert.x, vert.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				} // Add stepped vertices...
				// Including front facing vertices


				for (let s = 1; s <= steps; s++) {
					for (let i = 0; i < vlen; i++) {
						const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

						if (!extrudeByPath) {
							v(vert.x, vert.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				} // Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {


				for (let b = bevelSegments - 1; b >= 0; b--) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, depth + z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

							if (!extrudeByPath) {
								v(vert.x, vert.y, depth + z);
							} else {
								v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces


				buildLidFaces(); // Sides faces

				buildSideFaces(); /////	Internal functions

				function buildLidFaces() {
					const start = verticesArray.length / 3;

					if (bevelEnabled) {
						let layer = 0; // steps + 1

						let offset = vlen * layer; // Bottom faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer; // Top faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + offset, face[1] + offset, face[2] + offset);
						}
					} else {
						// Bottom faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2], face[1], face[0]);
						} // Top faces


						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
						}
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				} // Create faces for the z-sides of the shape


				function buildSideFaces() {
					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						sidewalls(ahole, layeroffset); //, true

						layeroffset += ahole.length;
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					let i = contour.length;

					while (--i >= 0) {
						const j = i;
						let k = i - 1;
						if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

						for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
							const slen1 = vlen * s;
							const slen2 = vlen * (s + 1);
							const a = layeroffset + j + slen1,
										b = layeroffset + k + slen1,
										c = layeroffset + k + slen2,
										d = layeroffset + j + slen2;
							f4(a, b, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}
		}

		toJSON() {
			const data = BufferGeometry.prototype.toJSON.call(this);
			const shapes = this.parameters.shapes;
			const options = this.parameters.options;
			return toJSON$1(shapes, options, data);
		}

	}

	const WorldUVGenerator = {
		generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
		},
		generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const a_z = vertices[indexA * 3 + 2];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const b_z = vertices[indexB * 3 + 2];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			const c_z = vertices[indexC * 3 + 2];
			const d_x = vertices[indexD * 3];
			const d_y = vertices[indexD * 3 + 1];
			const d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < 0.01) {
				return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
			} else {
				return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
			}
		}
	};

	function toJSON$1(shapes, options, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}

	class IcosahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
			const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			super(vertices, indices, radius, detail);
			this.type = 'IcosahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

	}

	class LatheGeometry extends BufferGeometry {
		constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
			super();
			this.type = 'LatheGeometry';
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

			const indices = [];
			const vertices = [];
			const uvs = []; // helper variables

			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices and uvs

			for (let i = 0; i <= segments; i++) {
				const phi = phiStart + i * inverseSegments * phiLength;
				const sin = Math.sin(phi);
				const cos = Math.cos(phi);

				for (let j = 0; j <= points.length - 1; j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z); // uv

					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
				}
			} // indices


			for (let i = 0; i < segments; i++) {
				for (let j = 0; j < points.length - 1; j++) {
					const base = j + i * points.length;
					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

			this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if (phiLength === Math.PI * 2) {
				const normals = this.attributes.normal.array;
				const n1 = new Vector3();
				const n2 = new Vector3();
				const n = new Vector3(); // this is the buffer offset for the last line of vertices

				const base = segments * points.length * 3;

				for (let i = 0, j = 0; i < points.length; i++, j += 3) {
					// select the normal of the vertex in the first line
					n1.x = normals[j + 0];
					n1.y = normals[j + 1];
					n1.z = normals[j + 2]; // select the normal of the vertex in the last line

					n2.x = normals[base + j + 0];
					n2.y = normals[base + j + 1];
					n2.z = normals[base + j + 2]; // average normals

					n.addVectors(n1, n2).normalize(); // assign the new values to both normals

					normals[j + 0] = normals[base + j + 0] = n.x;
					normals[j + 1] = normals[base + j + 1] = n.y;
					normals[j + 2] = normals[base + j + 2] = n.z;
				}
			}
		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
			const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			super(vertices, indices, radius, detail);
			this.type = 'OctahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

	}

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	class ParametricGeometry extends BufferGeometry {
		constructor(func, slices, stacks) {
			super();
			this.type = 'ParametricGeometry';
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			const EPS = 0.00001;
			const normal = new Vector3();
			const p0 = new Vector3(),
						p1 = new Vector3();
			const pu = new Vector3(),
						pv = new Vector3();

			if (func.length < 3) {
				console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
			} // generate vertices, normals and uvs


			const sliceCount = slices + 1;

			for (let i = 0; i <= stacks; i++) {
				const v = i / stacks;

				for (let j = 0; j <= slices; j++) {
					const u = j / slices; // vertex

					func(u, v, p0);
					vertices.push(p0.x, p0.y, p0.z); // normal
					// approximate tangent vectors via finite differences

					if (u - EPS >= 0) {
						func(u - EPS, v, p1);
						pu.subVectors(p0, p1);
					} else {
						func(u + EPS, v, p1);
						pu.subVectors(p1, p0);
					}

					if (v - EPS >= 0) {
						func(u, v - EPS, p1);
						pv.subVectors(p0, p1);
					} else {
						func(u, v + EPS, p1);
						pv.subVectors(p1, p0);
					} // cross product of tangent vectors returns surface normal


					normal.crossVectors(pu, pv).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u, v);
				}
			} // generate indices


			for (let i = 0; i < stacks; i++) {
				for (let j = 0; j < slices; j++) {
					const a = i * sliceCount + j;
					const b = i * sliceCount + j + 1;
					const c = (i + 1) * sliceCount + j + 1;
					const d = (i + 1) * sliceCount + j; // faces one and two

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class RingGeometry extends BufferGeometry {
		constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'RingGeometry';
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // some helper variables

			let radius = innerRadius;
			const radiusStep = (outerRadius - innerRadius) / phiSegments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices, normals and uvs

			for (let j = 0; j <= phiSegments; j++) {
				for (let i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, 0, 1); // uv

					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				} // increase the radius for next row of vertices


				radius += radiusStep;
			} // indices


			for (let j = 0; j < phiSegments; j++) {
				const thetaSegmentLevel = j * (thetaSegments + 1);

				for (let i = 0; i < thetaSegments; i++) {
					const segment = i + thetaSegmentLevel;
					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class ShapeGeometry extends BufferGeometry {
		constructor(shapes, curveSegments = 12) {
			super();
			this.type = 'ShapeGeometry';
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let groupStart = 0;
			let groupCount = 0; // allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (let i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);
					this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

			function addShape(shape) {
				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints(curveSegments);
				let shapeVertices = points.shape;
				const shapeHoles = points.holes; // check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];

					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[i] = shapeHole.reverse();
					}
				}

				const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];
					shapeVertices = shapeVertices.concat(shapeHole);
				} // vertices, normals, uvs


				for (let i = 0, l = shapeVertices.length; i < l; i++) {
					const vertex = shapeVertices[i];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				} // incides


				for (let i = 0, l = faces.length; i < l; i++) {
					const face = faces[i];
					const a = face[0] + indexOffset;
					const b = face[1] + indexOffset;
					const c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}
		}

		toJSON() {
			const data = BufferGeometry.prototype.toJSON.call(this);
			const shapes = this.parameters.shapes;
			return toJSON(shapes, data);
		}

	}

	function toJSON(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	class SphereGeometry extends BufferGeometry {
		constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
			super();
			this.type = 'SphereGeometry';
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			let index = 0;
			const grid = [];
			const vertex = new Vector3();
			const normal = new Vector3(); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // generate vertices, normals and uvs

			for (let iy = 0; iy <= heightSegments; iy++) {
				const verticesRow = [];
				const v = iy / heightSegments; // special case for the poles

				let uOffset = 0;

				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}

				for (let ix = 0; ix <= widthSegments; ix++) {
					const u = ix / widthSegments; // vertex

					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}

				grid.push(verticesRow);
			} // indices


			for (let iy = 0; iy < heightSegments; iy++) {
				for (let ix = 0; ix < widthSegments; ix++) {
					const a = grid[iy][ix + 1];
					const b = grid[iy][ix];
					const c = grid[iy + 1][ix];
					const d = grid[iy + 1][ix + 1];
					if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
			const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			super(vertices, indices, radius, detail);
			this.type = 'TetrahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

	}

	/**
	 * Text = 3D Text
	 *
	 * parameters = {
	 *	font: <THREE.Font>, // font
	 *
	 *	size: <float>, // size of the text
	 *	height: <float>, // thickness to extrude text
	 *	curveSegments: <int>, // number of points on the curves
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into text bevel goes
	 *	bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
	 *	bevelOffset: <float> // how far from text outline does bevel start
	 * }
	 */

	class TextGeometry extends ExtrudeGeometry {
		constructor(text, parameters = {}) {
			const font = parameters.font;

			if (!(font && font.isFont)) {
				console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
				return new BufferGeometry();
			}

			const shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

			if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
			if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
			if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
			super(shapes, parameters);
			this.type = 'TextGeometry';
		}

	}

	class TorusGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
			super();
			this.type = 'TorusGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3(); // generate vertices, normals and uvs

			for (let j = 0; j <= radialSegments; j++) {
				for (let i = 0; i <= tubularSegments; i++) {
					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2; // vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= radialSegments; j++) {
				for (let i = 1; i <= tubularSegments; i++) {
					// indices
					const a = (tubularSegments + 1) * j + i - 1;
					const b = (tubularSegments + 1) * (j - 1) + i - 1;
					const c = (tubularSegments + 1) * (j - 1) + i;
					const d = (tubularSegments + 1) * j + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class TorusKnotGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
			super();
			this.type = 'TorusKnotGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const P1 = new Vector3();
			const P2 = new Vector3();
			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3(); // generate vertices, normals and uvs

			for (let i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
				const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for (let j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					const v = j / radialSegments * Math.PI * 2;
					const cx = -tube * Math.cos(v);
					const cy = tube * Math.sin(v); // now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= tubularSegments; j++) {
				for (let i = 1; i <= radialSegments; i++) {
					// indices
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

			function calculatePositionOnCurve(u, p, q, radius, position) {
				const cu = Math.cos(u);
				const su = Math.sin(u);
				const quOverP = q / p * u;
				const cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}
		}

	}

	class TubeGeometry extends BufferGeometry {
		constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
			super();
			this.type = 'TubeGeometry';
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3(); // buffer

			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = []; // create buffer data

			generateBufferData(); // build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

			function generateBufferData() {
				for (let i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				} // if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


				generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs(); // finally create faces

				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

				const N = frames.normals[i];
				const B = frames.binormals[i]; // generate normals and vertices for the current segment

				for (let j = 0; j <= radialSegments; j++) {
					const v = j / radialSegments * Math.PI * 2;
					const sin = Math.sin(v);
					const cos = -Math.cos(v); // normal

					normal.x = cos * N.x + sin * B.x;
					normal.y = cos * N.y + sin * B.y;
					normal.z = cos * N.z + sin * B.z;
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z); // vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (let j = 1; j <= tubularSegments; j++) {
					for (let i = 1; i <= radialSegments; i++) {
						const a = (radialSegments + 1) * (j - 1) + (i - 1);
						const b = (radialSegments + 1) * j + (i - 1);
						const c = (radialSegments + 1) * j + i;
						const d = (radialSegments + 1) * (j - 1) + i; // faces

						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (let i = 0; i <= tubularSegments; i++) {
					for (let j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}
		}

		toJSON() {
			const data = BufferGeometry.prototype.toJSON.call(this);
			data.path = this.parameters.path.toJSON();
			return data;
		}

	}

	class WireframeGeometry extends BufferGeometry {
		constructor(geometry) {
			super();
			this.type = 'WireframeGeometry';

			if (geometry.isGeometry === true) {
				console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return;
			} // buffer


			const vertices = []; // helper variables

			const edge = [0, 0],
						edges = {};
			const vertex = new Vector3();

			if (geometry.index !== null) {
				// indexed BufferGeometry
				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if (groups.length === 0) {
					groups = [{
						start: 0,
						count: indices.count,
						materialIndex: 0
					}];
				} // create a data structure that contains all eges without duplicates


				for (let o = 0, ol = groups.length; o < ol; ++o) {
					const group = groups[o];
					const start = group.start;
					const count = group.count;

					for (let i = start, l = start + count; i < l; i += 3) {
						for (let j = 0; j < 3; j++) {
							const edge1 = indices.getX(i + j);
							const edge2 = indices.getX(i + (j + 1) % 3);
							edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

							edge[1] = Math.max(edge1, edge2);
							const key = edge[0] + ',' + edge[1];

							if (edges[key] === undefined) {
								edges[key] = {
									index1: edge[0],
									index2: edge[1]
								};
							}
						}
					}
				} // generate vertices


				for (const key in edges) {
					const e = edges[key];
					vertex.fromBufferAttribute(position, e.index1);
					vertices.push(vertex.x, vertex.y, vertex.z);
					vertex.fromBufferAttribute(position, e.index2);
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			} else {
				// non-indexed BufferGeometry
				const position = geometry.attributes.position;

				for (let i = 0, l = position.count / 3; i < l; i++) {
					for (let j = 0; j < 3; j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
						const index1 = 3 * i + j;
						vertex.fromBufferAttribute(position, index1);
						vertices.push(vertex.x, vertex.y, vertex.z);
						const index2 = 3 * i + (j + 1) % 3;
						vertex.fromBufferAttribute(position, index2);
						vertices.push(vertex.x, vertex.y, vertex.z);
					}
				}
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}

	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	/**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */

	class ShadowMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShadowMaterial';
			this.color = new Color(0x000000);
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			return this;
		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true;

	class RawShaderMaterial extends ShaderMaterial {
		constructor(parameters) {
			super(parameters);
			this.type = 'RawShaderMaterial';
		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshStandardMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': ''
			};
			this.type = 'MeshStandardMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.roughness = 1.0;
			this.metalness = 0.0;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.roughnessMap = null;
			this.metalnessMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.envMapIntensity = 1.0;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
			this.flatShading = false;
			this.vertexTangents = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': ''
			};
			this.color.copy(source.color);
			this.roughness = source.roughness;
			this.metalness = source.metalness;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.roughnessMap = source.roughnessMap;
			this.metalnessMap = source.metalnessMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			this.flatShading = source.flatShading;
			this.vertexTangents = source.vertexTangents;
			return this;
		}

	}

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	/**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	reflectivity: <float>,
	 *	ior: <float>,
	 *
	 *	sheen: <Color>,
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> )
	 * }
	 */

	class MeshPhysicalMaterial extends MeshStandardMaterial {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.type = 'MeshPhysicalMaterial';
			this.clearcoat = 0.0;
			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2(1, 1);
			this.clearcoatNormalMap = null;
			this.reflectivity = 0.5; // maps to F0 = 0.04

			Object.defineProperty(this, 'ior', {
				get: function () {
					return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
				},
				set: function (ior) {
					this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
				}
			});
			this.sheen = null; // null will disable sheen bsdf

			this.transmission = 0.0;
			this.transmissionMap = null;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
			this.reflectivity = source.reflectivity;

			if (source.sheen) {
				this.sheen = (this.sheen || new Color()).copy(source.sheen);
			} else {
				this.sheen = null;
			}

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;
			return this;
		}

	}

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshPhongMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshPhongMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.specular = new Color(0x111111);
			this.shininess = 30;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.specular.copy(source.specular);
			this.shininess = source.shininess;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	class MeshToonMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'TOON': ''
			};
			this.type = 'MeshToonMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.gradientMap = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.gradientMap = source.gradientMap;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			return this;
		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshNormalMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshNormalMaterial';
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */

	class MeshLambertMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshLambertMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			return this;
		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshMatcapMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'MATCAP': ''
			};
			this.type = 'MeshMatcapMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.matcap = null;
			this.map = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'MATCAP': ''
			};
			this.color.copy(source.color);
			this.matcap = source.matcap;
			this.map = source.map;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */

	class LineDashedMaterial extends LineBasicMaterial {
		constructor(parameters) {
			super();
			this.type = 'LineDashedMaterial';
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
			return this;
		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	const AnimationUtils = {
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function (array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},
		// converts an array to a specific type
		convertArray: function (array, type, forceClone) {
			if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},
		isTypedArray: function (object) {
			return ArrayBuffer.isView(object) && !(object instanceof DataView);
		},
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function (times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			const n = times.length;
			const result = new Array(n);

			for (let i = 0; i !== n; ++i) result[i] = i;

			result.sort(compareTime);
			return result;
		},
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function (values, stride, order) {
			const nValues = values.length;
			const result = new values.constructor(nValues);

			for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				const srcOffset = order[i] * stride;

				for (let j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},
		// function for parsing AOS keyframe formats
		flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
			let i = 1,
					key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			let value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},
		subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
			const clip = sourceClip.clone();
			clip.name = name;
			const tracks = [];

			for (let i = 0; i < clip.tracks.length; ++i) {
				const track = clip.tracks[i];
				const valueSize = track.getValueSize();
				const times = [];
				const values = [];

				for (let j = 0; j < track.times.length; ++j) {
					const frame = track.times[j] * fps;
					if (frame < startFrame || frame >= endFrame) continue;
					times.push(track.times[j]);

					for (let k = 0; k < valueSize; ++k) {
						values.push(track.values[j * valueSize + k]);
					}
				}

				if (times.length === 0) continue;
				track.times = AnimationUtils.convertArray(times, track.times.constructor);
				track.values = AnimationUtils.convertArray(values, track.values.constructor);
				tracks.push(track);
			}

			clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity;

			for (let i = 0; i < clip.tracks.length; ++i) {
				if (minStartTime > clip.tracks[i].times[0]) {
					minStartTime = clip.tracks[i].times[0];
				}
			} // shift all tracks such that clip begins at t=0


			for (let i = 0; i < clip.tracks.length; ++i) {
				clip.tracks[i].shift(-1 * minStartTime);
			}

			clip.resetDuration();
			return clip;
		},
		makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
			if (fps <= 0) fps = 30;
			const numTracks = referenceClip.tracks.length;
			const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

			for (let i = 0; i < numTracks; ++i) {
				const referenceTrack = referenceClip.tracks[i];
				const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

				if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

				const targetTrack = targetClip.tracks.find(function (track) {
					return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
				});
				if (targetTrack === undefined) continue;
				let referenceOffset = 0;
				const referenceValueSize = referenceTrack.getValueSize();

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					referenceOffset = referenceValueSize / 3;
				}

				let targetOffset = 0;
				const targetValueSize = targetTrack.getValueSize();

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					targetOffset = targetValueSize / 3;
				}

				const lastIndex = referenceTrack.times.length - 1;
				let referenceValue; // Find the value to subtract out of the track

				if (referenceTime <= referenceTrack.times[0]) {
					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else if (referenceTime >= referenceTrack.times[lastIndex]) {
					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset;
					const endIndex = startIndex + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else {
					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant();
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					interpolant.evaluate(referenceTime);
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
				} // Conjugate the quaternion


				if (referenceTrackType === 'quaternion') {
					const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
					referenceQuat.toArray(referenceValue);
				} // Subtract the reference value from all of the track values


				const numTimes = targetTrack.times.length;

				for (let j = 0; j < numTimes; ++j) {
					const valueStart = j * targetValueSize + targetOffset;

					if (referenceTrackType === 'quaternion') {
						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
					} else {
						const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

						for (let k = 0; k < valueEnd; ++k) {
							targetTrack.values[valueStart + k] -= referenceValue[k];
						}
					}
				}
			}

			targetClip.blendMode = AdditiveAnimationBlendMode;
			return targetClip;
		}
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	class Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
			this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
			this.settings = null;
			this.DefaultSettings_ = {};
		}

		evaluate(t) {
			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
					t1 = pp[i1],
					t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					let right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (let giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan; // after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the right side of the index


							right = pp.length;
							break linear_scan;
						} //- slower code:
						//-					if ( t < t0 || t0 === undefined ) {


						if (!(t >= t0)) {
							// looping?
							const t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details

								t0 = t1global;
							} // linear reverse scan


							for (let giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the left side of the index


							right = i1;
							i1 = 0;
							break linear_scan;
						} // the interval is valid


						break validate_interval;
					} // linear scan
					// binary search


					while (i1 < right) {
						const mid = i1 + right >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1]; // check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek


				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval


			return this.interpolate_(i1, t0, t, t1);
		}

		getSettings_() {
			return this.settings || this.DefaultSettings_;
		}

		copySampleValue_(index) {
			// copies a sample value to the result buffer
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset = index * stride;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		} // Template methods for derived classes:


		interpolate_()
		/* i1, t0, t, t1 */
		{
			throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
		}

		intervalChanged_()
		/* i1, t0, t1 */
		{// empty
		}

	} // ALIAS DEFINITIONS


	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
			this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
		}

		intervalChanged_(i1, t0, t1) {
			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
					iNext = i1 + 1,
					tPrev = pp[iPrev],
					tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}

			const halfDt = (t1 - t0) * 0.5,
						stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						o1 = i1 * stride,
						o0 = o1 - stride,
						oP = this._offsetPrev,
						oN = this._offsetNext,
						wP = this._weightPrev,
						wN = this._weightNext,
						p = (t - t0) / (t1 - t0),
						pp = p * p,
						ppp = pp * p; // evaluate polynomials

			const sP = -wP * ppp + 2 * wP * pp - wP * p;
			const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp; // combine data linearly

			for (let i = 0; i !== stride; ++i) {
				result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
			}

			return result;
		}

	}

	class LinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset1 = i1 * stride,
						offset0 = offset1 - stride,
						weight1 = (t - t0) / (t1 - t0),
						weight0 = 1 - weight1;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
			}

			return result;
		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1
		/*, t0, t, t1 */
		) {
			return this.copySampleValue_(i1 - 1);
		}

	}

	class KeyframeTrack {
		constructor(name, times, values, interpolation) {
			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
			this.name = name;
			this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
			this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
			this.setInterpolation(interpolation || this.DefaultInterpolation);
		} // Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):


		static toJSON(track) {
			const trackType = track.constructor;
			let json; // derived classes can define a static toJSON method

			if (trackType.toJSON !== this.toJSON) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)
				};
				const interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		}

		InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		setInterpolation(interpolation) {
			let factoryMethod;

			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;

				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;

				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}

			if (factoryMethod === undefined) {
				const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;
			return this;
		}

		getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		}

		getValueSize() {
			return this.values.length / this.times.length;
		} // move all keyframes either forwards or backwards in time


		shift(timeOffset) {
			if (timeOffset !== 0.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)


		scale(timeScale) {
			if (timeScale !== 1.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values


		trim(startTime, endTime) {
			const times = this.times,
						nKeys = times.length;
			let from = 0,
					to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable


		validate() {
			let valid = true;
			const valueSize = this.getValueSize();

			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			const times = this.times,
						values = this.values,
						nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			let prevTime = null;

			for (let i = 0; i !== nKeys; i++) {
				const currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (let i = 0, n = values.length; i !== n; ++i) {
						const value = values[i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		} // removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)


		optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice(this.times),
						values = AnimationUtils.arraySlice(this.values),
						stride = this.getValueSize(),
						smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
						lastIndex = times.length - 1;
			let writeIndex = 1;

			for (let i = 1; i < lastIndex; ++i) {
				let keep = false;
				const time = times[i];
				const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						const offset = i * stride,
									offsetP = offset - stride,
									offsetN = offset + stride;

						for (let j = 0; j !== stride; ++j) {
							const value = values[offset + j];

							if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				} // in-place compaction


				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						const readOffset = i * stride,
									writeOffset = writeIndex * stride;

						for (let j = 0; j !== stride; ++j) {
							values[writeOffset + j] = values[readOffset + j];
						}
					}

					++writeIndex;
				}
			} // flush last keyframe (compaction looks ahead)


			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
					values[writeOffset + j] = values[readOffset + j];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}

			return this;
		}

		clone() {
			const times = AnimationUtils.arraySlice(this.times, 0);
			const values = AnimationUtils.arraySlice(this.values, 0);
			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

			track.createInterpolant = this.createInterpolant;
			return track;
		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */

	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed

	/**
	 * A Track of keyframe values that represent color.
	 */

	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited

	/**
	 * A Track of numeric keyframe values.
	 */

	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						alpha = (t - t0) / (t1 - t0);
			let offset = i1 * stride;

			for (let end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */

	class QuaternionKeyframeTrack extends KeyframeTrack {
		InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */

	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */

	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited

	class AnimationClip {
		constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;
			this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

			if (this.duration < 0) {
				this.resetDuration();
			}
		}

		static parse(json) {
			const tracks = [],
						jsonTracks = json.tracks,
						frameTime = 1.0 / (json.fps || 1.0);

			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			const clip = new this(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		}

		static toJSON(clip) {
			const tracks = [],
						clipTracks = clip.tracks;
			const json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};

			for (let i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		}

		static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for (let i = 0; i < numMorphTargets; i++) {
				let times = [];
				let values = [];
				times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				const order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.

				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
			}

			return new this(name, -1, tracks);
		}

		static findByName(objectOrClipArray, name) {
			let clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (let i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		}

		static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

			const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002

			for (let i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = morphTargets[i];
				const parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					const name = parts[1];
					let animationMorphTargets = animationToMorphTargets[name];

					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			const clips = [];

			for (const name in animationToMorphTargets) {
				clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
			}

			return clips;
		} // parse the animation.hierarchy format


		static parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					const times = [];
					const values = [];
					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			const tracks = [];
			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

			let duration = animation.length || -1;
			const hierarchyTracks = animation.hierarchy || [];

			for (let h = 0; h < hierarchyTracks.length; h++) {
				const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

				if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					const morphTargetNames = {};
					let k;

					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					} // create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.


					for (const morphTargetName in morphTargetNames) {
						const times = [];
						const values = [];

						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							const animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation
					const boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
					addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			const clip = new this(clipName, duration, tracks, blendMode);
			return clip;
		}

		resetDuration() {
			const tracks = this.tracks;
			let duration = 0;

			for (let i = 0, n = tracks.length; i !== n; ++i) {
				const track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;
			return this;
		}

		trim() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		}

		validate() {
			let valid = true;

			for (let i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		}

		optimize() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		}

		clone() {
			const tracks = [];

			for (let i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}

			return new this.constructor(this.name, this.duration, tracks, this.blendMode);
		}

		toJSON() {
			return this.constructor.toJSON(this);
		}

	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;

			case 'color':
				return ColorKeyframeTrack;

			case 'quaternion':
				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;

			case 'string':
				return StringKeyframeTrack;
		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		const trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			const times = [],
						values = [];
			AnimationUtils.flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		} // derived classes can define a static parse method


		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}

	const Cache = {
		enabled: false,
		files: {},
		add: function (key, file) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},
		get: function (key) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},
		remove: function (key) {
			delete this.files[key];
		},
		clear: function () {
			this.files = {};
		}
	};

	class LoadingManager {
		constructor(onLoad, onProgress, onError) {
			const scope = this;
			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function (url) {
				itemsTotal++;

				if (isLoading === false) {
					if (scope.onStart !== undefined) {
						scope.onStart(url, itemsLoaded, itemsTotal);
					}
				}

				isLoading = true;
			};

			this.itemEnd = function (url) {
				itemsLoaded++;

				if (scope.onProgress !== undefined) {
					scope.onProgress(url, itemsLoaded, itemsTotal);
				}

				if (itemsLoaded === itemsTotal) {
					isLoading = false;

					if (scope.onLoad !== undefined) {
						scope.onLoad();
					}
				}
			};

			this.itemError = function (url) {
				if (scope.onError !== undefined) {
					scope.onError(url);
				}
			};

			this.resolveURL = function (url) {
				if (urlModifier) {
					return urlModifier(url);
				}

				return url;
			};

			this.setURLModifier = function (transform) {
				urlModifier = transform;
				return this;
			};

			this.addHandler = function (regex, loader) {
				handlers.push(regex, loader);
				return this;
			};

			this.removeHandler = function (regex) {
				const index = handlers.indexOf(regex);

				if (index !== -1) {
					handlers.splice(index, 2);
				}

				return this;
			};

			this.getHandler = function (file) {
				for (let i = 0, l = handlers.length; i < l; i += 2) {
					const regex = handlers[i];
					const loader = handlers[i + 1];
					if (regex.global) regex.lastIndex = 0; // see #17920

					if (regex.test(file)) {
						return loader;
					}
				}

				return null;
			};
		}

	}

	const DefaultLoadingManager = new LoadingManager();

	class Loader {
		constructor(manager) {
			this.manager = manager !== undefined ? manager : DefaultLoadingManager;
			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};
		}

		load()
		/* url, onLoad, onProgress, onError */
		{}

		loadAsync(url, onProgress) {
			const scope = this;
			return new Promise(function (resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		}

		parse()
		/* data */
		{}

		setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		}

		setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		}

		setPath(path) {
			this.path = path;
			return this;
		}

		setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		}

		setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		}

	}

	const loading = {};

	class FileLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			} // Check if request is duplicate


			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			} // Check for data: URI


			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			const dataUriRegexResult = url.match(dataUriRegex);
			let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

			if (dataUriRegexResult) {
				const mimeType = dataUriRegexResult[1];
				const isBase64 = !!dataUriRegexResult[2];
				let data = dataUriRegexResult[3];
				data = decodeURIComponent(data);
				if (isBase64) data = atob(data);

				try {
					let response;
					const responseType = (this.responseType || '').toLowerCase();

					switch (responseType) {
						case 'arraybuffer':
						case 'blob':
							const view = new Uint8Array(data.length);

							for (let i = 0; i < data.length; i++) {
								view[i] = data.charCodeAt(i);
							}

							if (responseType === 'blob') {
								response = new Blob([view.buffer], {
									type: mimeType
								});
							} else {
								response = view.buffer;
							}

							break;

						case 'document':
							const parser = new DOMParser();
							response = parser.parseFromString(data, mimeType);
							break;

						case 'json':
							response = JSON.parse(data);
							break;

						default:
							// 'text' or other
							response = data;
							break;
					} // Wait for next browser tick like standard XMLHttpRequest event dispatching does


					setTimeout(function () {
						if (onLoad) onLoad(response);
						scope.manager.itemEnd(url);
					}, 0);
				} catch (error) {
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {
						if (onError) onError(error);
						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}, 0);
				}
			} else {
				// Initialise array for duplicate requests
				loading[url] = [];
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				request = new XMLHttpRequest();
				request.open('GET', url, true);
				request.addEventListener('load', function (event) {
					const response = this.response;
					const callbacks = loading[url];
					delete loading[url];

					if (this.status === 200 || this.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.

						Cache.add(url, response);

						for (let i = 0, il = callbacks.length; i < il; i++) {
							const callback = callbacks[i];
							if (callback.onLoad) callback.onLoad(response);
						}

						scope.manager.itemEnd(url);
					} else {
						for (let i = 0, il = callbacks.length; i < il; i++) {
							const callback = callbacks[i];
							if (callback.onError) callback.onError(event);
						}

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}
				}, false);
				request.addEventListener('progress', function (event) {
					const callbacks = loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onProgress) callback.onProgress(event);
					}
				}, false);
				request.addEventListener('error', function (event) {
					const callbacks = loading[url];
					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				request.addEventListener('abort', function (event) {
					const callbacks = loading[url];
					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				if (this.responseType !== undefined) request.responseType = this.responseType;
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

				for (const header in this.requestHeader) {
					request.setRequestHeader(header, this.requestHeader[header]);
				}

				request.send(null);
			}

			scope.manager.itemStart(url);
			return request;
		}

		setResponseType(value) {
			this.responseType = value;
			return this;
		}

		setMimeType(value) {
			this.mimeType = value;
			return this;
		}

	}

	class AnimationLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const animations = [];

			for (let i = 0; i < json.length; i++) {
				const clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}

			return animations;
		}

	}

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class CompressedTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const images = [];
			const texture = new CompressedTexture();
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function (buffer) {
					const texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				for (let i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function (buffer) {
					const texDatas = scope.parse(buffer, true);

					if (texDatas.isCubemap) {
						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (let f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};

							for (let i = 0; i < texDatas.mipmapCount; i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}

						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		}

	}

	class ImageLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

			function onImageLoad() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);
			image.src = url;
			return image;
		}

	}

	class CubeTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(urls, onLoad, onProgress, onError) {
			const texture = new CubeTexture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function (image) {
					texture.images[i] = image;
					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (let i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		}

	}

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class DataTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const texture = new DataTexture();
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				const texData = scope.parse(buffer);
				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}

				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}

				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				if (texData.generateMipmaps !== undefined) {
					texture.generateMipmaps = texData.generateMipmaps;
				}

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		}

	}

	class TextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const texture = new Texture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {
				texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

				const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {
		constructor() {
			this.type = 'Curve';
			this.arcLengthDivisions = 200;
		} // Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]


		getPoint()
		/* t, optionalTarget */
		{
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		} // Get point at relative position in curve according to arc length
		// - u [0 .. 1]


		getPointAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		} // Get sequence of points using getPoint( t )


		getPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		} // Get sequence of points using getPointAt( u )


		getSpacedPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		} // Get total curve arc length


		getLength() {
			const lengths = this.getLengths();
			return lengths[lengths.length - 1];
		} // Get list of cumulative segment lengths


		getLengths(divisions = this.arcLengthDivisions) {
			if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;
			const cache = [];
			let current,
					last = this.getPoint(0);
			let sum = 0;
			cache.push(0);

			for (let p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		}

		updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


		getUtoTmapping(u, distance) {
			const arcLengths = this.getLengths();
			let i = 0;
			const il = arcLengths.length;
			let targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			} // binary search for the index with largest value smaller than target u distance


			let low = 0,
					high = il - 1,
					comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break; // DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			} // we could get finer grain at lengths, or use simple interpolation between two points


			const lengthBefore = arcLengths[i];
			const lengthAfter = arcLengths[i + 1];
			const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

			const t = (i + segmentFraction) / (il - 1);
			return t;
		} // Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation


		getTangent(t, optionalTarget) {
			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta; // Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			const pt1 = this.getPoint(t1);
			const pt2 = this.getPoint(t2);
			const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		}

		getTangentAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		}

		computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			const normal = new Vector3();
			const tangents = [];
			const normals = [];
			const binormals = [];
			const vec = new Vector3();
			const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

			for (let i = 0; i <= segments; i++) {
				const u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
				tangents[i].normalize();
			} // select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component


			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs(tangents[0].x);
			const ty = Math.abs(tangents[0].y);
			const tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (let i = 1; i <= segments; i++) {
				normals[i] = normals[i - 1].clone();
				binormals[i] = binormals[i - 1].clone();
				vec.crossVectors(tangents[i - 1], tangents[i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[i].crossVectors(tangents[i], normals[i]);
			} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


			if (closed === true) {
				let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
				theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					theta = -theta;
				}

				for (let i = 1; i <= segments; i++) {
					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
					binormals[i].crossVectors(tangents[i], normals[i]);
				}
			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		}

		fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		}

	}

	class EllipseCurve extends Curve {
		constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
			super();
			this.type = 'EllipseCurve';
			this.aX = aX;
			this.aY = aY;
			this.xRadius = xRadius;
			this.yRadius = yRadius;
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
			this.aClockwise = aClockwise;
			this.aRotation = aRotation;
		}

		getPoint(t, optionalTarget) {
			const point = optionalTarget || new Vector2();
			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

			while (deltaAngle < 0) deltaAngle += twoPi;

			while (deltaAngle > twoPi) deltaAngle -= twoPi;

			if (deltaAngle < Number.EPSILON) {
				if (samePoints) {
					deltaAngle = 0;
				} else {
					deltaAngle = twoPi;
				}
			}

			if (this.aClockwise === true && !samePoints) {
				if (deltaAngle === twoPi) {
					deltaAngle = -twoPi;
				} else {
					deltaAngle = deltaAngle - twoPi;
				}
			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos(angle);
			let y = this.aY + this.yRadius * Math.sin(angle);

			if (this.aRotation !== 0) {
				const cos = Math.cos(this.aRotation);
				const sin = Math.sin(this.aRotation);
				const tx = x - this.aX;
				const ty = y - this.aY; // Rotate the point about the center of the ellipse.

				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
			}

			return point.set(x, y);
		}

		copy(source) {
			super.copy(source);
			this.aX = source.aX;
			this.aY = source.aY;
			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;
			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;
			this.aClockwise = source.aClockwise;
			this.aRotation = source.aRotation;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.aX = this.aX;
			data.aY = this.aY;
			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;
			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;
			data.aClockwise = this.aClockwise;
			data.aRotation = this.aRotation;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.aX = json.aX;
			this.aY = json.aY;
			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;
			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;
			this.aClockwise = json.aClockwise;
			this.aRotation = json.aRotation;
			return this;
		}

	}

	EllipseCurve.prototype.isEllipseCurve = true;

	class ArcCurve extends EllipseCurve {
		constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			this.type = 'ArcCurve';
		}

	}

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		let c0 = 0,
				c1 = 0,
				c2 = 0,
				c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */

		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {
			initCatmullRom: function (x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function (t) {
				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	} //


	const tmp = new Vector3();
	const px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();

	class CatmullRomCurve3 extends Curve {
		constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
			super();
			this.type = 'CatmullRomCurve3';
			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const points = this.points;
			const l = points.length;
			const p = (l - (this.closed ? 0 : 1)) * t;
			let intPoint = Math.floor(p);
			let weight = p - intPoint;

			if (this.closed) {
				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
			} else if (weight === 0 && intPoint === l - 1) {
				intPoint = l - 2;
				weight = 1;
			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if (this.closed || intPoint > 0) {
				p0 = points[(intPoint - 1) % l];
			} else {
				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0]);
				p0 = tmp;
			}

			const p1 = points[intPoint % l];
			const p2 = points[(intPoint + 1) % l];

			if (this.closed || intPoint + 2 < l) {
				p3 = points[(intPoint + 2) % l];
			} else {
				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
				p3 = tmp;
			}

			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
				let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
				let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

				if (dt1 < 1e-4) dt1 = 1.0;
				if (dt0 < 1e-4) dt0 = dt1;
				if (dt2 < 1e-4) dt2 = dt1;
				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
			} else if (this.curveType === 'catmullrom') {
				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
			}

			point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector3().fromArray(point));
			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;
			return this;
		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		const v0 = (p2 - p0) * 0.5;
		const v1 = (p3 - p1) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	} //


	function QuadraticBezierP0(t, p) {
		const k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	} //


	function CubicBezierP0(t, p) {
		const k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		const k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}

	class CubicBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
			super();
			this.type = 'CubicBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	class CubicBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
			super();
			this.type = 'CubicBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	class LineCurve extends Curve {
		constructor(v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'LineCurve';
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		getTangent(t, optionalTarget) {
			const tangent = optionalTarget || new Vector2();
			tangent.copy(this.v2).sub(this.v1).normalize();
			return tangent;
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	LineCurve.prototype.isLineCurve = true;

	class LineCurve3 extends Curve {
		constructor(v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'LineCurve3';
			this.isLineCurve3 = true;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	class QuadraticBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'QuadraticBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	class QuadraticBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'QuadraticBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	class SplineCurve extends Curve {
		constructor(points = []) {
			super();
			this.type = 'SplineCurve';
			this.points = points;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const points = this.points;
			const p = (points.length - 1) * t;
			const intPoint = Math.floor(p);
			const weight = p - intPoint;
			const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
			const p1 = points[intPoint];
			const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
			point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector2().fromArray(point));
			}

			return this;
		}

	}

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {
		constructor() {
			super();
			this.type = 'CurvePath';
			this.curves = [];
			this.autoClose = false; // Automatically closes the path
		}

		add(curve) {
			this.curves.push(curve);
		}

		closePath() {
			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0);
			const endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		} // To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')


		getPoint(t) {
			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0; // To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					const diff = curveLengths[i] - d;
					const curve = this.curves[i];
					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u);
				}

				i++;
			}

			return null; // loop where sum != 0, sum > d , sum+1 <d
		} // We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength


		getLength() {
			const lens = this.getCurveLengths();
			return lens[lens.length - 1];
		} // cacheLengths must be recalculated.


		updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		} // Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.


		getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			} // Get length of sub-curve
			// Push sums into cached array


			const lengths = [];
			let sums = 0;

			for (let i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;
			return lengths;
		}

		getSpacedPoints(divisions = 40) {
			const points = [];

			for (let i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		}

		getPoints(divisions = 12) {
			const points = [];
			let last;

			for (let i = 0, curves = this.curves; i < curves.length; i++) {
				const curve = curves[i];
				const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
				const pts = curve.getPoints(resolution);

				for (let j = 0; j < pts.length; j++) {
					const point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		}

		copy(source) {
			super.copy(source);
			this.curves = [];

			for (let i = 0, l = source.curves.length; i < l; i++) {
				const curve = source.curves[i];
				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.autoClose = this.autoClose;
			data.curves = [];

			for (let i = 0, l = this.curves.length; i < l; i++) {
				const curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.autoClose = json.autoClose;
			this.curves = [];

			for (let i = 0, l = json.curves.length; i < l; i++) {
				const curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		}

	}

	class Path extends CurvePath {
		constructor(points) {
			super();
			this.type = 'Path';
			this.currentPoint = new Vector2();

			if (points) {
				this.setFromPoints(points);
			}
		}

		setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (let i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}

			return this;
		}

		moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

			return this;
		}

		lineTo(x, y) {
			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		splineThru(pts
		/*Array of Vector*/
		) {
			const npts = [this.currentPoint.clone()].concat(pts);
			const curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		}

		arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		}

		absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);
			const lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		}

		copy(source) {
			super.copy(source);
			this.currentPoint.copy(source.currentPoint);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.currentPoint = this.currentPoint.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.currentPoint.fromArray(json.currentPoint);
			return this;
		}

	}

	class Shape extends Path {
		constructor(points) {
			super(points);
			this.uuid = generateUUID();
			this.type = 'Shape';
			this.holes = [];
		}

		getPointsHoles(divisions) {
			const holesPts = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		} // get points of shape and holes (keypoints based on segments parameter)


		extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		}

		copy(source) {
			super.copy(source);
			this.holes = [];

			for (let i = 0, l = source.holes.length; i < l; i++) {
				const hole = source.holes[i];
				this.holes.push(hole.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.uuid = this.uuid;
			data.holes = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				const hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.uuid = json.uuid;
			this.holes = [];

			for (let i = 0, l = json.holes.length; i < l; i++) {
				const hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		}

	}

	class Light extends Object3D {
		constructor(color, intensity = 1) {
			super();
			this.type = 'Light';
			this.color = new Color(color);
			this.intensity = intensity;
		}

		dispose() {// Empty here in base class; some subclasses override.
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		}

	}

	Light.prototype.isLight = true;

	class HemisphereLight extends Light {
		constructor(skyColor, groundColor, intensity) {
			super(skyColor, intensity);
			this.type = 'HemisphereLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.groundColor = new Color(groundColor);
		}

		copy(source) {
			Light.prototype.copy.call(this, source);
			this.groundColor.copy(source.groundColor);
			return this;
		}

	}

	HemisphereLight.prototype.isHemisphereLight = true;

	const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

	const _lookTarget$1 = /*@__PURE__*/new Vector3();

	class LightShadow {
		constructor(camera) {
			this.camera = camera;
			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.mapSize = new Vector2(512, 512);
			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();
			this.autoUpdate = true;
			this.needsUpdate = false;
			this._frustum = new Frustum();
			this._frameExtents = new Vector2(1, 1);
			this._viewportCount = 1;
			this._viewports = [new Vector4(0, 0, 1, 1)];
		}

		getViewportCount() {
			return this._viewportCount;
		}

		getFrustum() {
			return this._frustum;
		}

		updateMatrices(light) {
			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

			shadowCamera.position.copy(_lightPositionWorld$1);

			_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);

			shadowCamera.lookAt(_lookTarget$1);
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);

			shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			shadowMatrix.multiply(shadowCamera.projectionMatrix);
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
		}

		getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		}

		getFrameExtents() {
			return this._frameExtents;
		}

		dispose() {
			if (this.map) {
				this.map.dispose();
			}

			if (this.mapPass) {
				this.mapPass.dispose();
			}
		}

		copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		}

	}

	class SpotLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(50, 1, 0.5, 500));
			this.focus = 1;
		}

		updateMatrices(light) {
			const camera = this.camera;
			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			super.updateMatrices(light);
		}

		copy(source) {
			super.copy(source);
			this.focus = source.focus;
			return this;
		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true;

	class SpotLight extends Light {
		constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
			super(color, intensity);
			this.type = 'SpotLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();
		}

		get power() {
			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;
		}

		set power(power) {
			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	SpotLight.prototype.isSpotLight = true;

	const _projScreenMatrix = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld = /*@__PURE__*/new Vector3();

	const _lookTarget = /*@__PURE__*/new Vector3();

	class PointLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(90, 1, 0.5, 500));
			this._frameExtents = new Vector2(4, 2);
			this._viewportCount = 6;
			this._viewports = [// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//	xzXZ
			//	 y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction
			// positive X
			new Vector4(2, 1, 1, 1), // negative X
			new Vector4(0, 1, 1, 1), // positive Z
			new Vector4(3, 1, 1, 1), // negative Z
			new Vector4(1, 1, 1, 1), // positive Y
			new Vector4(3, 0, 1, 1), // negative Y
			new Vector4(1, 0, 1, 1)];
			this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
			this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
		}

		updateMatrices(light, viewportIndex = 0) {
			const camera = this.camera;
			const shadowMatrix = this.matrix;
			const far = light.distance || camera.far;

			if (far !== camera.far) {
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

			camera.position.copy(_lightPositionWorld);

			_lookTarget.copy(camera.position);

			_lookTarget.add(this._cubeDirections[viewportIndex]);

			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(_lookTarget);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix);
		}

	}

	PointLightShadow.prototype.isPointLightShadow = true;

	class PointLight extends Light {
		constructor(color, intensity, distance = 0, decay = 1) {
			super(color, intensity);
			this.type = 'PointLight';
			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();
		}

		get power() {
			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;
		}

		set power(power) {
			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / (4 * Math.PI);
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	PointLight.prototype.isPointLight = true;

	class OrthographicCamera extends Camera {
		constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
			super();
			this.type = 'OrthographicCamera';
			this.zoom = 1;
			this.view = null;
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			this.near = near;
			this.far = far;
			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		}

		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const dx = (this.right - this.left) / (2 * this.zoom);
			const dy = (this.top - this.bottom) / (2 * this.zoom);
			const cx = (this.right + this.left) / 2;
			const cy = (this.top + this.bottom) / 2;
			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true;

	class DirectionalLightShadow extends LightShadow {
		constructor() {
			super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	class DirectionalLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'DirectionalLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.shadow = new DirectionalLightShadow();
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	DirectionalLight.prototype.isDirectionalLight = true;

	class AmbientLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'AmbientLight';
		}

	}

	AmbientLight.prototype.isAmbientLight = true;

	class RectAreaLight extends Light {
		constructor(color, intensity, width = 10, height = 10) {
			super(color, intensity);
			this.type = 'RectAreaLight';
			this.width = width;
			this.height = height;
		}

		copy(source) {
			super.copy(source);
			this.width = source.width;
			this.height = source.height;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		}

	}

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {
		constructor() {
			this.coefficients = [];

			for (let i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}

		set(coefficients) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}

			return this;
		}

		zero() {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}

			return this;
		} // get the radiance in the direction of the normal
		// target is a Vector3


		getAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x); // band 2

			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf


		getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
			// band 1

			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

			return target;
		}

		add(sh) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}

			return this;
		}

		addScaledSH(sh, s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}

			return this;
		}

		scale(s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}

			return this;
		}

		lerp(sh, alpha) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}

			return this;
		}

		equals(sh) {
			for (let i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}

			return true;
		}

		copy(sh) {
			return this.set(sh.coefficients);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		fromArray(array, offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + i * 3);
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + i * 3);
			}

			return array;
		} // evaluate the basis functions
		// shBasis is an Array[ 9 ]


		static getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z; // band 0

			shBasis[0] = 0.282095; // band 1

			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x; // band 2

			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	class LightProbe extends Light {
		constructor(sh = new SphericalHarmonics3(), intensity = 1) {
			super(undefined, intensity);
			this.sh = sh;
		}

		copy(source) {
			super.copy(source);
			this.sh.copy(source.sh);
			return this;
		}

		fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

			this.sh.fromArray(json.sh);
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.sh = this.sh.toArray();
			return data;
		}

	}

	LightProbe.prototype.isLightProbe = true;

	class MaterialLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.textures = {};
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			const material = new Materials[json.type]();
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.skinning !== undefined) material.skinning = json.skinning;
			if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
			if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
			if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;

			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = json.vertexColors > 0 ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			} // Shader Material


			if (json.uniforms !== undefined) {
				for (const name in json.uniforms) {
					const uniform = json.uniforms[name];
					material.uniforms[name] = {};

					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;

						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (const key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			} // Deprecated


			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

			if (json.normalScale !== undefined) {
				let normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			return material;
		}

		setTextures(value) {
			this.textures = value;
			return this;
		}

	}

	class LoaderUtils {
		static decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			} // Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.


			let s = '';

			for (let i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) {
				// see #16358
				return s;
			}
		}

		static extractUrlBase(url) {
			const index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.substr(0, index + 1);
		}

	}

	class InstancedBufferGeometry extends BufferGeometry {
		constructor() {
			super();
			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;
		}

		copy(source) {
			super.copy(source);
			this.instanceCount = source.instanceCount;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const data = super.toJSON(this);
			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		}

	}

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

	class InstancedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized, meshPerAttribute) {
			if (typeof normalized === 'number') {
				meshPerAttribute = normalized;
				normalized = false;
				console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
			}

			super(array, itemSize, normalized);
			this.meshPerAttribute = meshPerAttribute || 1;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		}

	}

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

	class BufferGeometryLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[uuid];
				const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				const array = getTypedArray(interleavedBuffer.type, buffer);
				const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[uuid];
				const ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			const index = json.data.index;

			if (index !== undefined) {
				const typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			const attributes = json.data.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				let bufferAttribute;

				if (attribute.isInterleavedBufferAttribute) {
					const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					const typedArray = getTypedArray(attribute.type, attribute.array);
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

				if (attribute.updateRange !== undefined) {
					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;
				}

				geometry.setAttribute(key, bufferAttribute);
			}

			const morphAttributes = json.data.morphAttributes;

			if (morphAttributes) {
				for (const key in morphAttributes) {
					const attributeArray = morphAttributes[key];
					const array = [];

					for (let i = 0, il = attributeArray.length; i < il; i++) {
						const attribute = attributeArray[i];
						let bufferAttribute;

						if (attribute.isInterleavedBufferAttribute) {
							const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
							bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
						} else {
							const typedArray = getTypedArray(attribute.type, attribute.array);
							bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
						}

						if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
						array.push(bufferAttribute);
					}

					geometry.morphAttributes[key] = array;
				}
			}

			const morphTargetsRelative = json.data.morphTargetsRelative;

			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (let i = 0, n = groups.length; i !== n; ++i) {
					const group = groups[i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			const boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {
				const center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		}

	}

	class ObjectLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				let json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}

				const metadata = json.metadata;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		}

		parse(json, onLoad) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = this.parseImages(json.images, function () {
				if (onLoad !== undefined) onLoad(object);
			});
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons); //

			if (onLoad !== undefined) {
				let hasImages = false;

				for (const uuid in images) {
					if (images[uuid] instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}

				if (hasImages === false) onLoad(object);
			}

			return object;
		}

		parseShapes(json) {
			const shapes = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		}

		parseSkeletons(json, object) {
			const skeletons = {};
			const bones = {}; // generate bone lookup table

			object.traverse(function (child) {
				if (child.isBone) bones[child.uuid] = child;
			}); // create skeletons

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}

			return skeletons;
		}

		parseGeometries(json, shapes) {
			const geometries = {};
			let geometryShapes;

			if (json !== undefined) {
				const bufferGeometryLoader = new BufferGeometryLoader();

				for (let i = 0, l = json.length; i < l; i++) {
					let geometry;
					const data = json[i];

					switch (data.type) {
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
							geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
							geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':
							geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.detail);
							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':
							geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':
							geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
							break;

						case 'TubeGeometry':
						case 'TubeBufferGeometry':
							// This only works for built-in curves (e.g. CatmullRomCurve3).
							// User defined curves or instances of CurvePath will not be deserialized.
							geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':
							geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':
							geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':
							geometryShapes = [];

							for (let j = 0, jl = data.shapes.length; j < jl; j++) {
								const shape = shapes[data.shapes[j]];
								geometryShapes.push(shape);
							}

							geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
							break;

						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':
							geometryShapes = [];

							for (let j = 0, jl = data.shapes.length; j < jl; j++) {
								const shape = shapes[data.shapes[j]];
								geometryShapes.push(shape);
							}

							const extrudePath = data.options.extrudePath;

							if (extrudePath !== undefined) {
								data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
							}

							geometry = new Geometries[data.type](geometryShapes, data.options);
							break;

						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;

						case 'Geometry':
							console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
							break;

						default:
							console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
							continue;
					}

					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		}

		parseMaterials(json, textures) {
			const cache = {}; // MultiMaterial

			const materials = {};

			if (json !== undefined) {
				const loader = new MaterialLoader();
				loader.setTextures(textures);

				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated
						const array = [];

						for (let j = 0; j < data.materials.length; j++) {
							const material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						if (cache[data.uuid] === undefined) {
							cache[data.uuid] = loader.parse(data);
						}

						materials[data.uuid] = cache[data.uuid];
					}
				}
			}

			return materials;
		}

		parseAnimations(json) {
			const animations = {};

			if (json !== undefined) {
				for (let i = 0; i < json.length; i++) {
					const data = json[i];
					const clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}

			return animations;
		}

		parseImages(json, onLoad) {
			const scope = this;
			const images = {};
			let loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				}, undefined, function () {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				const manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}

			const textures = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					let texture;
					const image = images[data.image];

					if (Array.isArray(image)) {
						texture = new CubeTexture(image);
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture(image.data, image.width, image.height);
						} else {
							texture = new Texture(image);
						}

						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}

					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					textures[data.uuid] = texture;
				}
			}

			return textures;
		}

		parseObject(data, geometries, materials, animations) {
			let object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					const array = [];

					for (let i = 0, l = name.length; i < l; i++) {
						const uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			let geometry, material;

			switch (data.type) {
				case 'Scene':
					object = new Scene();

					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						}
					}

					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}

					break;

				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;

				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;

				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;

				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;

				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;
					const instanceColor = data.instanceColor;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
					if (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
					break;

				case 'LOD':
					object = new LOD();
					break;

				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;

				case 'Group':
					object = new Group();
					break;

				case 'Bone':
					object = new Bone();
					break;

				default:
					object = new Object3D();
			}

			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				const children = data.children;

				for (let i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, animations));
				}
			}

			if (data.animations !== undefined) {
				const objectAnimations = data.animations;

				for (let i = 0; i < objectAnimations.length; i++) {
					const uuid = objectAnimations[i];
					object.animations.push(animations[uuid]);
				}
			}

			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				const levels = data.levels;

				for (let l = 0; l < levels.length; l++) {
					const level = levels[l];
					const child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		}

		bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function (child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					const skeleton = skeletons[child.skeleton];

					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
		/* DEPRECATED */


		setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	class ImageBitmapLoader extends Loader {
		constructor(manager) {
			super(manager);

			if (typeof createImageBitmap === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
			}

			if (typeof fetch === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
			}

			this.options = {
				premultiplyAlpha: 'none'
			};
		}

		setOptions(options) {
			this.options = options;
			return this;
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const fetchOptions = {};
			fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;
			fetch(url, fetchOptions).then(function (res) {
				return res.blob();
			}).then(function (blob) {
				return createImageBitmap(blob, Object.assign(scope.options, {
					colorSpaceConversion: 'none'
				}));
			}).then(function (imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function (e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		}

	}

	ImageBitmapLoader.prototype.isImageBitmapLoader = true;

	class ShapePath {
		constructor() {
			this.type = 'ShapePath';
			this.color = new Color();
			this.subPaths = [];
			this.currentPath = null;
		}

		moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		}

		lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		}

		splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		}

		toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				const shapes = [];

				for (let i = 0, l = inSubpaths.length; i < l; i++) {
					const tmpPath = inSubpaths[i];
					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push(tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				const polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
				// toggling of inside/outside at every single! intersection point of an edge
				//	with the horizontal line through inPt, left of inPt
				//	not counting lowerY endpoints of edges and whole edges on that line

				let inside = false;

				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					let edgeLowPt = inPolygon[p];
					let edgeHighPt = inPolygon[q];
					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}

						if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?

							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt

						if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
						// continue;
					}
				}

				return inside;
			}

			const isClockWise = ShapeUtils.isClockWise;
			const subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			if (noHoles === true) return toShapesNoHoles(subPaths);
			let solid, tmpPath, tmpShape;
			const shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			let holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (let i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if (!holesFirst && newShapes[mainIdx]) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = []; //console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					}); //console.log('ccw', i);
				}
			} // only Holes? -> probably all Shapes with wrong orientation


			if (!newShapes[0]) return toShapesNoHoles(subPaths);

			if (newShapes.length > 1) {
				let ambiguous = false;
				const toChange = [];

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					const sho = newShapeHoles[sIdx];

					for (let hIdx = 0; hIdx < sho.length; hIdx++) {
						const ho = sho[hIdx];
						let hole_unassigned = true;

						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (sIdx !== s2Idx) toChange.push({
									froms: sIdx,
									tos: s2Idx,
									hole: hIdx
								});

								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}

						if (hole_unassigned) {
							betterShapeHoles[sIdx].push(ho);
						}
					}
				} // console.log("ambiguous: ", ambiguous);


				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;
				}
			}

			let tmpHoles;

			for (let i = 0, il = newShapes.length; i < il; i++) {
				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];

				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			} //console.log("shape", shapes);


			return shapes;
		}

	}

	class Font {
		constructor(data) {
			this.type = 'Font';
			this.data = data;
		}

		generateShapes(text, size = 100) {
			const shapes = [];
			const paths = createPaths(text, size, this.data);

			for (let p = 0, pl = paths.length; p < pl; p++) {
				Array.prototype.push.apply(shapes, paths[p].toShapes());
			}

			return shapes;
		}

	}

	function createPaths(text, size, data) {
		const chars = Array.from(text);
		const scale = size / data.resolution;
		const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
		const paths = [];
		let offsetX = 0,
				offsetY = 0;

		for (let i = 0; i < chars.length; i++) {
			const char = chars[i];

			if (char === '\n') {
				offsetX = 0;
				offsetY -= line_height;
			} else {
				const ret = createPath(char, scale, offsetX, offsetY, data);
				offsetX += ret.offsetX;
				paths.push(ret.path);
			}
		}

		return paths;
	}

	function createPath(char, scale, offsetX, offsetY, data) {
		const glyph = data.glyphs[char] || data.glyphs['?'];

		if (!glyph) {
			console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
			return;
		}

		const path = new ShapePath();
		let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if (glyph.o) {
			const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

			for (let i = 0, l = outline.length; i < l;) {
				const action = outline[i++];

				switch (action) {
					case 'm':
						// moveTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.moveTo(x, y);
						break;

					case 'l':
						// lineTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.lineTo(x, y);
						break;

					case 'q':
						// quadraticCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
						break;

					case 'b':
						// bezierCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						cpx2 = outline[i++] * scale + offsetX;
						cpy2 = outline[i++] * scale + offsetY;
						path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
						break;
				}
			}
		}

		return {
			offsetX: glyph.ha * scale,
			path: path
		};
	}

	Font.prototype.isFont = true;

	class FontLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				let json;

				try {
					json = JSON.parse(text);
				} catch (e) {
					console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
					json = JSON.parse(text.substring(65, text.length - 2));
				}

				const font = scope.parse(json);
				if (onLoad) onLoad(font);
			}, onProgress, onError);
		}

		parse(json) {
			return new Font(json);
		}

	}

	let _context;

	const AudioContext = {
		getContext: function () {
			if (_context === undefined) {
				_context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return _context;
		},
		setContext: function (value) {
			_context = value;
		}
	};

	class AudioLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice(0);
					const context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function (audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

	}

	class HemisphereLightProbe extends LightProbe {
		constructor(skyColor, groundColor, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(skyColor);
			const color2 = new Color().set(groundColor);
			const sky = new Vector3(color1.r, color1.g, color1.b);
			const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

			const c0 = Math.sqrt(Math.PI);
			const c1 = c0 * Math.sqrt(0.75);
			this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
			this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
		}

	}

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

	class AmbientLightProbe extends LightProbe {
		constructor(color, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

			this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
		}

	}

	AmbientLightProbe.prototype.isAmbientLightProbe = true;

	const _eyeRight = /*@__PURE__*/new Matrix4();

	const _eyeLeft = /*@__PURE__*/new Matrix4();

	class StereoCamera {
		constructor() {
			this.type = 'StereoCamera';
			this.aspect = 1;
			this.eyeSep = 0.064;
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable(1);
			this.cameraL.matrixAutoUpdate = false;
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable(2);
			this.cameraR.matrixAutoUpdate = false;
			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};
		}

		update(camera) {
			const cache = this._cache;
			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				const projectionMatrix = camera.projectionMatrix.clone();
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
				let xmin, xmax; // translate xOffset

				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf; // for left eye

				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(projectionMatrix);
			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		}

	}

	class Clock {
		constructor(autoStart = true) {
			this.autoStart = autoStart;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}

		start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		}

		stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		}

		getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		}

		getDelta() {
			let diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				const newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}

			return diff;
		}

	}

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}

	const _position$1 = /*@__PURE__*/new Vector3();

	const _quaternion$1 = /*@__PURE__*/new Quaternion();

	const _scale$1 = /*@__PURE__*/new Vector3();

	const _orientation$1 = /*@__PURE__*/new Vector3();

	class AudioListener extends Object3D {
		constructor() {
			super();
			this.type = 'AudioListener';
			this.context = AudioContext.getContext();
			this.gain = this.context.createGain();
			this.gain.connect(this.context.destination);
			this.filter = null;
			this.timeDelta = 0; // private

			this._clock = new Clock();
		}

		getInput() {
			return this.gain;
		}

		removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		}

		getFilter() {
			return this.filter;
		}

		setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		}

		getMasterVolume() {
			return this.gain.gain.value;
		}

		setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			const listener = this.context.listener;
			const up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);

			_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);

			if (listener.positionX) {
				// code path for Chrome (see #14393)
				const endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
				listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
			}
		}

	}

	class Audio extends Object3D {
		constructor(listener) {
			super();
			this.type = 'Audio';
			this.listener = listener;
			this.context = listener.context;
			this.gain = this.context.createGain();
			this.gain.connect(listener.getInput());
			this.autoplay = false;
			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';
			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;
			this.filters = [];
		}

		getOutput() {
			return this.gain;
		}

		setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		}

		setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		}

		setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		}

		setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		}

		play(delay = 0) {
			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._startedAt = this.context.currentTime + delay;
			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		}

		pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}

			return this;
		}

		stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._progress = 0;
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
			return this;
		}

		connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			this._connected = true;
			return this;
		}

		disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			this._connected = false;
			return this;
		}

		getFilters() {
			return this.filters;
		}

		setFilters(value) {
			if (!value) value = [];

			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}

			return this;
		}

		setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		}

		getDetune() {
			return this.detune;
		}

		getFilter() {
			return this.getFilters()[0];
		}

		setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		}

		setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		}

		getPlaybackRate() {
			return this.playbackRate;
		}

		onEnded() {
			this.isPlaying = false;
		}

		getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		}

		setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		}

		setLoopStart(value) {
			this.loopStart = value;
			return this;
		}

		setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		}

		getVolume() {
			return this.gain.gain.value;
		}

		setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

	}

	const _position = /*@__PURE__*/new Vector3();

	const _quaternion = /*@__PURE__*/new Quaternion();

	const _scale = /*@__PURE__*/new Vector3();

	const _orientation = /*@__PURE__*/new Vector3();

	class PositionalAudio extends Audio {
		constructor(listener) {
			super(listener);
			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect(this.gain);
		}

		getOutput() {
			return this.panner;
		}

		getRefDistance() {
			return this.panner.refDistance;
		}

		setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		}

		getRolloffFactor() {
			return this.panner.rolloffFactor;
		}

		setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		}

		getDistanceModel() {
			return this.panner.distanceModel;
		}

		setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		}

		getMaxDistance() {
			return this.panner.maxDistance;
		}

		setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		}

		setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position, _quaternion, _scale);

			_orientation.set(0, 0, 1).applyQuaternion(_quaternion);

			const panner = this.panner;

			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				const endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
			} else {
				panner.setPosition(_position.x, _position.y, _position.z);
				panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
			}
		}

	}

	class AudioAnalyser {
		constructor(audio, fftSize = 2048) {
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}

		getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		}

		getAverageFrequency() {
			let value = 0;
			const data = this.getFrequencyData();

			for (let i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		}

	}

	class PropertyMixer {
		constructor(binding, typeName, valueSize) {
			this.binding = binding;
			this.valueSize = valueSize;
			let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch (typeName) {
				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;
					this.buffer = new Float64Array(valueSize * 6);
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select; // Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types

					mixFunctionAdditive = this._select;
					setIdentity = this._setAdditiveIdentityOther;
					this.buffer = new Array(valueSize * 5);
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;
					this.buffer = new Float64Array(valueSize * 5);
			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			this.useCount = 0;
			this.referenceCount = 0;
		} // accumulate data in the 'incoming' region into 'accu<i>'


		accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = accuIndex * stride + stride;
			let currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (let i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				const mix = weight / currentWeight;

				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		} // accumulate data in the 'incoming' region into 'add'


		accumulateAdditive(weight) {
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = stride * this._addIndex;

			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			} // add := add + incoming * weight


			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

			this.cumulativeWeightAdditive += weight;
		} // apply the state of 'accu<i>' to the binding when accus differ


		apply(accuIndex) {
			const stride = this.valueSize,
						buffer = this.buffer,
						offset = accuIndex * stride + stride,
						weight = this.cumulativeWeight,
						weightAdditive = this.cumulativeWeightAdditive,
						binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
			}

			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}

			for (let i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		} // remember the state of the bound property and copy it to both accus


		saveOriginalState() {
			const binding = this.binding;
			const buffer = this.buffer,
						stride = this.valueSize,
						originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

			for (let i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + i % stride];
			} // Add to identity for additive


			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		} // apply the state previously taken via 'saveOriginalState' to the binding


		restoreOriginalState() {
			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		}

		_setAdditiveIdentityNumeric() {
			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for (let i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		}

		_setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();

			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		}

		_setAdditiveIdentityOther() {
			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for (let i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		} // mix functions


		_select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (let i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		}

		_slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		}

		_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		}

		_lerp(buffer, dstOffset, srcOffset, t, stride) {
			const s = 1 - t;

			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		}

		_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.


	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.


	const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


	const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.


	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.


	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

	const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

	const _supportedObjectNames = ['material', 'materials', 'bones'];

	class Composite {
		constructor(targetGroup, path, optionalParsedPath) {
			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);
		}

		getValue(array, offset) {
			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
						binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

			if (binding !== undefined) binding.getValue(array, offset);
		}

		setValue(array, offset) {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		}

		bind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		}

		unbind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		}

	} // Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.


	class PropertyBinding {
		constructor(rootNode, path, parsedPath) {
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
			this.rootNode = rootNode; // initial state of these methods that calls 'bind'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

		static create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		}
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */


		static sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		}

		static parseTrackName(trackName) {
			const matches = _trackRe.exec(trackName);

			if (!matches) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				// required
				propertyIndex: matches[6]
			};
			const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

			if (lastDot !== undefined && lastDot !== -1) {
				const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).

				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}

			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}

			return results;
		}

		static findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			} // search into skeleton bones.


			if (root.skeleton) {
				const bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			} // search into node subtree.


			if (root.children) {
				const searchNodeSubtree = function (children) {
					for (let i = 0; i < children.length; i++) {
						const childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						const result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}

					return null;
				};

				const subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		} // these are used to "bind" a nonexistent property


		_getValue_unavailable() {}

		_setValue_unavailable() {} // Getters


		_getValue_direct(buffer, offset) {
			buffer[offset] = this.node[this.propertyName];
		}

		_getValue_array(buffer, offset) {
			const source = this.resolvedProperty;

			for (let i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		}

		_getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		}

		_getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		} // Direct


		_setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		}

		_setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // EntireArray


		_setValue_array(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		}

		_setValue_array_setNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.needsUpdate = true;
		}

		_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.matrixWorldNeedsUpdate = true;
		} // ArrayElement


		_setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		}

		_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // HasToFromArray


		_setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		}

		_setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		}

		_getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);
		}

		_setValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		} // create getter / setter pair for a property in the scene graph


		bind() {
			let targetObject = this.node;
			const parsedPath = this.parsedPath;
			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
				this.node = targetObject;
			} // set fail state so we can just 'return' on error


			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable; // ensure there is a value node

			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}

			if (objectName) {
				let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}

						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}

						targetObject = targetObject.material.materials;
						break;

					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						} // potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.


						targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

						for (let i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}

						break;

					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}

						targetObject = targetObject[objectName];
				}

				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			} // resolve property


			const nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				const nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			} // determine versioning scheme


			let versioning = this.Versioning.None;
			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) {
				// material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
				// node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			} // determine how the property gets bound


			let bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
							propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
						}
					} else {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
						return;
					}
				}

				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			} // select getter / setter


			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		}

		unbind() {
			this.node = null; // back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

	}

	PropertyBinding.Composite = Composite;
	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
	PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
	PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
	PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
	PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */

	class AnimationObjectGroup {
		constructor() {
			this.uuid = generateUUID(); // cached objects followed by the active ones

			this._objects = Array.prototype.slice.call(arguments);
			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				indices[arguments[i].uuid] = i;
			}

			this._paths = []; // inside: string

			this._parsedPaths = []; // inside: { we don't care, here }

			this._bindings = []; // inside: Array< PropertyBinding >

			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			const scope = this;
			this.stats = {
				objects: {
					get total() {
						return scope._objects.length;
					},

					get inUse() {
						return this.total - scope.nCachedObjects_;
					}

				},

				get bindingsPerObject() {
					return scope._bindings.length;
				}

			};
		}

		add() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						nBindings = bindings.length;
			let knownObject = undefined,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid;
				let index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object); // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index]; // move existing object to the ACTIVE region

					const firstActiveIndex = --nCachedObjects,
								lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									lastCached = bindingsForPath[firstActiveIndex];
						let binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		}

		remove() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					const lastCachedIndex = nCachedObjects++,
								firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									firstActive = bindingsForPath[lastCachedIndex],
									binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // remove & forget


		uncache() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_,
					nObjects = objects.length;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						const firstActiveIndex = --nCachedObjects,
									lastCachedObject = objects[firstActiveIndex],
									lastIndex = --nObjects,
									lastObject = objects[lastIndex]; // last cached object takes this object's place

						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject; // last object goes to the activated slot and pop

						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j],
										lastCached = bindingsForPath[firstActiveIndex],
										last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						const lastIndex = --nObjects,
									lastObject = objects[lastIndex];

						if (lastIndex > 0) {
							indicesByUUID[lastObject.uuid] = index;
						}

						objects[index] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j];
							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();
						}
					} // cached or active

				} // if object is known

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // Internal interface used by befriended PropertyBinding.Composite:


		subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[path];
			const bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			const paths = this._paths,
						parsedPaths = this._parsedPaths,
						objects = this._objects,
						nObjects = objects.length,
						nCachedObjects = this.nCachedObjects_,
						bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
				const object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		}

		unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			const indicesByPath = this._bindingsIndicesByPath,
						index = indicesByPath[path];

			if (index !== undefined) {
				const paths = this._paths,
							parsedPaths = this._parsedPaths,
							bindings = this._bindings,
							lastBindingsIndex = bindings.length - 1,
							lastBindings = bindings[lastBindingsIndex],
							lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		}

	}

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

	class AnimationAction {
		constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			const tracks = clip.tracks,
						nTracks = tracks.length,
						interpolants = new Array(nTracks);
			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for (let i = 0; i !== nTracks; ++i) {
				const interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}

			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)

			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager

			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1; // global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action

			this._startTime = null; // scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop

			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale

			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false; // keep feeding the last frame?

			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		} // State & Scheduling


		play() {
			this._mixer._activateAction(this);

			return this;
		}

		stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		}

		reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip

			this._loopCount = -1; // forget previous loops

			this._startTime = null; // forget scheduling

			return this.stopFading().stopWarping();
		}

		isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
		} // return true when play has been called


		isScheduled() {
			return this._mixer._isActiveAction(this);
		}

		startAt(time) {
			this._startTime = time;
			return this;
		}

		setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		} // Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing


		setEffectiveWeight(weight) {
			this.weight = weight; // note: same logic as when updated at runtime

			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		} // return the weight considering fading and .enabled


		getEffectiveWeight() {
			return this._effectiveWeight;
		}

		fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		}

		fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		}

		crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				const fadeInDuration = this._clip.duration,
							fadeOutDuration = fadeOutAction._clip.duration,
							startEndRatio = fadeOutDuration / fadeInDuration,
							endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		}

		crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		}

		stopFading() {
			const weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;

				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		} // Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing


		setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		} // return the time scale considering warping and .paused


		getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		}

		setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		}

		syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		}

		halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		}

		warp(startTimeScale, endTimeScale, duration) {
			const mixer = this._mixer,
						now = mixer.time,
						timeScale = this.timeScale;
			let interpolant = this._timeScaleInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		}

		stopWarping() {
			const timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;

				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		} // Object Accessors


		getMixer() {
			return this._mixer;
		}

		getClip() {
			return this._clip;
		}

		getRoot() {
			return this._localRoot || this._mixer._root;
		} // Interna


		_update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);

				return;
			}

			const startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action
				const timeRunning = (time - startTime) * timeDirection;

				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				} // start


				this._startTime = null; // unschedule

				deltaTime = timeDirection * timeRunning;
			} // apply time scale and advance time


			deltaTime *= this._updateTimeScale(time);

			const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
			// an effective weight of 0


			const weight = this._updateWeight(time);

			if (weight > 0) {
				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulateAdditive(weight);
						}

						break;

					case NormalAnimationBlendMode:
					default:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulate(accuIndex, weight);
						}

				}
			}
		}

		_updateWeight(time) {
			let weight = 0;

			if (this.enabled) {
				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		}

		_updateTimeScale(time) {
			let timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;
				const interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		}

		_updateTime(deltaTime) {
			const duration = this._clip.duration;
			const loop = this.loop;
			let time = this.time + deltaTime;
			let loopCount = this._loopCount;
			const pingPong = loop === LoopPingPong;

			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return pingPong && (loopCount & 1) === 1 ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;

					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					this.time = time;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else {
				// repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around
					const loopDelta = Math.floor(time / duration); // signed

					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					const pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							const atStart = deltaTime < 0;

							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}

			return time;
		}

		_setEndings(atStart, atEnd, pingPong) {
			const settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		}

		_scheduleFading(duration, weightNow, weightThen) {
			const mixer = this._mixer,
						now = mixer.time;
			let interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		}

	}

	class AnimationMixer extends EventDispatcher {
		constructor(root) {
			super();
			this._root = root;

			this._initMemoryManager();

			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;
		}

		_bindAction(action, prototypeAction) {
			const root = action._localRoot || this._root,
						tracks = action._clip.tracks,
						nTracks = tracks.length,
						bindings = action._propertyBindings,
						interpolants = action._interpolants,
						rootUuid = root.uuid,
						bindingsByRoot = this._bindingsByRootAndName;
			let bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (let i = 0; i !== nTracks; ++i) {
				const track = tracks[i],
							trackName = track.name;
				let binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;

							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;

					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		}

		_activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					const rootUuid = (action._localRoot || this._root).uuid,
								clipUuid = action._clip.uuid,
								actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				const bindings = action._propertyBindings; // increment reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);

						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		}

		_deactivateAction(action) {
			if (this._isActiveAction(action)) {
				const bindings = action._propertyBindings; // decrement reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();

						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		} // Memory manager


		_initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones

			this._nActiveActions = 0;
			this._actionsByClip = {}; // inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }

			this._bindings = []; // 'nActiveBindings' followed by inactive ones

			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

			this._controlInterpolants = []; // same game as above

			this._nActiveControlInterpolants = 0;
			const scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},

					get inUse() {
						return scope._nActiveActions;
					}

				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},

					get inUse() {
						return scope._nActiveBindings;
					}

				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},

					get inUse() {
						return scope._nActiveControlInterpolants;
					}

				}
			};
		} // Memory management for AnimationAction objects


		_isActiveAction(action) {
			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		}

		_addInactiveAction(action, clipUuid, rootUuid) {
			const actions = this._actions,
						actionsByClip = this._actionsByClip;
			let actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				const knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		}

		_removeInactiveAction(action) {
			const actions = this._actions,
						lastInactiveAction = actions[actions.length - 1],
						cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			const clipUuid = action._clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid],
						knownActionsForClip = actionsForClip.knownActions,
						lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
						byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			const actionByRoot = actionsForClip.actionByRoot,
						rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		}

		_removeInactiveBindingsForAction(action) {
			const bindings = action._propertyBindings;

			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		}

		_lendAction(action) {
			// [ active actions |	inactive actions	]
			// [	active actions >| inactive actions ]
			//								 s				a
			//									<-swap->
			//								 a				s
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						lastActiveIndex = this._nActiveActions++,
						firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		}

		_takeBackAction(action) {
			// [	active actions	| inactive actions ]
			// [ active actions |< inactive actions	]
			//				a				s
			//				 <-swap->
			//				s				a
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						firstInactiveIndex = --this._nActiveActions,
						lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		} // Memory management for PropertyMixer objects


		_addInactiveBinding(binding, rootUuid, trackName) {
			const bindingsByRoot = this._bindingsByRootAndName,
						bindings = this._bindings;
			let bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		}

		_removeInactiveBinding(binding) {
			const bindings = this._bindings,
						propBinding = binding.binding,
						rootUuid = propBinding.rootNode.uuid,
						trackName = propBinding.path,
						bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid],
						lastInactiveBinding = bindings[bindings.length - 1],
						cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];

			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		}

		_lendBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						lastActiveIndex = this._nActiveBindings++,
						firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		}

		_takeBackBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						firstInactiveIndex = --this._nActiveBindings,
						lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		} // Memory management of Interpolants for weight and time scale


		_lendControlInterpolant() {
			const interpolants = this._controlInterpolants,
						lastActiveIndex = this._nActiveControlInterpolants++;
			let interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		}

		_takeBackControlInterpolant(interpolant) {
			const interpolants = this._controlInterpolants,
						prevIndex = interpolant.__cacheIndex,
						firstInactiveIndex = --this._nActiveControlInterpolants,
						lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		} // return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)


		clipAction(clip, optionalRoot, blendMode) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid;
			let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			const clipUuid = clipObject !== null ? clipObject.uuid : clip;
			const actionsForClip = this._actionsByClip[clipUuid];
			let prototypeAction = null;

			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}

			if (actionsForClip !== undefined) {
				const existingAction = actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				} // we know the clip, so we don't have to parse all
				// the bindings again but can just copy


				prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

				if (clipObject === null) clipObject = prototypeAction._clip;
			} // clip must be known when specified via string


			if (clipObject === null) return null; // allocate all resources required to run it

			const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

			this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		} // get an existing action


		existingAction(clip, optionalRoot) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid,
						clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
						clipUuid = clipObject ? clipObject.uuid : clip,
						actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		} // deactivates all previously scheduled actions


		stopAllAction() {
			const actions = this._actions,
						nActions = this._nActiveActions;

			for (let i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}

			return this;
		} // advance the time and update apply the animation


		update(deltaTime) {
			deltaTime *= this.timeScale;
			const actions = this._actions,
						nActions = this._nActiveActions,
						time = this.time += deltaTime,
						timeDirection = Math.sign(deltaTime),
						accuIndex = this._accuIndex ^= 1; // run active actions

			for (let i = 0; i !== nActions; ++i) {
				const action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			} // update scene graph


			const bindings = this._bindings,
						nBindings = this._nActiveBindings;

			for (let i = 0; i !== nBindings; ++i) {
				bindings[i].apply(accuIndex);
			}

			return this;
		} // Allows you to seek to a specific time in an animation.


		setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;

			for (let i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}

			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		} // return this mixer's root target object


		getRoot() {
			return this._root;
		} // free all resources specific to a particular clip


		uncacheClip(clip) {
			const actions = this._actions,
						clipUuid = clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				const actionsToRemove = actionsForClip.knownActions;

				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
					const action = actionsToRemove[i];

					this._deactivateAction(action);

					const cacheIndex = action._cacheIndex,
								lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		} // free all resources specific to a particular root target object


		uncacheRoot(root) {
			const rootUuid = root.uuid,
						actionsByClip = this._actionsByClip;

			for (const clipUuid in actionsByClip) {
				const actionByRoot = actionsByClip[clipUuid].actionByRoot,
							action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);

					this._removeInactiveAction(action);
				}
			}

			const bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (const trackName in bindingByName) {
					const binding = bindingByName[trackName];
					binding.restoreOriginalState();

					this._removeInactiveBinding(binding);
				}
			}
		} // remove a targeted clip from the cache


		uncacheAction(clip, optionalRoot) {
			const action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);

				this._removeInactiveAction(action);
			}
		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

	class Uniform {
		constructor(value) {
			if (typeof value === 'string') {
				console.warn('THREE.Uniform: Type parameter is no longer needed.');
				value = arguments[1];
			}

			this.value = value;
		}

		clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {
		constructor(array, stride, meshPerAttribute = 1) {
			super(array, stride);
			this.meshPerAttribute = meshPerAttribute || 1;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		clone(data) {
			const ib = super.clone(data);
			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		}

		toJSON(data) {
			const json = super.toJSON(data);
			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		}

	}

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

	class GLBufferAttribute {
		constructor(buffer, type, itemSize, elementSize, count) {
			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;
			this.version = 0;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		}

		setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		}

		setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		}

		setCount(count) {
			this.count = count;
			return this;
		}

	}

	GLBufferAttribute.prototype.isGLBufferAttribute = true;

	class Raycaster {
		constructor(origin, direction, near = 0, far = Infinity) {
			this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();
			this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			};
		}

		set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		}

		setFromCamera(coords, camera) {
			if (camera && camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera && camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		}

		intersectObject(object, recursive = false, intersects = []) {
			intersectObject(object, this, intersects, recursive);
			intersects.sort(ascSort);
			return intersects;
		}

		intersectObjects(objects, recursive = false, intersects = []) {
			for (let i = 0, l = objects.length; i < l; i++) {
				intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);
			return intersects;
		}

	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}

		if (recursive === true) {
			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {
		constructor(radius = 1, phi = 0, theta = 0) {
			this.radius = radius;
			this.phi = phi; // polar angle

			this.theta = theta; // azimuthal angle

			return this;
		}

		set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		} // restrict phi to be betwee EPS and PI-EPS


		makeSafe() {
			const EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(clamp(y / this.radius, -1, 1));
			}

			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	class Cylindrical {
		constructor(radius = 1, theta = 0, y = 0) {
			this.radius = radius; // distance from the origin to a point in the x-z plane

			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

			this.y = y; // height above the x-z plane

			return this;
		}

		set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$4 = /*@__PURE__*/new Vector2();

	class Box2 {
		constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$4.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y;
		}

		getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .getCenter() target is now required');
				target = new Vector2();
			}

			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .getSize() target is now required');
				target = new Vector2();
			}

			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			if (target === undefined) {
				console.warn('THREE.Box2: .getParameter() target is now required');
				target = new Vector2();
			}

			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
		}

		intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		}

		clampPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .clampPoint() target is now required');
				target = new Vector2();
			}

			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box2.prototype.isBox2 = true;

	const _startP = /*@__PURE__*/new Vector3();

	const _startEnd = /*@__PURE__*/new Vector3();

	class Line3 {
		constructor(start = new Vector3(), end = new Vector3()) {
			this.start = start;
			this.end = end;
		}

		set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		}

		copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		}

		getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .getCenter() target is now required');
				target = new Vector3();
			}

			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		}

		delta(target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .delta() target is now required');
				target = new Vector3();
			}

			return target.subVectors(this.end, this.start);
		}

		distanceSq() {
			return this.start.distanceToSquared(this.end);
		}

		distance() {
			return this.start.distanceTo(this.end);
		}

		at(t, target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .at() target is now required');
				target = new Vector3();
			}

			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);

			_startEnd.subVectors(this.end, this.start);

			const startEnd2 = _startEnd.dot(_startEnd);

			const startEnd_startP = _startEnd.dot(_startP);

			let t = startEnd_startP / startEnd2;

			if (clampToLine) {
				t = clamp(t, 0, 1);
			}

			return t;
		}

		closestPointToPoint(point, clampToLine, target) {
			const t = this.closestPointToPointParameter(point, clampToLine);

			if (target === undefined) {
				console.warn('THREE.Line3: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		}

		equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class ImmediateRenderObject extends Object3D {
		constructor(material) {
			super();
			this.material = material;

			this.render = function ()
			/* renderCallback */
			{};

			this.hasPositions = false;
			this.hasNormals = false;
			this.hasColors = false;
			this.hasUvs = false;
			this.positionArray = null;
			this.normalArray = null;
			this.colorArray = null;
			this.uvArray = null;
			this.count = 0;
		}

	}

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	const _vector$3 = /*@__PURE__*/new Vector3();

	class SpotLightHelper extends Object3D {
		constructor(light, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new BufferGeometry();
			const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

			for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
				const p1 = i / l * Math.PI * 2;
				const p2 = j / l * Math.PI * 2;
				positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.cone = new LineSegments(geometry, material);
			this.add(this.cone);
			this.update();
		}

		dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		}

		update() {
			this.light.updateMatrixWorld();
			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(_vector$3);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		}

	}

	const _vector$2 = /*@__PURE__*/new Vector3();

	const _boneMatrix = /*@__PURE__*/new Matrix4();

	const _matrixWorldInv = /*@__PURE__*/new Matrix4();

	class SkeletonHelper extends LineSegments {
		constructor(object) {
			const bones = getBoneList(object);
			const geometry = new BufferGeometry();
			const vertices = [];
			const colors = [];
			const color1 = new Color(0, 0, 1);
			const color2 = new Color(0, 1, 0);

			for (let i = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			super(geometry, material);
			this.type = 'SkeletonHelper';
			this.isSkeletonHelper = true;
			this.root = object;
			this.bones = bones;
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
		}

		updateMatrixWorld(force) {
			const bones = this.bones;
			const geometry = this.geometry;
			const position = geometry.getAttribute('position');

			_matrixWorldInv.copy(this.root.matrixWorld).invert();

			for (let i = 0, j = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;
			super.updateMatrixWorld(force);
		}

	}

	function getBoneList(object) {
		const boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (let i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	class PointLightHelper extends Mesh {
		constructor(light, sphereSize, color) {
			const geometry = new SphereGeometry(sphereSize, 4, 2);
			const material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			super(geometry, material);
			this.light = light;
			this.light.updateMatrixWorld();
			this.color = color;
			this.type = 'PointLightHelper';
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.update();
			/*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
			const d = light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.scale.set( d, d, d );
			}
			this.add( this.lightDistance );
			*/
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

		update() {
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
				}
			*/

		}

	}

	const _vector$1 = /*@__PURE__*/new Vector3();

	const _color1 = /*@__PURE__*/new Color();

	const _color2 = /*@__PURE__*/new Color();

	class HemisphereLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (this.color === undefined) this.material.vertexColors = true;
			const position = geometry.getAttribute('position');
			const colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));
			this.add(new Mesh(geometry, this.material));
			this.update();
		}

		dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		}

		update() {
			const mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				const colors = mesh.geometry.getAttribute('color');

				_color1.copy(this.light.color);

				_color2.copy(this.light.groundColor);

				for (let i = 0, l = colors.count; i < l; i++) {
					const color = i < l / 2 ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
		}

	}

	class GridHelper extends LineSegments {
		constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;
			const vertices = [],
						colors = [];

			for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				const color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'GridHelper';
		}

	}

	class PolarGridHelper extends LineSegments {
		constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const vertices = [];
			const colors = []; // create the radials

			for (let i = 0; i <= radials; i++) {
				const v = i / radials * (Math.PI * 2);
				const x = Math.sin(v) * radius;
				const z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				const color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			} // create the circles


			for (let i = 0; i <= circles; i++) {
				const color = i & 1 ? color1 : color2;
				const r = radius - radius / circles * i;

				for (let j = 0; j < divisions; j++) {
					// first vertex
					let v = j / divisions * (Math.PI * 2);
					let x = Math.sin(v) * r;
					let z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b); // second vertex

					v = (j + 1) / divisions * (Math.PI * 2);
					x = Math.sin(v) * r;
					z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b);
				}
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'PolarGridHelper';
		}

	}

	const _v1 = /*@__PURE__*/new Vector3();

	const _v2 = /*@__PURE__*/new Vector3();

	const _v3 = /*@__PURE__*/new Vector3();

	class DirectionalLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			if (size === undefined) size = 1;
			let geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.lightPlane = new Line(geometry, material);
			this.add(this.lightPlane);
			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			this.targetLine = new Line(geometry, material);
			this.add(this.targetLine);
			this.update();
		}

		dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		}

		update() {
			_v1.setFromMatrixPosition(this.light.matrixWorld);

			_v2.setFromMatrixPosition(this.light.target.matrixWorld);

			_v3.subVectors(_v2, _v1);

			this.lightPlane.lookAt(_v2);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(_v2);
			this.targetLine.scale.z = _v3.length();
		}

	}

	const _vector = /*@__PURE__*/new Vector3();

	const _camera = /*@__PURE__*/new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */


	class CameraHelper extends LineSegments {
		constructor(camera) {
			const geometry = new BufferGeometry();
			const material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			const vertices = [];
			const colors = [];
			const pointMap = {}; // colors

			const colorFrustum = new Color(0xffaa00);
			const colorCone = new Color(0xff0000);
			const colorUp = new Color(0x00aaff);
			const colorTarget = new Color(0xffffff);
			const colorCross = new Color(0x333333); // near

			addLine('n1', 'n2', colorFrustum);
			addLine('n2', 'n4', colorFrustum);
			addLine('n4', 'n3', colorFrustum);
			addLine('n3', 'n1', colorFrustum); // far

			addLine('f1', 'f2', colorFrustum);
			addLine('f2', 'f4', colorFrustum);
			addLine('f4', 'f3', colorFrustum);
			addLine('f3', 'f1', colorFrustum); // sides

			addLine('n1', 'f1', colorFrustum);
			addLine('n2', 'f2', colorFrustum);
			addLine('n3', 'f3', colorFrustum);
			addLine('n4', 'f4', colorFrustum); // cone

			addLine('p', 'n1', colorCone);
			addLine('p', 'n2', colorCone);
			addLine('p', 'n3', colorCone);
			addLine('p', 'n4', colorCone); // up

			addLine('u1', 'u2', colorUp);
			addLine('u2', 'u3', colorUp);
			addLine('u3', 'u1', colorUp); // target

			addLine('c', 't', colorTarget);
			addLine('p', 'c', colorCross); // cross

			addLine('cn1', 'cn2', colorCross);
			addLine('cn3', 'cn4', colorCross);
			addLine('cf1', 'cf2', colorCross);
			addLine('cf3', 'cf4', colorCross);

			function addLine(a, b, color) {
				addPoint(a, color);
				addPoint(b, color);
			}

			function addPoint(id, color) {
				vertices.push(0, 0, 0);
				colors.push(color.r, color.g, color.b);

				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}

				pointMap[id].push(vertices.length / 3 - 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			super(geometry, material);
			this.type = 'CameraHelper';
			this.camera = camera;
			if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
			this.pointMap = pointMap;
			this.update();
		}

		update() {
			const geometry = this.geometry;
			const pointMap = this.pointMap;
			const w = 1,
						h = 1; // we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector.set(x, y, z).unproject(camera);

		const points = pointMap[point];

		if (points !== undefined) {
			const position = geometry.getAttribute('position');

			for (let i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
			}
		}
	}

	const _box = /*@__PURE__*/new Box3();

	class BoxHelper extends LineSegments {
		constructor(object, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = new Float32Array(8 * 3);
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.object = object;
			this.type = 'BoxHelper';
			this.matrixAutoUpdate = false;
			this.update();
		}

		update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				_box.setFromObject(this.object);
			}

			if (_box.isEmpty()) return;
			const min = _box.min;
			const max = _box.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
				0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position;
			const array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		}

		setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		}

		copy(source) {
			LineSegments.prototype.copy.call(this, source);
			this.object = source.object;
			return this;
		}

	}

	class Box3Helper extends LineSegments {
		constructor(box, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.box = box;
			this.type = 'Box3Helper';
			this.geometry.computeBoundingSphere();
		}

		updateMatrixWorld(force) {
			const box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);
			super.updateMatrixWorld(force);
		}

	}

	class PlaneHelper extends Line {
		constructor(plane, size = 1, hex = 0xffff00) {
			const color = hex;
			const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.type = 'PlaneHelper';
			this.plane = plane;
			this.size = size;
			const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
			const geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();
			this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));
		}

		updateMatrixWorld(force) {
			let scale = -this.plane.constant;
			if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
			this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal);
			super.updateMatrixWorld(force);
		}

	}

	const _axis = /*@__PURE__*/new Vector3();

	let _lineGeometry, _coneGeometry;

	class ArrowHelper extends Object3D {
		// dir is assumed to be normalized
		constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
			super();
			this.type = 'ArrowHelper';

			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();

				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

				_coneGeometry.translate(0, -0.5, 0);
			}

			this.position.copy(origin);
			this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.line.matrixAutoUpdate = false;
			this.add(this.line);
			this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.cone.matrixAutoUpdate = false;
			this.add(this.cone);
			this.setDirection(dir);
			this.setLength(length, headLength, headWidth);
		}

		setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();

				const radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		}

		setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		}

		setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		}

		copy(source) {
			super.copy(source, false);
			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		}

	}

	class AxesHelper extends LineSegments {
		constructor(size = 1) {
			const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
			const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'AxesHelper';
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	const _floatView = new Float32Array(1);

	const _int32View = new Int32Array(_floatView.buffer);

	class DataUtils {
		// Converts float32 to float16 (stored as uint16 value).
		static toHalfFloat(val) {
			// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */
			_floatView[0] = val;
			const x = _int32View[0];
			let bits = x >> 16 & 0x8000;
			/* Get the sign */

			let m = x >> 12 & 0x07ff;
			/* Keep one extra bit for rounding */

			const e = x >> 23 & 0xff;
			/* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */

			if (e < 103) return bits;
			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

			if (e > 142) {
				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */

				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			/* If exponent underflows but not too much, return a denormal */


			if (e < 113) {
				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */

				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */

			bits += m & 1;
			return bits;
		}

	}

	const LOD_MIN = 4;
	const LOD_MAX = 8;
	const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.

	const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.

	const MAX_SAMPLES = 20;
	const ENCODINGS = {
		[LinearEncoding]: 0,
		[sRGBEncoding]: 1,
		[RGBEEncoding]: 2,
		[RGBM7Encoding]: 3,
		[RGBM16Encoding]: 4,
		[RGBDEncoding]: 5,
		[GammaEncoding]: 6
	};
	const backgroundMaterial = new MeshBasicMaterial({
		side: BackSide,
		depthWrite: false,
		depthTest: false
	});
	const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);

	const _flatCamera = /*@__PURE__*/new OrthographicCamera();

	const {
		_lodPlanes,
		_sizeLods,
		_sigmas
	} = /*@__PURE__*/_createPlanes();

	const _clearColor = /*@__PURE__*/new Color();

	let _oldTarget = null; // Golden Ratio

	const PHI = (1 + Math.sqrt(5)) / 2;
	const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.

	const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	function convertLinearToRGBE(color) {
		const maxComponent = Math.max(color.r, color.g, color.b);
		const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
		color.multiplyScalar(Math.pow(2.0, -fExp));
		const alpha = (fExp + 128.0) / 255.0;
		return alpha;
	}

	class PMREMGenerator {
		constructor(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._blurMaterial = _getBlurShader(MAX_SAMPLES);
			this._equirectShader = null;
			this._cubemapShader = null;

			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */


		fromScene(scene, sigma = 0, near = 0.1, far = 100) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets();

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromEquirectangular(equirectangular) {
			return this._fromTexture(equirectangular);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromCubemap(cubemap) {
			return this._fromTexture(cubemap);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileCubemapShader() {
			if (this._cubemapShader === null) {
				this._cubemapShader = _getCubemapShader();

				this._compileMaterial(this._cubemapShader);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileEquirectangularShader() {
			if (this._equirectShader === null) {
				this._equirectShader = _getEquirectShader();

				this._compileMaterial(this._equirectShader);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */


		dispose() {
			this._blurMaterial.dispose();

			if (this._cubemapShader !== null) this._cubemapShader.dispose();
			if (this._equirectShader !== null) this._equirectShader.dispose();

			for (let i = 0; i < _lodPlanes.length; i++) {
				_lodPlanes[i].dispose();
			}
		} // private interface


		_cleanup(outputTarget) {
			this._pingPongRenderTarget.dispose();

			this._renderer.setRenderTarget(_oldTarget);

			outputTarget.scissorTest = false;

			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		}

		_fromTexture(texture) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets(texture);

			this._textureToCubeUV(texture, cubeUVRenderTarget);

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}

		_allocateTargets(texture) {
			// warning: null texture is valid
			const params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget(params);

			cubeUVRenderTarget.depthBuffer = texture ? false : true;
			this._pingPongRenderTarget = _createRenderTarget(params);
			return cubeUVRenderTarget;
		}

		_compileMaterial(material) {
			const tmpMesh = new Mesh(_lodPlanes[0], material);

			this._renderer.compile(tmpMesh, _flatCamera);
		}

		_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			const upSign = [1, -1, 1, 1, 1, 1];
			const forwardSign = [1, 1, 1, -1, -1, -1];
			const renderer = this._renderer;
			const originalAutoClear = renderer.autoClear;
			const outputEncoding = renderer.outputEncoding;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.outputEncoding = LinearEncoding;
			renderer.autoClear = false;
			let useSolidColor = false;
			const background = scene.background;

			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background).convertSRGBToLinear();
					scene.background = null;
					const alpha = convertLinearToRGBE(backgroundMaterial.color);
					backgroundMaterial.opacity = alpha;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
				const alpha = convertLinearToRGBE(backgroundMaterial.color);
				backgroundMaterial.opacity = alpha;
				useSolidColor = true;
			}

			for (let i = 0; i < 6; i++) {
				const col = i % 3;

				if (col == 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col == 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}

				_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

				renderer.setRenderTarget(cubeUVRenderTarget);

				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}

				renderer.render(scene, cubeCamera);
			}

			renderer.toneMapping = toneMapping;
			renderer.outputEncoding = outputEncoding;
			renderer.autoClear = originalAutoClear;
		}

		_textureToCubeUV(texture, cubeUVRenderTarget) {
			const renderer = this._renderer;

			if (texture.isCubeTexture) {
				if (this._cubemapShader == null) {
					this._cubemapShader = _getCubemapShader();
				}
			} else {
				if (this._equirectShader == null) {
					this._equirectShader = _getEquirectShader();
				}
			}

			const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
			const mesh = new Mesh(_lodPlanes[0], material);
			const uniforms = material.uniforms;
			uniforms['envMap'].value = texture;

			if (!texture.isCubeTexture) {
				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
			}

			uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
			uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		}

		_applyPMREM(cubeUVRenderTarget) {
			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for (let i = 1; i < TOTAL_LODS; i++) {
				const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
				const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}

			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */


		_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

			this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
		}

		_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error('blur direction must be either latitudinal or longitudinal!');
			} // Number of standard deviations at which to cut off the discrete approximation.


			const STANDARD_DEVIATIONS = 3;
			const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
			const blurUniforms = blurMaterial.uniforms;
			const pixels = _sizeLods[lodIn] - 1;
			const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

			if (samples > MAX_SAMPLES) {
				console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
			}

			const weights = [];
			let sum = 0;

			for (let i = 0; i < MAX_SAMPLES; ++i) {
				const x = i / sigmaPixels;
				const weight = Math.exp(-x * x / 2);
				weights.push(weight);

				if (i == 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}

			for (let i = 0; i < weights.length; i++) {
				weights[i] = weights[i] / sum;
			}

			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';

			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}

			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = LOD_MAX - lodIn;
			blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			const outputSize = _sizeLods[lodOut];
			const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
			const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		}

	}

	function _isLDR(texture) {
		if (texture === undefined || texture.type !== UnsignedByteType) return false;
		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
	}

	function _createPlanes() {
		const _lodPlanes = [];
		const _sizeLods = [];
		const _sigmas = [];
		let lod = LOD_MAX;

		for (let i = 0; i < TOTAL_LODS; i++) {
			const sizeLod = Math.pow(2, lod);

			_sizeLods.push(sizeLod);

			let sigma = 1.0 / sizeLod;

			if (i > LOD_MAX - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
			} else if (i == 0) {
				sigma = 0;
			}

			_sigmas.push(sigma);

			const texelSize = 1.0 / (sizeLod - 1);
			const min = -texelSize / 2;
			const max = 1 + texelSize / 2;
			const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;
			const position = new Float32Array(positionSize * vertices * cubeFaces);
			const uv = new Float32Array(uvSize * vertices * cubeFaces);
			const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

			for (let face = 0; face < cubeFaces; face++) {
				const x = face % 3 * 2 / 3 - 1;
				const y = face > 2 ? 0 : -1;
				const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				const fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}

			const planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

			_lodPlanes.push(planes);

			if (lod > LOD_MIN) {
				lod--;
			}
		}

		return {
			_lodPlanes,
			_sizeLods,
			_sigmas
		};
	}

	function _createRenderTarget(params) {
		const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(maxSamples) {
		const weights = new Float32Array(maxSamples);
		const poleAxis = new Vector3(0, 1, 0);
		const shaderMaterial = new RawShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': maxSamples
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectShader() {
		const texelSize = new Vector2(1, 1);
		const shaderMaterial = new RawShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'texelSize': {
					value: texelSize
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCubemapShader() {
		const shaderMaterial = new RawShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCommonVertexShader() {
		return (
			/* glsl */
			`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
		);
	}

	function _getEncodings() {
		return (
			/* glsl */
			`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
		);
	}

	const LineStrip = 0;
	const LinePieces = 1;
	const NoColors = 0;
	const FaceColors = 1;
	const VertexColors = 2;
	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}
	function MultiMaterial(materials = []) {
		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;

		materials.clone = function () {
			return materials.slice();
		};

		return materials;
	}
	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	} //

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	} //

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');
		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
		return construct;
	}; //


	Path.prototype.fromPoints = function (points) {
		console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
		return this.setFromPoints(points);
	}; //


	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	} //

	Loader.prototype.extractUrlBase = function (url) {
		console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
		return LoaderUtils.extractUrlBase(url);
	};

	Loader.Handlers = {
		add: function ()
		/* regex, loader */
		{
			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
		},
		get: function ()
		/* file */
		{
			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
		}
	};
	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	} //

	Box2.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box2.prototype.empty = function () {
		console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box2.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box2.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box2: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Box3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box3.prototype.empty = function () {
		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box3.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box3.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	};

	Box3.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box3: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Sphere.prototype.empty = function () {
		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	}; //


	Frustum.prototype.setFromMatrix = function (m) {
		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
		return this.setFromProjectionMatrix(m);
	}; //


	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	}; //


	Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix3.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
		return vector.applyMatrix3(this);
	};

	Matrix3.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
	};

	Matrix3.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
		return attribute.applyMatrix3(this);
	};

	Matrix3.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
	};

	Matrix3.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Matrix4.prototype.extractPosition = function (m) {
		console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
		return this.copyPosition(m);
	};

	Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix4.prototype.getPosition = function () {
		console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
		return new Vector3().setFromMatrixColumn(this, 3);
	};

	Matrix4.prototype.setRotationFromQuaternion = function (q) {
		console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
		return this.makeRotationFromQuaternion(q);
	};

	Matrix4.prototype.multiplyToArray = function () {
		console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
	};

	Matrix4.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector4 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
	};

	Matrix4.prototype.rotateAxis = function (v) {
		console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
		v.transformDirection(this);
	};

	Matrix4.prototype.crossVector = function (vector) {
		console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.translate = function () {
		console.error('THREE.Matrix4: .translate() has been removed.');
	};

	Matrix4.prototype.rotateX = function () {
		console.error('THREE.Matrix4: .rotateX() has been removed.');
	};

	Matrix4.prototype.rotateY = function () {
		console.error('THREE.Matrix4: .rotateY() has been removed.');
	};

	Matrix4.prototype.rotateZ = function () {
		console.error('THREE.Matrix4: .rotateZ() has been removed.');
	};

	Matrix4.prototype.rotateByAxis = function () {
		console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
	};

	Matrix4.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
		return attribute.applyMatrix4(this);
	};

	Matrix4.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
	};

	Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
		console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
		return this.makePerspective(left, right, top, bottom, near, far);
	};

	Matrix4.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	}; //


	Quaternion.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
		return vector.applyQuaternion(this);
	};

	Quaternion.prototype.inverse = function () {
		console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
		return this.invert();
	}; //


	Ray.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Ray.prototype.isIntersectionPlane = function (plane) {
		console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
		return this.intersectsPlane(plane);
	};

	Ray.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	}; //


	Triangle.prototype.area = function () {
		console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
		return this.getArea();
	};

	Triangle.prototype.barycoordFromPoint = function (point, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return this.getBarycoord(point, target);
	};

	Triangle.prototype.midpoint = function (target) {
		console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
		return this.getMidpoint(target);
	};

	Triangle.prototypenormal = function (target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return this.getNormal(target);
	};

	Triangle.prototype.plane = function (target) {
		console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
		return this.getPlane(target);
	};

	Triangle.barycoordFromPoint = function (point, a, b, c, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return Triangle.getBarycoord(point, a, b, c, target);
	};

	Triangle.normal = function (a, b, c, target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return Triangle.getNormal(a, b, c, target);
	}; //


	Shape.prototype.extractAllPoints = function (divisions) {
		console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
		return this.extractPoints(divisions);
	};

	Shape.prototype.extrude = function (options) {
		console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
		return new ExtrudeGeometry(this, options);
	};

	Shape.prototype.makeGeometry = function (options) {
		console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
		return new ShapeGeometry(this, options);
	}; //


	Vector2.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector2.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector2.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector3.prototype.setEulerFromRotationMatrix = function () {
		console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
	};

	Vector3.prototype.setEulerFromQuaternion = function () {
		console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
	};

	Vector3.prototype.getPositionFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
		return this.setFromMatrixPosition(m);
	};

	Vector3.prototype.getScaleFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
		return this.setFromMatrixScale(m);
	};

	Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
		console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
		return this.setFromMatrixColumn(matrix, index);
	};

	Vector3.prototype.applyProjection = function (m) {
		console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
		return this.applyMatrix4(m);
	};

	Vector3.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector3.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector3.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector4.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector4.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Object3D.prototype.getChildByName = function (name) {
		console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
		return this.getObjectByName(name);
	};

	Object3D.prototype.renderDepth = function () {
		console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
	};

	Object3D.prototype.translate = function (distance, axis) {
		console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
		return this.translateOnAxis(axis, distance);
	};

	Object3D.prototype.getWorldRotation = function () {
		console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
	};

	Object3D.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set: function (value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			}
		}
	});

	Mesh.prototype.setDrawMode = function () {
		console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
	};

	Object.defineProperties(Mesh.prototype, {
		drawMode: {
			get: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
				return TrianglesDrawMode;
			},
			set: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
			}
		}
	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	}; //


	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	}; //


	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function () {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			}
		},
		shadowCameraFov: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function () {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			}
		},
		shadowBias: {
			set: function (value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function () {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			}
		},
		shadowMapWidth: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			}
		}
	}); //

	Object.defineProperties(BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			}
		},
		dynamic: {
			get: function () {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function ()
			/* value */
			{
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				this.setUsage(DynamicDrawUsage);
			}
		}
	});

	BufferAttribute.prototype.setDynamic = function (value) {
		console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	BufferAttribute.prototype.copyIndicesArray = function ()
	/* indices */
	{
		console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
	}, BufferAttribute.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //

	BufferGeometry.prototype.addIndex = function (index) {
		console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
		this.setIndex(index);
	};

	BufferGeometry.prototype.addAttribute = function (name, attribute) {
		console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

		if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
			console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
			return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
		}

		if (name === 'index') {
			console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
			this.setIndex(attribute);
			return this;
		}

		return this.setAttribute(name, attribute);
	};

	BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
		if (indexOffset !== undefined) {
			console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
		}

		console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
		this.addGroup(start, count);
	};

	BufferGeometry.prototype.clearDrawCalls = function () {
		console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
		this.clearGroups();
	};

	BufferGeometry.prototype.computeOffsets = function () {
		console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
	};

	BufferGeometry.prototype.removeAttribute = function (name) {
		console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
		return this.deleteAttribute(name);
	};

	BufferGeometry.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			}
		}
	});

	InterleavedBuffer.prototype.setDynamic = function (value) {
		console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	InterleavedBuffer.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //


	ExtrudeGeometry.prototype.getArrays = function () {
		console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
	};

	ExtrudeGeometry.prototype.addShapeList = function () {
		console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
	};

	ExtrudeGeometry.prototype.addShape = function () {
		console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
	}; //


	Scene.prototype.dispose = function () {
		console.error('THREE.Scene: .dispose() has been removed.');
	}; //


	Uniform.prototype.onUpdate = function () {
		console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
		return this;
	}; //


	Object.defineProperties(Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			}
		},
		overdraw: {
			get: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			}
		},
		wrapRGB: {
			get: function () {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			}
		},
		shading: {
			get: function () {
				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = value === FlatShading;
			}
		},
		stencilMask: {
			get: function () {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				return this.stencilFuncMask;
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				this.stencilFuncMask = value;
			}
		}
	});
	Object.defineProperties(ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set: function (value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			}
		}
	}); //

	WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
		console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
		this.setRenderTarget(renderTarget);
		this.clear(color, depth, stencil);
	};

	WebGLRenderer.prototype.animate = function (callback) {
		console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
		this.setAnimationLoop(callback);
	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {
		console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
		return this.getRenderTarget();
	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {
		console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
		return this.capabilities.getMaxAnisotropy();
	};

	WebGLRenderer.prototype.getPrecision = function () {
		console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
		return this.capabilities.precision;
	};

	WebGLRenderer.prototype.resetGLState = function () {
		console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
		return this.state.reset();
	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
		return this.extensions.get('OES_texture_float');
	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
		return this.extensions.get('OES_texture_half_float');
	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {
		console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
		return this.extensions.get('OES_standard_derivatives');
	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_s3tc');
	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_pvrtc');
	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {
		console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
		return this.extensions.get('EXT_blend_minmax');
	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
		return this.capabilities.vertexTextures;
	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {
		console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
		return this.extensions.get('ANGLE_instanced_arrays');
	};

	WebGLRenderer.prototype.enableScissorTest = function (boolean) {
		console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
		this.setScissorTest(boolean);
	};

	WebGLRenderer.prototype.initMaterial = function () {
		console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
	};

	WebGLRenderer.prototype.addPrePlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
	};

	WebGLRenderer.prototype.addPostPlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
	};

	WebGLRenderer.prototype.updateShadowMap = function () {
		console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
	};

	WebGLRenderer.prototype.setFaceCulling = function () {
		console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
	};

	WebGLRenderer.prototype.allocTextureUnit = function () {
		console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
	};

	WebGLRenderer.prototype.setTexture = function () {
		console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
	};

	WebGLRenderer.prototype.setTexture2D = function () {
		console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
	};

	WebGLRenderer.prototype.setTextureCube = function () {
		console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {
		console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
		return this.getActiveMipmapLevel();
	};

	Object.defineProperties(WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function ()
			/* value */
			{
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		context: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
				return this.getContext();
			}
		},
		vr: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
				return this.xr;
			}
		},
		gammaInput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
				return false;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
			}
		},
		gammaOutput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				return false;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
			}
		},
		toneMappingWhitePoint: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
				return 1.0;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
			}
		}
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
		cullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function ()
			/* cullFace */
			{
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		renderReverseSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			}
		},
		renderSingleSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			}
		}
	});
	function WebGLRenderTargetCube(width, height, options) {
		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
		return new WebGLCubeRenderTarget(width, options);
	} //

	Object.defineProperties(WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			}
		}
	}); //

	Audio.prototype.load = function (file) {
		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
		const scope = this;
		const audioLoader = new AudioLoader();
		audioLoader.load(file, function (buffer) {
			scope.setBuffer(buffer);
		});
		return this;
	};

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	}; //


	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
		return this.renderTarget.clear(renderer, color, depth, stencil);
	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
		const loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(url, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
		const loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(urls, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	}; //


	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	} //

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	} //

	const SceneUtils = {
		createMultiMaterialObject: function ()
		/* geometry, materials */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		detach: function ()
		/* child, parent, scene */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		attach: function ()
		/* child, scene, parent */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		}
	}; //

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION
			}
		}));
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.AxisHelper = AxisHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasRenderer = CanvasRenderer;
	exports.CanvasTexture = CanvasTexture;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DodecahedronBufferGeometry = DodecahedronGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EdgesHelper = EdgesHelper;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FaceColors = FaceColors;
	exports.FileLoader = FileLoader;
	exports.FlatShading = FlatShading;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.Font = Font;
	exports.FontLoader = FontLoader;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GammaEncoding = GammaEncoding;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16Attribute = Int16Attribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.JSONLoader = JSONLoader;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LensFlare = LensFlare;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LinePieces = LinePieces;
	exports.LineSegments = LineSegments;
	exports.LineStrip = LineStrip;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.Math = MathUtils;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiMaterial = MultiMaterial;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColors = NoColors;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.ParametricBufferGeometry = ParametricGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.Particle = Particle;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystem = ParticleSystem;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointCloud = PointCloud;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGBDEncoding = RGBDEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.RGBEFormat = RGBEFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBIntegerFormat = RGBIntegerFormat;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
	exports.Scene = Scene;
	exports.SceneUtils = SceneUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.SmoothShading = SmoothShading;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TextBufferGeometry = TextGeometry;
	exports.TextGeometry = TextGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.UVMapping = UVMapping;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.Vertex = Vertex;
	exports.VertexColors = VertexColors;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WireframeHelper = WireframeHelper;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.XHRLoader = XHRLoader;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports.sRGBEncoding = sRGBEncoding;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

( function () {

	class GLTFLoader extends THREE.Loader {

		constructor( manager ) {

			super( manager );
			this.dracoLoader = null;
			this.ktx2Loader = null;
			this.meshoptDecoder = null;
			this.pluginCallbacks = [];
			this.register( function ( parser ) {

				return new GLTFMaterialsClearcoatExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFTextureBasisUExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFTextureWebPExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFMaterialsTransmissionExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFLightsExtension( parser );

			} );
			this.register( function ( parser ) {

				return new GLTFMeshoptCompression( parser );

			} );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;
			let resourcePath;

			if ( this.resourcePath !== '' ) {

				resourcePath = this.resourcePath;

			} else if ( this.path !== '' ) {

				resourcePath = this.path;

			} else {

				resourcePath = THREE.LoaderUtils.extractUrlBase( url );

			} // Tells the LoadingManager to track an extra item, which resolves after
			// the model is fully loaded. This means the count of items loaded will
			// be incorrect, but ensures manager.onLoad() does not fire early.


			this.manager.itemStart( url );

			const _onError = function ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			};

			const loader = new THREE.FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( data ) {

				try {

					scope.parse( data, resourcePath, function ( gltf ) {

						onLoad( gltf );
						scope.manager.itemEnd( url );

					}, _onError );

				} catch ( e ) {

					_onError( e );

				}

			}, onProgress, _onError );

		}

		setDRACOLoader( dracoLoader ) {

			this.dracoLoader = dracoLoader;
			return this;

		}

		setDDSLoader() {

			throw new Error( 'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".' );

		}

		setKTX2Loader( ktx2Loader ) {

			this.ktx2Loader = ktx2Loader;
			return this;

		}

		setMeshoptDecoder( meshoptDecoder ) {

			this.meshoptDecoder = meshoptDecoder;
			return this;

		}

		register( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

				this.pluginCallbacks.push( callback );

			}

			return this;

		}

		unregister( callback ) {

			if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

				this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

			}

			return this;

		}

		parse( data, path, onLoad, onError ) {

			let content;
			const extensions = {};
			const plugins = {};

			if ( typeof data === 'string' ) {

				content = data;

			} else {

				const magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

				if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

					try {

						extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

					} catch ( error ) {

						if ( onError ) onError( error );
						return;

					}

					content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

				} else {

					content = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );

				}

			}

			const json = JSON.parse( content );

			if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

				if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
				return;

			}

			const parser = new GLTFParser( json, {
				path: path || this.resourcePath || '',
				crossOrigin: this.crossOrigin,
				requestHeader: this.requestHeader,
				manager: this.manager,
				ktx2Loader: this.ktx2Loader,
				meshoptDecoder: this.meshoptDecoder
			} );
			parser.fileLoader.setRequestHeader( this.requestHeader );

			for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

				const plugin = this.pluginCallbacks[ i ]( parser );
				plugins[ plugin.name ] = plugin; // Workaround to avoid determining as unknown extension
				// in addUnknownExtensionsToUserData().
				// Remove this workaround if we move all the existing
				// extension handlers to plugin system

				extensions[ plugin.name ] = true;

			}

			if ( json.extensionsUsed ) {

				for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

					const extensionName = json.extensionsUsed[ i ];
					const extensionsRequired = json.extensionsRequired || [];

					switch ( extensionName ) {

						case EXTENSIONS.KHR_MATERIALS_UNLIT:
							extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
							break;

						case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
							extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
							break;

						case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
							extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
							break;

						case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
							extensions[ extensionName ] = new GLTFTextureTransformExtension();
							break;

						case EXTENSIONS.KHR_MESH_QUANTIZATION:
							extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
							break;

						default:
							if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

								console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

							}

					}

				}

			}

			parser.setExtensions( extensions );
			parser.setPlugins( plugins );
			parser.parse( onLoad, onError );

		}

	}
	/* GLTFREGISTRY */


	function GLTFRegistry() {

		let objects = {};
		return {
			get: function ( key ) {

				return objects[ key ];

			},
			add: function ( key, object ) {

				objects[ key ] = object;

			},
			remove: function ( key ) {

				delete objects[ key ];

			},
			removeAll: function () {

				objects = {};

			}
		};

	}
	/*********************************/

	/********** EXTENSIONS ***********/

	/*********************************/


	const EXTENSIONS = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
		KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
		KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
		KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
		KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
		KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
		KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
		EXT_TEXTURE_WEBP: 'EXT_texture_webp',
		EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
	};
	/**
	 * Punctual Lights Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
	 */

	class GLTFLightsExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // THREE.Object3D instance caches

			this.cache = {
				refs: {},
				uses: {}
			};

		}

		_markDefs() {

			const parser = this.parser;
			const nodeDefs = this.parser.json.nodes || [];

			for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				const nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.extensions && nodeDef.extensions[ this.name ] && nodeDef.extensions[ this.name ].light !== undefined ) {

					parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

				}

			}

		}

		_loadLight( lightIndex ) {

			const parser = this.parser;
			const cacheKey = 'light:' + lightIndex;
			let dependency = parser.cache.get( cacheKey );
			if ( dependency ) return dependency;
			const json = parser.json;
			const extensions = json.extensions && json.extensions[ this.name ] || {};
			const lightDefs = extensions.lights || [];
			const lightDef = lightDefs[ lightIndex ];
			let lightNode;
			const color = new THREE.Color( 0xffffff );
			if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );
			const range = lightDef.range !== undefined ? lightDef.range : 0;

			switch ( lightDef.type ) {

				case 'directional':
					lightNode = new THREE.DirectionalLight( color );
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				case 'point':
					lightNode = new THREE.PointLight( color );
					lightNode.distance = range;
					break;

				case 'spot':
					lightNode = new THREE.SpotLight( color );
					lightNode.distance = range; // Handle spotlight properties.

					lightDef.spot = lightDef.spot || {};
					lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
					lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
					lightNode.angle = lightDef.spot.outerConeAngle;
					lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
					lightNode.target.position.set( 0, 0, - 1 );
					lightNode.add( lightNode.target );
					break;

				default:
					throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

			} // Some lights (e.g. spot) default to a position other than the origin. Reset the position
			// here, because node-level parsing will only override position if explicitly specified.


			lightNode.position.set( 0, 0, 0 );
			lightNode.decay = 2;
			if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;
			lightNode.name = parser.createUniqueName( lightDef.name || 'light_' + lightIndex );
			dependency = Promise.resolve( lightNode );
			parser.cache.add( cacheKey, dependency );
			return dependency;

		}

		createNodeAttachment( nodeIndex ) {

			const self = this;
			const parser = this.parser;
			const json = parser.json;
			const nodeDef = json.nodes[ nodeIndex ];
			const lightDef = nodeDef.extensions && nodeDef.extensions[ this.name ] || {};
			const lightIndex = lightDef.light;
			if ( lightIndex === undefined ) return null;
			return this._loadLight( lightIndex ).then( function ( light ) {

				return parser._getNodeRef( self.cache, lightIndex, light );

			} );

		}

	}
	/**
	 * Unlit Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
	 */


	class GLTFMaterialsUnlitExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

		}

		getMaterialType() {

			return THREE.MeshBasicMaterial;

		}

		extendParams( materialParams, materialDef, parser ) {

			const pending = [];
			materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;
			const metallicRoughness = materialDef.pbrMetallicRoughness;

			if ( metallicRoughness ) {

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					const array = metallicRoughness.baseColorFactor;
					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

				}

			}

			return Promise.all( pending );

		}

	}
	/**
	 * Clearcoat Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
	 */


	class GLTFMaterialsClearcoatExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];
			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;
			return THREE.MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];
			const extension = materialDef.extensions[ this.name ];

			if ( extension.clearcoatFactor !== undefined ) {

				materialParams.clearcoat = extension.clearcoatFactor;

			}

			if ( extension.clearcoatTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

			}

			if ( extension.clearcoatRoughnessFactor !== undefined ) {

				materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

			}

			if ( extension.clearcoatRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

			}

			if ( extension.clearcoatNormalTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

				if ( extension.clearcoatNormalTexture.scale !== undefined ) {

					const scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995

					materialParams.clearcoatNormalScale = new THREE.Vector2( scale, - scale );

				}

			}

			return Promise.all( pending );

		}

	}
	/**
	 * Transmission Materials Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
	 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
	 */


	class GLTFMaterialsTransmissionExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

		}

		getMaterialType( materialIndex ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];
			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;
			return THREE.MeshPhysicalMaterial;

		}

		extendMaterialParams( materialIndex, materialParams ) {

			const parser = this.parser;
			const materialDef = parser.json.materials[ materialIndex ];

			if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

				return Promise.resolve();

			}

			const pending = [];
			const extension = materialDef.extensions[ this.name ];

			if ( extension.transmissionFactor !== undefined ) {

				materialParams.transmission = extension.transmissionFactor;

			}

			if ( extension.transmissionTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

			}

			return Promise.all( pending );

		}

	}
	/**
	 * BasisU Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
	 */


	class GLTFTextureBasisUExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

		}

		loadTexture( textureIndex ) {

			const parser = this.parser;
			const json = parser.json;
			const textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

				return null;

			}

			const extension = textureDef.extensions[ this.name ];
			const source = json.images[ extension.source ];
			const loader = parser.options.ktx2Loader;

			if ( ! loader ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

				} else {

					// Assumes that the extension is optional and that a fallback texture is present
					return null;

				}

			}

			return parser.loadTextureImage( textureIndex, source, loader );

		}

	}
	/**
	 * WebP Texture Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
	 */


	class GLTFTextureWebPExtension {

		constructor( parser ) {

			this.parser = parser;
			this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
			this.isSupported = null;

		}

		loadTexture( textureIndex ) {

			const name = this.name;
			const parser = this.parser;
			const json = parser.json;
			const textureDef = json.textures[ textureIndex ];

			if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

				return null;

			}

			const extension = textureDef.extensions[ name ];
			const source = json.images[ extension.source ];
			let loader = parser.textureLoader;

			if ( source.uri ) {

				const handler = parser.options.manager.getHandler( source.uri );
				if ( handler !== null ) loader = handler;

			}

			return this.detectSupport().then( function ( isSupported ) {

				if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

				} // Fall back to PNG or JPEG.


				return parser.loadTexture( textureIndex );

			} );

		}

		detectSupport() {

			if ( ! this.isSupported ) {

				this.isSupported = new Promise( function ( resolve ) {

					const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all
					// WebP images, unfortunately.

					image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

					image.onload = image.onerror = function () {

						resolve( image.height === 1 );

					};

				} );

			}

			return this.isSupported;

		}

	}
	/**
	* meshopt BufferView Compression Extension
	*
	* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
	*/


	class GLTFMeshoptCompression {

		constructor( parser ) {

			this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
			this.parser = parser;

		}

		loadBufferView( index ) {

			const json = this.parser.json;
			const bufferView = json.bufferViews[ index ];

			if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

				const extensionDef = bufferView.extensions[ this.name ];
				const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
				const decoder = this.parser.options.meshoptDecoder;

				if ( ! decoder || ! decoder.supported ) {

					if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

						throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

					} else {

						// Assumes that the extension is optional and that fallback buffer data is present
						return null;

					}

				}

				return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

					const byteOffset = extensionDef.byteOffset || 0;
					const byteLength = extensionDef.byteLength || 0;
					const count = extensionDef.count;
					const stride = extensionDef.byteStride;
					const result = new ArrayBuffer( count * stride );
					const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );
					decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
					return result;

				} );

			} else {

				return null;

			}

		}

	}
	/* BINARY EXTENSION */


	const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
	const BINARY_EXTENSION_HEADER_LENGTH = 12;
	const BINARY_EXTENSION_CHUNK_TYPES = {
		JSON: 0x4E4F534A,
		BIN: 0x004E4942
	};

	class GLTFBinaryExtension {

		constructor( data ) {

			this.name = EXTENSIONS.KHR_BINARY_GLTF;
			this.content = null;
			this.body = null;
			const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
			this.header = {
				magic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
				version: headerView.getUint32( 4, true ),
				length: headerView.getUint32( 8, true )
			};

			if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

				throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

			} else if ( this.header.version < 2.0 ) {

				throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

			}

			const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
			const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
			let chunkIndex = 0;

			while ( chunkIndex < chunkContentsLength ) {

				const chunkLength = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;
				const chunkType = chunkView.getUint32( chunkIndex, true );
				chunkIndex += 4;

				if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

					const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
					this.content = THREE.LoaderUtils.decodeText( contentArray );

				} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

					const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
					this.body = data.slice( byteOffset, byteOffset + chunkLength );

				} // Clients must ignore chunks with unknown types.


				chunkIndex += chunkLength;

			}

			if ( this.content === null ) {

				throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

			}

		}

	}
	/**
	 * DRACO THREE.Mesh Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
	 */


	class GLTFDracoMeshCompressionExtension {

		constructor( json, dracoLoader ) {

			if ( ! dracoLoader ) {

				throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

			}

			this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
			this.json = json;
			this.dracoLoader = dracoLoader;
			this.dracoLoader.preload();

		}

		decodePrimitive( primitive, parser ) {

			const json = this.json;
			const dracoLoader = this.dracoLoader;
			const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
			const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
			const threeAttributeMap = {};
			const attributeNormalizedMap = {};
			const attributeTypeMap = {};

			for ( const attributeName in gltfAttributeMap ) {

				const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();
				threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

			}

			for ( const attributeName in primitive.attributes ) {

				const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

				if ( gltfAttributeMap[ attributeName ] !== undefined ) {

					const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
					const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
					attributeTypeMap[ threeAttributeName ] = componentType;
					attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

				}

			}

			return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

				return new Promise( function ( resolve ) {

					dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

						for ( const attributeName in geometry.attributes ) {

							const attribute = geometry.attributes[ attributeName ];
							const normalized = attributeNormalizedMap[ attributeName ];
							if ( normalized !== undefined ) attribute.normalized = normalized;

						}

						resolve( geometry );

					}, threeAttributeMap, attributeTypeMap );

				} );

			} );

		}

	}
	/**
	 * Texture Transform Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
	 */


	class GLTFTextureTransformExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

		}

		extendTexture( texture, transform ) {

			texture = texture.clone();

			if ( transform.offset !== undefined ) {

				texture.offset.fromArray( transform.offset );

			}

			if ( transform.rotation !== undefined ) {

				texture.rotation = transform.rotation;

			}

			if ( transform.scale !== undefined ) {

				texture.repeat.fromArray( transform.scale );

			}

			if ( transform.texCoord !== undefined ) {

				console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

			}

			texture.needsUpdate = true;
			return texture;

		}

	}
	/**
	 * Specular-Glossiness Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
	 */

	/**
	 * A sub class of StandardMaterial with some of the functionality
	 * changed via the `onBeforeCompile` callback
	 * @pailhead
	 */


	class GLTFMeshStandardSGMaterial extends THREE.MeshStandardMaterial {

		constructor( params ) {

			super();
			this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing

			const specularMapParsFragmentChunk = [ '#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif' ].join( '\n' );
			const glossinessMapParsFragmentChunk = [ '#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif' ].join( '\n' );
			const specularMapFragmentChunk = [ 'vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif' ].join( '\n' );
			const glossinessMapFragmentChunk = [ 'float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif' ].join( '\n' );
			const lightPhysicalFragmentChunk = [ 'PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;' ].join( '\n' );
			const uniforms = {
				specular: {
					value: new THREE.Color().setHex( 0xffffff )
				},
				glossiness: {
					value: 1
				},
				specularMap: {
					value: null
				},
				glossinessMap: {
					value: null
				}
			};
			this._extraUniforms = uniforms;

			this.onBeforeCompile = function ( shader ) {

				for ( const uniformName in uniforms ) {

					shader.uniforms[ uniformName ] = uniforms[ uniformName ];

				}

				shader.fragmentShader = shader.fragmentShader.replace( 'uniform float roughness;', 'uniform vec3 specular;' ).replace( 'uniform float metalness;', 'uniform float glossiness;' ).replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk ).replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk ).replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk ).replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk ).replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

			};

			Object.defineProperties( this, {
				specular: {
					get: function () {

						return uniforms.specular.value;

					},
					set: function ( v ) {

						uniforms.specular.value = v;

					}
				},
				specularMap: {
					get: function () {

						return uniforms.specularMap.value;

					},
					set: function ( v ) {

						uniforms.specularMap.value = v;

						if ( v ) {

							this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

						} else {

							delete this.defines.USE_SPECULARMAP;

						}

					}
				},
				glossiness: {
					get: function () {

						return uniforms.glossiness.value;

					},
					set: function ( v ) {

						uniforms.glossiness.value = v;

					}
				},
				glossinessMap: {
					get: function () {

						return uniforms.glossinessMap.value;

					},
					set: function ( v ) {

						uniforms.glossinessMap.value = v;

						if ( v ) {

							this.defines.USE_GLOSSINESSMAP = '';
							this.defines.USE_UV = '';

						} else {

							delete this.defines.USE_GLOSSINESSMAP;
							delete this.defines.USE_UV;

						}

					}
				}
			} );
			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;
			this.setValues( params );

		}

		copy( source ) {

			super.copy( source );
			this.specularMap = source.specularMap;
			this.specular.copy( source.specular );
			this.glossinessMap = source.glossinessMap;
			this.glossiness = source.glossiness;
			delete this.metalness;
			delete this.roughness;
			delete this.metalnessMap;
			delete this.roughnessMap;
			return this;

		}

	}

	class GLTFMaterialsPbrSpecularGlossinessExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
			this.specularGlossinessParams = [ 'color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio' ];

		}

		getMaterialType() {

			return GLTFMeshStandardSGMaterial;

		}

		extendParams( materialParams, materialDef, parser ) {

			const pbrSpecularGlossiness = materialDef.extensions[ this.name ];
			materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;
			const pending = [];

			if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

				const array = pbrSpecularGlossiness.diffuseFactor;
				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

			}

			materialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );
			materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
			materialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );

			if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

				materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

			}

			if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

				const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
				pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
				pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

			}

			return Promise.all( pending );

		}

		createMaterial( materialParams ) {

			const material = new GLTFMeshStandardSGMaterial( materialParams );
			material.fog = true;
			material.color = materialParams.color;
			material.map = materialParams.map === undefined ? null : materialParams.map;
			material.lightMap = null;
			material.lightMapIntensity = 1.0;
			material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
			material.aoMapIntensity = 1.0;
			material.emissive = materialParams.emissive;
			material.emissiveIntensity = 1.0;
			material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
			material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
			material.bumpScale = 1;
			material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
			material.normalMapType = THREE.TangentSpaceNormalMap;
			if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;
			material.displacementMap = null;
			material.displacementScale = 1;
			material.displacementBias = 0;
			material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
			material.specular = materialParams.specular;
			material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
			material.glossiness = materialParams.glossiness;
			material.alphaMap = null;
			material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
			material.envMapIntensity = 1.0;
			material.refractionRatio = 0.98;
			return material;

		}

	}
	/**
	 * THREE.Mesh Quantization Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
	 */


	class GLTFMeshQuantizationExtension {

		constructor() {

			this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

		}

	}
	/*********************************/

	/********** INTERPOLATION ********/

	/*********************************/
	// Spline Interpolation
	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


	class GLTFCubicSplineInterpolant extends THREE.Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		copySampleValue_( index ) {

			// Copies a sample value to the result buffer. See description of glTF
			// CUBICSPLINE values layout in interpolate_() function below.
			const result = this.resultBuffer,
				values = this.sampleValues,
				valueSize = this.valueSize,
				offset = index * valueSize * 3 + valueSize;

			for ( let i = 0; i !== valueSize; i ++ ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		}

	}

	GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
	GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

	GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;
		const stride2 = stride * 2;
		const stride3 = stride * 3;
		const td = t1 - t0;
		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;
		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;
		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k

			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)

			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1

			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	};
	/*********************************/

	/********** INTERNALS ************/

	/*********************************/

	/* CONSTANTS */


	const WEBGL_CONSTANTS = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	};
	const WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	};
	const WEBGL_FILTERS = {
		9728: THREE.NearestFilter,
		9729: THREE.LinearFilter,
		9984: THREE.NearestMipmapNearestFilter,
		9985: THREE.LinearMipmapNearestFilter,
		9986: THREE.NearestMipmapLinearFilter,
		9987: THREE.LinearMipmapLinearFilter
	};
	const WEBGL_WRAPPINGS = {
		33071: THREE.ClampToEdgeWrapping,
		33648: THREE.MirroredRepeatWrapping,
		10497: THREE.RepeatWrapping
	};
	const WEBGL_TYPE_SIZES = {
		'SCALAR': 1,
		'VEC2': 2,
		'VEC3': 3,
		'VEC4': 4,
		'MAT2': 4,
		'MAT3': 9,
		'MAT4': 16
	};
	const ATTRIBUTES = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		TEXCOORD_0: 'uv',
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex'
	};
	const PATH_PROPERTIES = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	};
	const INTERPOLATION = {
		CUBICSPLINE: undefined,
		// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		// keyframe track will be initialized with a default interpolation type, then modified.
		LINEAR: THREE.InterpolateLinear,
		STEP: THREE.InterpolateDiscrete
	};
	const ALPHA_MODES = {
		OPAQUE: 'OPAQUE',
		MASK: 'MASK',
		BLEND: 'BLEND'
	};
	/* UTILITY FUNCTIONS */

	function resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return ''; // Host Relative URL

		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		} // Absolute URL http://,https://,//


		if ( /^(https?:)?\/\//i.test( url ) ) return url; // Data URI

		if ( /^data:.*,.*$/i.test( url ) ) return url; // Blob URL

		if ( /^blob:.*$/i.test( url ) ) return url; // Relative URL

		return path + url;

	}
	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
	 */


	function createDefaultMaterial( cache ) {

		if ( cache[ 'DefaultMaterial' ] === undefined ) {

			cache[ 'DefaultMaterial' ] = new THREE.MeshStandardMaterial( {
				color: 0xFFFFFF,
				emissive: 0x000000,
				metalness: 1,
				roughness: 1,
				transparent: false,
				depthTest: true,
				side: THREE.FrontSide
			} );

		}

		return cache[ 'DefaultMaterial' ];

	}

	function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

		// Add unknown glTF extensions to an object's userData.
		for ( const name in objectDef.extensions ) {

			if ( knownExtensions[ name ] === undefined ) {

				object.userData.gltfExtensions = object.userData.gltfExtensions || {};
				object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

			}

		}

	}
	/**
	 * @param {Object3D|Material|BufferGeometry} object
	 * @param {GLTF.definition} gltfDef
	 */


	function assignExtrasToUserData( object, gltfDef ) {

		if ( gltfDef.extras !== undefined ) {

			if ( typeof gltfDef.extras === 'object' ) {

				Object.assign( object.userData, gltfDef.extras );

			} else {

				console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

			}

		}

	}
	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
	 *
	 * @param {BufferGeometry} geometry
	 * @param {Array<GLTF.Target>} targets
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */


	function addMorphTargets( geometry, targets, parser ) {

		let hasMorphPosition = false;
		let hasMorphNormal = false;

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];
			if ( target.POSITION !== undefined ) hasMorphPosition = true;
			if ( target.NORMAL !== undefined ) hasMorphNormal = true;
			if ( hasMorphPosition && hasMorphNormal ) break;

		}

		if ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );
		const pendingPositionAccessors = [];
		const pendingNormalAccessors = [];

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( hasMorphPosition ) {

				const pendingAccessor = target.POSITION !== undefined ? parser.getDependency( 'accessor', target.POSITION ) : geometry.attributes.position;
				pendingPositionAccessors.push( pendingAccessor );

			}

			if ( hasMorphNormal ) {

				const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency( 'accessor', target.NORMAL ) : geometry.attributes.normal;
				pendingNormalAccessors.push( pendingAccessor );

			}

		}

		return Promise.all( [ Promise.all( pendingPositionAccessors ), Promise.all( pendingNormalAccessors ) ] ).then( function ( accessors ) {

			const morphPositions = accessors[ 0 ];
			const morphNormals = accessors[ 1 ];
			if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
			if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
			geometry.morphTargetsRelative = true;
			return geometry;

		} );

	}
	/**
	 * @param {Mesh} mesh
	 * @param {GLTF.Mesh} meshDef
	 */


	function updateMorphTargets( mesh, meshDef ) {

		mesh.updateMorphTargets();

		if ( meshDef.weights !== undefined ) {

			for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

				mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

			}

		} // .extras has user-defined data, so check that .extras.targetNames is an array.


		if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

			const targetNames = meshDef.extras.targetNames;

			if ( mesh.morphTargetInfluences.length === targetNames.length ) {

				mesh.morphTargetDictionary = {};

				for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

					mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

			}

		}

	}

	function createPrimitiveKey( primitiveDef ) {

		const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
		let geometryKey;

		if ( dracoExtension ) {

			geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey( dracoExtension.attributes );

		} else {

			geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

		}

		return geometryKey;

	}

	function createAttributesKey( attributes ) {

		let attributesKey = '';
		const keys = Object.keys( attributes ).sort();

		for ( let i = 0, il = keys.length; i < il; i ++ ) {

			attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

		}

		return attributesKey;

	}

	function getNormalizedComponentScale( constructor ) {

		// Reference:
		// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
		switch ( constructor ) {

			case Int8Array:
				return 1 / 127;

			case Uint8Array:
				return 1 / 255;

			case Int16Array:
				return 1 / 32767;

			case Uint16Array:
				return 1 / 65535;

			default:
				throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

		}

	}
	/* GLTF PARSER */


	class GLTFParser {

		constructor( json = {}, options = {} ) {

			this.json = json;
			this.extensions = {};
			this.plugins = {};
			this.options = options; // loader object cache

			this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements

			this.associations = new Map(); // THREE.BufferGeometry caching

			this.primitiveCache = {}; // THREE.Object3D instance caches

			this.meshCache = {
				refs: {},
				uses: {}
			};
			this.cameraCache = {
				refs: {},
				uses: {}
			};
			this.lightCache = {
				refs: {},
				uses: {}
			}; // Track node names, to ensure no duplicates

			this.nodeNamesUsed = {}; // Use an THREE.ImageBitmapLoader if imageBitmaps are supported. Moves much of the
			// expensive work of uploading a texture to the GPU off the main thread.

			if ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {

				this.textureLoader = new THREE.ImageBitmapLoader( this.options.manager );

			} else {

				this.textureLoader = new THREE.TextureLoader( this.options.manager );

			}

			this.textureLoader.setCrossOrigin( this.options.crossOrigin );
			this.textureLoader.setRequestHeader( this.options.requestHeader );
			this.fileLoader = new THREE.FileLoader( this.options.manager );
			this.fileLoader.setResponseType( 'arraybuffer' );

			if ( this.options.crossOrigin === 'use-credentials' ) {

				this.fileLoader.setWithCredentials( true );

			}

		}

		setExtensions( extensions ) {

			this.extensions = extensions;

		}

		setPlugins( plugins ) {

			this.plugins = plugins;

		}

		parse( onLoad, onError ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions; // Clear the loader cache

			this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

			this._invokeAll( function ( ext ) {

				return ext._markDefs && ext._markDefs();

			} );

			Promise.all( this._invokeAll( function ( ext ) {

				return ext.beforeRoot && ext.beforeRoot();

			} ) ).then( function () {

				return Promise.all( [ parser.getDependencies( 'scene' ), parser.getDependencies( 'animation' ), parser.getDependencies( 'camera' ) ] );

			} ).then( function ( dependencies ) {

				const result = {
					scene: dependencies[ 0 ][ json.scene || 0 ],
					scenes: dependencies[ 0 ],
					animations: dependencies[ 1 ],
					cameras: dependencies[ 2 ],
					asset: json.asset,
					parser: parser,
					userData: {}
				};
				addUnknownExtensionsToUserData( extensions, result, json );
				assignExtrasToUserData( result, json );
				Promise.all( parser._invokeAll( function ( ext ) {

					return ext.afterRoot && ext.afterRoot( result );

				} ) ).then( function () {

					onLoad( result );

				} );

			} ).catch( onError );

		}
		/**
   * Marks the special nodes/meshes in json for efficient parse.
   */


		_markDefs() {

			const nodeDefs = this.json.nodes || [];
			const skinDefs = this.json.skins || [];
			const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a THREE.Bone or an
			// THREE.Object3D. Use the skins' joint references to mark bones.

			for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

				const joints = skinDefs[ skinIndex ].joints;

				for ( let i = 0, il = joints.length; i < il; i ++ ) {

					nodeDefs[ joints[ i ] ].isBone = true;

				}

			} // Iterate over all nodes, marking references to shared resources,
			// as well as skeleton joints.


			for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

				const nodeDef = nodeDefs[ nodeIndex ];

				if ( nodeDef.mesh !== undefined ) {

					this._addNodeRef( this.meshCache, nodeDef.mesh ); // Nothing in the mesh definition indicates whether it is
					// a THREE.SkinnedMesh or THREE.Mesh. Use the node's mesh reference
					// to mark THREE.SkinnedMesh if node has skin.


					if ( nodeDef.skin !== undefined ) {

						meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

					}

				}

				if ( nodeDef.camera !== undefined ) {

					this._addNodeRef( this.cameraCache, nodeDef.camera );

				}

			}

		}
		/**
   * Counts references to shared node / THREE.Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. THREE.Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */


		_addNodeRef( cache, index ) {

			if ( index === undefined ) return;

			if ( cache.refs[ index ] === undefined ) {

				cache.refs[ index ] = cache.uses[ index ] = 0;

			}

			cache.refs[ index ] ++;

		}
		/** Returns a reference to a shared resource, cloning it if necessary. */


		_getNodeRef( cache, index, object ) {

			if ( cache.refs[ index ] <= 1 ) return object;
			const ref = object.clone();
			ref.name += '_instance_' + cache.uses[ index ] ++;
			return ref;

		}

		_invokeOne( func ) {

			const extensions = Object.values( this.plugins );
			extensions.push( this );

			for ( let i = 0; i < extensions.length; i ++ ) {

				const result = func( extensions[ i ] );
				if ( result ) return result;

			}

			return null;

		}

		_invokeAll( func ) {

			const extensions = Object.values( this.plugins );
			extensions.unshift( this );
			const pending = [];

			for ( let i = 0; i < extensions.length; i ++ ) {

				const result = func( extensions[ i ] );
				if ( result ) pending.push( result );

			}

			return pending;

		}
		/**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */


		getDependency( type, index ) {

			const cacheKey = type + ':' + index;
			let dependency = this.cache.get( cacheKey );

			if ( ! dependency ) {

				switch ( type ) {

					case 'scene':
						dependency = this.loadScene( index );
						break;

					case 'node':
						dependency = this.loadNode( index );
						break;

					case 'mesh':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMesh && ext.loadMesh( index );

						} );
						break;

					case 'accessor':
						dependency = this.loadAccessor( index );
						break;

					case 'bufferView':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadBufferView && ext.loadBufferView( index );

						} );
						break;

					case 'buffer':
						dependency = this.loadBuffer( index );
						break;

					case 'material':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadMaterial && ext.loadMaterial( index );

						} );
						break;

					case 'texture':
						dependency = this._invokeOne( function ( ext ) {

							return ext.loadTexture && ext.loadTexture( index );

						} );
						break;

					case 'skin':
						dependency = this.loadSkin( index );
						break;

					case 'animation':
						dependency = this.loadAnimation( index );
						break;

					case 'camera':
						dependency = this.loadCamera( index );
						break;

					default:
						throw new Error( 'Unknown type: ' + type );

				}

				this.cache.add( cacheKey, dependency );

			}

			return dependency;

		}
		/**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */


		getDependencies( type ) {

			let dependencies = this.cache.get( type );

			if ( ! dependencies ) {

				const parser = this;
				const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];
				dependencies = Promise.all( defs.map( function ( def, index ) {

					return parser.getDependency( type, index );

				} ) );
				this.cache.add( type, dependencies );

			}

			return dependencies;

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */


		loadBuffer( bufferIndex ) {

			const bufferDef = this.json.buffers[ bufferIndex ];
			const loader = this.fileLoader;

			if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

				throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

			} // If present, GLB container is required to be the first buffer.


			if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

				return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

			}

			const options = this.options;
			return new Promise( function ( resolve, reject ) {

				loader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

					reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

				} );

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */


		loadBufferView( bufferViewIndex ) {

			const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];
			return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

				const byteLength = bufferViewDef.byteLength || 0;
				const byteOffset = bufferViewDef.byteOffset || 0;
				return buffer.slice( byteOffset, byteOffset + byteLength );

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */


		loadAccessor( accessorIndex ) {

			const parser = this;
			const json = this.json;
			const accessorDef = this.json.accessors[ accessorIndex ];

			if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

				// Ignore empty accessors, which may be used to declare runtime
				// information about attributes coming from another source (e.g. Draco
				// compression extension).
				return Promise.resolve( null );

			}

			const pendingBufferViews = [];

			if ( accessorDef.bufferView !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

			} else {

				pendingBufferViews.push( null );

			}

			if ( accessorDef.sparse !== undefined ) {

				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
				pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

			}

			return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

				const bufferView = bufferViews[ 0 ];
				const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
				const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

				const elementBytes = TypedArray.BYTES_PER_ELEMENT;
				const itemBytes = elementBytes * itemSize;
				const byteOffset = accessorDef.byteOffset || 0;
				const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
				const normalized = accessorDef.normalized === true;
				let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

				if ( byteStride && byteStride !== itemBytes ) {

					// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own THREE.InterleavedBuffer
					// This makes sure that IBA.count reflects accessor.count properly
					const ibSlice = Math.floor( byteOffset / byteStride );
					const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
					let ib = parser.cache.get( ibCacheKey );

					if ( ! ib ) {

						array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes ); // Integer parameters to IB/IBA are in array elements, not bytes.

						ib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );
						parser.cache.add( ibCacheKey, ib );

					}

					bufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset % byteStride / elementBytes, normalized );

				} else {

					if ( bufferView === null ) {

						array = new TypedArray( accessorDef.count * itemSize );

					} else {

						array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

					}

					bufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );

				} // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


				if ( accessorDef.sparse !== undefined ) {

					const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
					const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];
					const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
					const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
					const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
					const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

					if ( bufferView !== null ) {

						// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
						bufferAttribute = new THREE.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

					}

					for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

						const index = sparseIndices[ i ];
						bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
						if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
						if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
						if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
						if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.' );

					}

				}

				return bufferAttribute;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */


		loadTexture( textureIndex ) {

			const json = this.json;
			const options = this.options;
			const textureDef = json.textures[ textureIndex ];
			const source = json.images[ textureDef.source ];
			let loader = this.textureLoader;

			if ( source.uri ) {

				const handler = options.manager.getHandler( source.uri );
				if ( handler !== null ) loader = handler;

			}

			return this.loadTextureImage( textureIndex, source, loader );

		}

		loadTextureImage( textureIndex, source, loader ) {

			const parser = this;
			const json = this.json;
			const options = this.options;
			const textureDef = json.textures[ textureIndex ];
			const URL = self.URL || self.webkitURL;
			let sourceURI = source.uri;
			let isObjectURL = false;
			let hasAlpha = true;
			if ( source.mimeType === 'image/jpeg' ) hasAlpha = false;

			if ( source.bufferView !== undefined ) {

				// Load binary image data from bufferView, if provided.
				sourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {

					if ( source.mimeType === 'image/png' ) {

						// Inspect the PNG 'IHDR' chunk to determine whether the image could have an
						// alpha channel. This check is conservative — the image could have an alpha
						// channel with all values == 1, and the indexed type (colorType == 3) only
						// sometimes contains alpha.
						//
						// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
						const colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );
						hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;

					}

					isObjectURL = true;
					const blob = new Blob( [ bufferView ], {
						type: source.mimeType
					} );
					sourceURI = URL.createObjectURL( blob );
					return sourceURI;

				} );

			} else if ( source.uri === undefined ) {

				throw new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );

			}

			return Promise.resolve( sourceURI ).then( function ( sourceURI ) {

				return new Promise( function ( resolve, reject ) {

					let onLoad = resolve;

					if ( loader.isImageBitmapLoader === true ) {

						onLoad = function ( imageBitmap ) {

							resolve( new THREE.CanvasTexture( imageBitmap ) );

						};

					}

					loader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

				} );

			} ).then( function ( texture ) {

				// Clean up resources and configure Texture.
				if ( isObjectURL === true ) {

					URL.revokeObjectURL( sourceURI );

				}

				texture.flipY = false;
				if ( textureDef.name ) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set THREE.RGBFormat to save space.

				if ( ! hasAlpha ) texture.format = THREE.RGBFormat;
				const samplers = json.samplers || {};
				const sampler = samplers[ textureDef.sampler ] || {};
				texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;
				texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipmapLinearFilter;
				texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;
				texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;
				parser.associations.set( texture, {
					type: 'textures',
					index: textureIndex
				} );
				return texture;

			} );

		}
		/**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise}
   */


		assignTexture( materialParams, mapName, mapDef ) {

			const parser = this;
			return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

				// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
				// However, we will copy UV set 0 to UV set 1 on demand for aoMap
				if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

					console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

				}

				if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

					const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

					if ( transform ) {

						const gltfReference = parser.associations.get( texture );
						texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
						parser.associations.set( texture, gltfReference );

					}

				}

				materialParams[ mapName ] = texture;

			} );

		}
		/**
   * Assigns final material to a THREE.Mesh, THREE.Line, or THREE.Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh THREE.Mesh, THREE.Line, or THREE.Points instance.
   */


		assignFinalMaterial( mesh ) {

			const geometry = mesh.geometry;
			let material = mesh.material;
			const useVertexTangents = geometry.attributes.tangent !== undefined;
			const useVertexColors = geometry.attributes.color !== undefined;
			const useFlatShading = geometry.attributes.normal === undefined;
			const useSkinning = mesh.isSkinnedMesh === true;
			const useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;
			const useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

			if ( mesh.isPoints ) {

				const cacheKey = 'PointsMaterial:' + material.uuid;
				let pointsMaterial = this.cache.get( cacheKey );

				if ( ! pointsMaterial ) {

					pointsMaterial = new THREE.PointsMaterial();
					THREE.Material.prototype.copy.call( pointsMaterial, material );
					pointsMaterial.color.copy( material.color );
					pointsMaterial.map = material.map;
					pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

					this.cache.add( cacheKey, pointsMaterial );

				}

				material = pointsMaterial;

			} else if ( mesh.isLine ) {

				const cacheKey = 'LineBasicMaterial:' + material.uuid;
				let lineMaterial = this.cache.get( cacheKey );

				if ( ! lineMaterial ) {

					lineMaterial = new THREE.LineBasicMaterial();
					THREE.Material.prototype.copy.call( lineMaterial, material );
					lineMaterial.color.copy( material.color );
					this.cache.add( cacheKey, lineMaterial );

				}

				material = lineMaterial;

			} // Clone the material if it will be modified


			if ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {

				let cacheKey = 'ClonedMaterial:' + material.uuid + ':';
				if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
				if ( useSkinning ) cacheKey += 'skinning:';
				if ( useVertexTangents ) cacheKey += 'vertex-tangents:';
				if ( useVertexColors ) cacheKey += 'vertex-colors:';
				if ( useFlatShading ) cacheKey += 'flat-shading:';
				if ( useMorphTargets ) cacheKey += 'morph-targets:';
				if ( useMorphNormals ) cacheKey += 'morph-normals:';
				let cachedMaterial = this.cache.get( cacheKey );

				if ( ! cachedMaterial ) {

					cachedMaterial = material.clone();
					if ( useSkinning ) cachedMaterial.skinning = true;
					if ( useVertexColors ) cachedMaterial.vertexColors = true;
					if ( useFlatShading ) cachedMaterial.flatShading = true;
					if ( useMorphTargets ) cachedMaterial.morphTargets = true;
					if ( useMorphNormals ) cachedMaterial.morphNormals = true;

					if ( useVertexTangents ) {

						cachedMaterial.vertexTangents = true; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995

						if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
						if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

					}

					this.cache.add( cacheKey, cachedMaterial );
					this.associations.set( cachedMaterial, this.associations.get( material ) );

				}

				material = cachedMaterial;

			} // workarounds for mesh and geometry


			if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

				geometry.setAttribute( 'uv2', geometry.attributes.uv );

			}

			mesh.material = material;

		}

		getMaterialType( ) {

			return THREE.MeshStandardMaterial;

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */


		loadMaterial( materialIndex ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;
			const materialDef = json.materials[ materialIndex ];
			let materialType;
			const materialParams = {};
			const materialExtensions = materialDef.extensions || {};
			const pending = [];

			if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

				const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
				materialType = sgExtension.getMaterialType();
				pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

			} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

				const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
				materialType = kmuExtension.getMaterialType();
				pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

			} else {

				// Specification:
				// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
				const metallicRoughness = materialDef.pbrMetallicRoughness || {};
				materialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );
				materialParams.opacity = 1.0;

				if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

					const array = metallicRoughness.baseColorFactor;
					materialParams.color.fromArray( array );
					materialParams.opacity = array[ 3 ];

				}

				if ( metallicRoughness.baseColorTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

				}

				materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
				materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

				if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

					pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
					pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

				}

				materialType = this._invokeOne( function ( ext ) {

					return ext.getMaterialType && ext.getMaterialType( materialIndex );

				} );
				pending.push( Promise.all( this._invokeAll( function ( ext ) {

					return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

				} ) ) );

			}

			if ( materialDef.doubleSided === true ) {

				materialParams.side = THREE.DoubleSide;

			}

			const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

			if ( alphaMode === ALPHA_MODES.BLEND ) {

				materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706

				materialParams.depthWrite = false;

			} else {

				materialParams.transparent = false;

				if ( alphaMode === ALPHA_MODES.MASK ) {

					materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

				}

			}

			if ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) ); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995

				materialParams.normalScale = new THREE.Vector2( 1, - 1 );

				if ( materialDef.normalTexture.scale !== undefined ) {

					materialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );

				}

			}

			if ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

				if ( materialDef.occlusionTexture.strength !== undefined ) {

					materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

				}

			}

			if ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				materialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );

			}

			if ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {

				pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

			}

			return Promise.all( pending ).then( function () {

				let material;

				if ( materialType === GLTFMeshStandardSGMaterial ) {

					material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

				} else {

					material = new materialType( materialParams );

				}

				if ( materialDef.name ) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

				if ( material.map ) material.map.encoding = THREE.sRGBEncoding;
				if ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;
				assignExtrasToUserData( material, materialDef );
				parser.associations.set( material, {
					type: 'materials',
					index: materialIndex
				} );
				if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );
				return material;

			} );

		}
		/** When THREE.Object3D instances are targeted by animation, they need unique names. */


		createUniqueName( originalName ) {

			const sanitizedName = THREE.PropertyBinding.sanitizeNodeName( originalName || '' );
			let name = sanitizedName;

			for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

				name = sanitizedName + '_' + i;

			}

			this.nodeNamesUsed[ name ] = true;
			return name;

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */


		loadGeometries( primitives ) {

			const parser = this;
			const extensions = this.extensions;
			const cache = this.primitiveCache;

			function createDracoPrimitive( primitive ) {

				return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ].decodePrimitive( primitive, parser ).then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

			}

			const pending = [];

			for ( let i = 0, il = primitives.length; i < il; i ++ ) {

				const primitive = primitives[ i ];
				const cacheKey = createPrimitiveKey( primitive ); // See if we've already created this geometry

				const cached = cache[ cacheKey ];

				if ( cached ) {

					// Use the cached geometry if it exists
					pending.push( cached.promise );

				} else {

					let geometryPromise;

					if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

						// Use DRACO geometry if available
						geometryPromise = createDracoPrimitive( primitive );

					} else {

						// Otherwise create a new geometry
						geometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );

					} // Cache this geometry


					cache[ cacheKey ] = {
						primitive: primitive,
						promise: geometryPromise
					};
					pending.push( geometryPromise );

				}

			}

			return Promise.all( pending );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */


		loadMesh( meshIndex ) {

			const parser = this;
			const json = this.json;
			const extensions = this.extensions;
			const meshDef = json.meshes[ meshIndex ];
			const primitives = meshDef.primitives;
			const pending = [];

			for ( let i = 0, il = primitives.length; i < il; i ++ ) {

				const material = primitives[ i ].material === undefined ? createDefaultMaterial( this.cache ) : this.getDependency( 'material', primitives[ i ].material );
				pending.push( material );

			}

			pending.push( parser.loadGeometries( primitives ) );
			return Promise.all( pending ).then( function ( results ) {

				const materials = results.slice( 0, results.length - 1 );
				const geometries = results[ results.length - 1 ];
				const meshes = [];

				for ( let i = 0, il = geometries.length; i < il; i ++ ) {

					const geometry = geometries[ i ];
					const primitive = primitives[ i ]; // 1. create THREE.Mesh

					let mesh;
					const material = materials[ i ];

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined ) {

						// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
						mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh( geometry, material ) : new THREE.Mesh( geometry, material );

						if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

							// we normalize floating point skin weight array to fix malformed assets (see #15319)
							// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
							mesh.normalizeSkinWeights();

						}

						if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleStripDrawMode );

						} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

							mesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleFanDrawMode );

						}

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

						mesh = new THREE.LineSegments( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

						mesh = new THREE.Line( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

						mesh = new THREE.LineLoop( geometry, material );

					} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

						mesh = new THREE.Points( geometry, material );

					} else {

						throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

					}

					if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

						updateMorphTargets( mesh, meshDef );

					}

					mesh.name = parser.createUniqueName( meshDef.name || 'mesh_' + meshIndex );
					assignExtrasToUserData( mesh, meshDef );
					if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );
					parser.assignFinalMaterial( mesh );
					meshes.push( mesh );

				}

				if ( meshes.length === 1 ) {

					return meshes[ 0 ];

				}

				const group = new THREE.Group();

				for ( let i = 0, il = meshes.length; i < il; i ++ ) {

					group.add( meshes[ i ] );

				}

				return group;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */


		loadCamera( cameraIndex ) {

			let camera;
			const cameraDef = this.json.cameras[ cameraIndex ];
			const params = cameraDef[ cameraDef.type ];

			if ( ! params ) {

				console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
				return;

			}

			if ( cameraDef.type === 'perspective' ) {

				camera = new THREE.PerspectiveCamera( THREE.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

			} else if ( cameraDef.type === 'orthographic' ) {

				camera = new THREE.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

			}

			if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );
			assignExtrasToUserData( camera, cameraDef );
			return Promise.resolve( camera );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */


		loadSkin( skinIndex ) {

			const skinDef = this.json.skins[ skinIndex ];
			const skinEntry = {
				joints: skinDef.joints
			};

			if ( skinDef.inverseBindMatrices === undefined ) {

				return Promise.resolve( skinEntry );

			}

			return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

				skinEntry.inverseBindMatrices = accessor;
				return skinEntry;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */


		loadAnimation( animationIndex ) {

			const json = this.json;
			const animationDef = json.animations[ animationIndex ];
			const pendingNodes = [];
			const pendingInputAccessors = [];
			const pendingOutputAccessors = [];
			const pendingSamplers = [];
			const pendingTargets = [];

			for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

				const channel = animationDef.channels[ i ];
				const sampler = animationDef.samplers[ channel.sampler ];
				const target = channel.target;
				const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

				const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
				const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;
				pendingNodes.push( this.getDependency( 'node', name ) );
				pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
				pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
				pendingSamplers.push( sampler );
				pendingTargets.push( target );

			}

			return Promise.all( [ Promise.all( pendingNodes ), Promise.all( pendingInputAccessors ), Promise.all( pendingOutputAccessors ), Promise.all( pendingSamplers ), Promise.all( pendingTargets ) ] ).then( function ( dependencies ) {

				const nodes = dependencies[ 0 ];
				const inputAccessors = dependencies[ 1 ];
				const outputAccessors = dependencies[ 2 ];
				const samplers = dependencies[ 3 ];
				const targets = dependencies[ 4 ];
				const tracks = [];

				for ( let i = 0, il = nodes.length; i < il; i ++ ) {

					const node = nodes[ i ];
					const inputAccessor = inputAccessors[ i ];
					const outputAccessor = outputAccessors[ i ];
					const sampler = samplers[ i ];
					const target = targets[ i ];
					if ( node === undefined ) continue;
					node.updateMatrix();
					node.matrixAutoUpdate = true;
					let TypedKeyframeTrack;

					switch ( PATH_PROPERTIES[ target.path ] ) {

						case PATH_PROPERTIES.weights:
							TypedKeyframeTrack = THREE.NumberKeyframeTrack;
							break;

						case PATH_PROPERTIES.rotation:
							TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
							break;

						case PATH_PROPERTIES.position:
						case PATH_PROPERTIES.scale:
						default:
							TypedKeyframeTrack = THREE.VectorKeyframeTrack;
							break;

					}

					const targetName = node.name ? node.name : node.uuid;
					const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;
					const targetNames = [];

					if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

						// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.
						node.traverse( function ( object ) {

							if ( object.isMesh === true && object.morphTargetInfluences ) {

								targetNames.push( object.name ? object.name : object.uuid );

							}

						} );

					} else {

						targetNames.push( targetName );

					}

					let outputArray = outputAccessor.array;

					if ( outputAccessor.normalized ) {

						const scale = getNormalizedComponentScale( outputArray.constructor );
						const scaled = new Float32Array( outputArray.length );

						for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

							scaled[ j ] = outputArray[ j ] * scale;

						}

						outputArray = scaled;

					}

					for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

						const track = new TypedKeyframeTrack( targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ], inputAccessor.array, outputArray, interpolation ); // Override interpolation with custom factory method.

						if ( sampler.interpolation === 'CUBICSPLINE' ) {

							track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

								// A CUBICSPLINE keyframe in glTF has three output values for each input value,
								// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
								// must be divided by three to get the interpolant's sampleSize argument.
								return new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );

							}; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


							track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

						}

						tracks.push( track );

					}

				}

				const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
				return new THREE.AnimationClip( name, undefined, tracks );

			} );

		}

		createNodeMesh( nodeIndex ) {

			const json = this.json;
			const parser = this;
			const nodeDef = json.nodes[ nodeIndex ];
			if ( nodeDef.mesh === undefined ) return null;
			return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

				const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh ); // if weights are provided on the node, override weights on the mesh.


				if ( nodeDef.weights !== undefined ) {

					node.traverse( function ( o ) {

						if ( ! o.isMesh ) return;

						for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

							o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

						}

					} );

				}

				return node;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */


		loadNode( nodeIndex ) {

			const json = this.json;
			const extensions = this.extensions;
			const parser = this;
			const nodeDef = json.nodes[ nodeIndex ]; // reserve node's name before its dependencies, so the root has the intended name.

			const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';
			return function () {

				const pending = [];

				const meshPromise = parser._invokeOne( function ( ext ) {

					return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

				} );

				if ( meshPromise ) {

					pending.push( meshPromise );

				}

				if ( nodeDef.camera !== undefined ) {

					pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

						return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

					} ) );

				}

				parser._invokeAll( function ( ext ) {

					return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

				} ).forEach( function ( promise ) {

					pending.push( promise );

				} );

				return Promise.all( pending );

			}().then( function ( objects ) {

				let node; // .isBone isn't in glTF spec. See ._markDefs

				if ( nodeDef.isBone === true ) {

					node = new THREE.Bone();

				} else if ( objects.length > 1 ) {

					node = new THREE.Group();

				} else if ( objects.length === 1 ) {

					node = objects[ 0 ];

				} else {

					node = new THREE.Object3D();

				}

				if ( node !== objects[ 0 ] ) {

					for ( let i = 0, il = objects.length; i < il; i ++ ) {

						node.add( objects[ i ] );

					}

				}

				if ( nodeDef.name ) {

					node.userData.name = nodeDef.name;
					node.name = nodeName;

				}

				assignExtrasToUserData( node, nodeDef );
				if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

				if ( nodeDef.matrix !== undefined ) {

					const matrix = new THREE.Matrix4();
					matrix.fromArray( nodeDef.matrix );
					node.applyMatrix4( matrix );

				} else {

					if ( nodeDef.translation !== undefined ) {

						node.position.fromArray( nodeDef.translation );

					}

					if ( nodeDef.rotation !== undefined ) {

						node.quaternion.fromArray( nodeDef.rotation );

					}

					if ( nodeDef.scale !== undefined ) {

						node.scale.fromArray( nodeDef.scale );

					}

				}

				parser.associations.set( node, {
					type: 'nodes',
					index: nodeIndex
				} );
				return node;

			} );

		}
		/**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */


		loadScene( sceneIndex ) {

			const json = this.json;
			const extensions = this.extensions;
			const sceneDef = this.json.scenes[ sceneIndex ];
			const parser = this; // THREE.Loader returns THREE.Group, not Scene.
			// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172

			const scene = new THREE.Group();
			if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );
			assignExtrasToUserData( scene, sceneDef );
			if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );
			const nodeIds = sceneDef.nodes || [];
			const pending = [];

			for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

				pending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );

			}

			return Promise.all( pending ).then( function () {

				return scene;

			} );

		}

	}

	function buildNodeHierachy( nodeId, parentObject, json, parser ) {

		const nodeDef = json.nodes[ nodeId ];
		return parser.getDependency( 'node', nodeId ).then( function ( node ) {

			if ( nodeDef.skin === undefined ) return node; // build skeleton here as well

			let skinEntry;
			return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

				skinEntry = skin;
				const pendingJoints = [];

				for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

					pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

				}

				return Promise.all( pendingJoints );

			} ).then( function ( jointNodes ) {

				node.traverse( function ( mesh ) {

					if ( ! mesh.isMesh ) return;
					const bones = [];
					const boneInverses = [];

					for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

						const jointNode = jointNodes[ j ];

						if ( jointNode ) {

							bones.push( jointNode );
							const mat = new THREE.Matrix4();

							if ( skinEntry.inverseBindMatrices !== undefined ) {

								mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

							}

							boneInverses.push( mat );

						} else {

							console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

						}

					}

					mesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );

				} );
				return node;

			} );

		} ).then( function ( node ) {

			// build node hierachy
			parentObject.add( node );
			const pending = [];

			if ( nodeDef.children ) {

				const children = nodeDef.children;

				for ( let i = 0, il = children.length; i < il; i ++ ) {

					const child = children[ i ];
					pending.push( buildNodeHierachy( child, node, json, parser ) );

				}

			}

			return Promise.all( pending );

		} );

	}
	/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */


	function computeBounds( geometry, primitiveDef, parser ) {

		const attributes = primitiveDef.attributes;
		const box = new THREE.Box3();

		if ( attributes.POSITION !== undefined ) {

			const accessor = parser.json.accessors[ attributes.POSITION ];
			const min = accessor.min;
			const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

			if ( min !== undefined && max !== undefined ) {

				box.set( new THREE.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ), new THREE.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );

				if ( accessor.normalized ) {

					const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
					box.min.multiplyScalar( boxScale );
					box.max.multiplyScalar( boxScale );

				}

			} else {

				console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );
				return;

			}

		} else {

			return;

		}

		const targets = primitiveDef.targets;

		if ( targets !== undefined ) {

			const maxDisplacement = new THREE.Vector3();
			const vector = new THREE.Vector3();

			for ( let i = 0, il = targets.length; i < il; i ++ ) {

				const target = targets[ i ];

				if ( target.POSITION !== undefined ) {

					const accessor = parser.json.accessors[ target.POSITION ];
					const min = accessor.min;
					const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

					if ( min !== undefined && max !== undefined ) {

						// we need to get max of absolute components because target weight is [-1,1]
						vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
						vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
						vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );

						if ( accessor.normalized ) {

							const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
							vector.multiplyScalar( boxScale );

						} // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
						// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
						// are used to implement key-frame animations and as such only two are active at a time - this results in very large
						// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.


						maxDisplacement.max( vector );

					} else {

						console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

					}

				}

			} // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.


			box.expandByVector( maxDisplacement );

		}

		geometry.boundingBox = box;
		const sphere = new THREE.Sphere();
		box.getCenter( sphere.center );
		sphere.radius = box.min.distanceTo( box.max ) / 2;
		geometry.boundingSphere = sphere;

	}
	/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */


	function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

		const attributes = primitiveDef.attributes;
		const pending = [];

		function assignAttributeAccessor( accessorIndex, attributeName ) {

			return parser.getDependency( 'accessor', accessorIndex ).then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

		}

		for ( const gltfAttributeName in attributes ) {

			const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

			if ( threeAttributeName in geometry.attributes ) continue;
			pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

		}

		if ( primitiveDef.indices !== undefined && ! geometry.index ) {

			const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

				geometry.setIndex( accessor );

			} );
			pending.push( accessor );

		}

		assignExtrasToUserData( geometry, primitiveDef );
		computeBounds( geometry, primitiveDef, parser );
		return Promise.all( pending ).then( function () {

			return primitiveDef.targets !== undefined ? addMorphTargets( geometry, primitiveDef.targets, parser ) : geometry;

		} );

	}
	/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */


	function toTrianglesDrawMode( geometry, drawMode ) {

		let index = geometry.getIndex(); // generate index if not present

		if ( index === null ) {

			const indices = [];
			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		} //


		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === THREE.TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN
			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP
			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( newIndices.length / 3 !== numberOfTriangles ) {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		} // build final geometry


		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		return newGeometry;

	}

	THREE.GLTFLoader = GLTFLoader;

} )();

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

	var _trimExp = /(?:^\s+|\s+$)/g;
	var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
	function getText(e) {
	  var type = e.nodeType,
	      result = "";

	  if (type === 1 || type === 9 || type === 11) {
	    if (typeof e.textContent === "string") {
	      return e.textContent;
	    } else {
	      for (e = e.firstChild; e; e = e.nextSibling) {
	        result += getText(e);
	      }
	    }
	  } else if (type === 3 || type === 4) {
	    return e.nodeValue;
	  }

	  return result;
	}
	function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {
	  text += "";
	  trim && (text = text.trim ? text.trim() : text.replace(_trimExp, ""));

	  if (delimiter && delimiter !== "") {
	    return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
	  }

	  var result = [],
	      l = text.length,
	      i = 0,
	      j,
	      character;

	  for (; i < l; i++) {
	    character = text.charAt(i);

	    if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {
	      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;
	      character = text.substr(i, j);
	      result.emoji = 1;
	      i += j - 1;
	    }

	    result.push(character === ">" ? "&gt;" : character === "<" ? "&lt;" : preserveSpaces && character === " " && (text.charAt(i - 1) === " " || text.charAt(i + 1) === " ") ? "&nbsp;" : character);
	  }

	  return result;
	}

	/*!
	 * ScrambleTextPlugin 3.12.5
	 * https://gsap.com
	 *
	 * @license Copyright 2008-2024, GreenSock. All rights reserved.
	 * Subject to the terms at https://gsap.com/standard-license or for
	 * Club GSAP members, the agreement issued with that membership.
	 * @author: Jack Doyle, jack@greensock.com
	*/

	var CharSet = function () {
	  function CharSet(chars) {
	    this.chars = emojiSafeSplit(chars);
	    this.sets = [];
	    this.length = 50;

	    for (var i = 0; i < 20; i++) {
	      this.sets[i] = _scrambleText(80, this.chars);
	    }
	  }

	  var _proto = CharSet.prototype;

	  _proto.grow = function grow(newLength) {
	    for (var i = 0; i < 20; i++) {
	      this.sets[i] += _scrambleText(newLength - this.length, this.chars);
	    }

	    this.length = newLength;
	  };

	  return CharSet;
	}();

	var gsap,
	    _coreInitted,
	    _getGSAP = function _getGSAP() {
	  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
	},
	    _bonusValidated = 1,
	    _spacesExp = /\s+/g,
	    _scrambleText = function _scrambleText(length, chars) {
	  var l = chars.length,
	      s = "";

	  while (--length > -1) {
	    s += chars[~~(Math.random() * l)];
	  }

	  return s;
	},
	    _upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
	    _lower = _upper.toLowerCase(),
	    _charsLookup = {
	  upperCase: new CharSet(_upper),
	  lowerCase: new CharSet(_lower),
	  upperAndLowerCase: new CharSet(_upper + _lower)
	},
	    _initCore = function _initCore() {
	  _coreInitted = gsap = _getGSAP();
	};

	var ScrambleTextPlugin = {
	  version: "3.12.5",
	  name: "scrambleText",
	  register: function register(core, Plugin, propTween) {
	    gsap = core;

	    _initCore();
	  },
	  init: function init(target, value, tween, index, targets) {
	    _coreInitted || _initCore();
	    this.prop = "innerHTML" in target ? "innerHTML" : "textContent" in target ? "textContent" : 0;

	    if (!this.prop) {
	      return;
	    }

	    this.target = target;

	    if (typeof value !== "object") {
	      value = {
	        text: value
	      };
	    }

	    var text = value.text || value.value || "",
	        trim = value.trim !== false,
	        data = this,
	        delim,
	        maxLength,
	        charset,
	        splitByChars;
	    data.delimiter = delim = value.delimiter || "";
	    data.original = emojiSafeSplit(getText(target).replace(_spacesExp, " ").split("&nbsp;").join(""), delim, trim);

	    if (text === "{original}" || text === true || text == null) {
	      text = data.original.join(delim);
	    }

	    data.text = emojiSafeSplit((text || "").replace(_spacesExp, " "), delim, trim);
	    data.hasClass = !!(value.newClass || value.oldClass);
	    data.newClass = value.newClass;
	    data.oldClass = value.oldClass;
	    splitByChars = delim === "";
	    data.textHasEmoji = splitByChars && !!data.text.emoji;
	    data.charsHaveEmoji = !!value.chars && !!emojiSafeSplit(value.chars).emoji;
	    data.length = splitByChars ? data.original.length : data.original.join(delim).length;
	    data.lengthDif = (splitByChars ? data.text.length : data.text.join(delim).length) - data.length;
	    data.fillChar = value.fillChar || value.chars && ~value.chars.indexOf(" ") ? "&nbsp;" : "";
	    data.charSet = charset = _charsLookup[value.chars || "upperCase"] || new CharSet(value.chars);
	    data.speed = 0.05 / (value.speed || 1);
	    data.prevScrambleTime = 0;
	    data.setIndex = Math.random() * 20 | 0;
	    maxLength = data.length + Math.max(data.lengthDif, 0);

	    if (maxLength > charset.length) {
	      charset.grow(maxLength);
	    }

	    data.chars = charset.sets[data.setIndex];
	    data.revealDelay = value.revealDelay || 0;
	    data.tweenLength = value.tweenLength !== false;
	    data.tween = tween;
	    data.rightToLeft = !!value.rightToLeft;

	    data._props.push("scrambleText", "text");

	    return _bonusValidated;
	  },
	  render: function render(ratio, data) {
	    var target = data.target,
	        prop = data.prop,
	        text = data.text,
	        delimiter = data.delimiter,
	        tween = data.tween,
	        prevScrambleTime = data.prevScrambleTime,
	        revealDelay = data.revealDelay,
	        setIndex = data.setIndex,
	        chars = data.chars,
	        charSet = data.charSet,
	        length = data.length,
	        textHasEmoji = data.textHasEmoji,
	        charsHaveEmoji = data.charsHaveEmoji,
	        lengthDif = data.lengthDif,
	        tweenLength = data.tweenLength,
	        oldClass = data.oldClass,
	        newClass = data.newClass,
	        rightToLeft = data.rightToLeft,
	        fillChar = data.fillChar,
	        speed = data.speed,
	        original = data.original,
	        hasClass = data.hasClass,
	        l = text.length,
	        time = tween._time,
	        timeDif = time - prevScrambleTime,
	        i,
	        i2,
	        startText,
	        endText,
	        applyNew,
	        applyOld,
	        str,
	        startClass,
	        endClass,
	        position,
	        r;

	    if (revealDelay) {
	      if (tween._from) {
	        time = tween._dur - time;
	      }

	      ratio = time === 0 ? 0 : time < revealDelay ? 0.000001 : time === tween._dur ? 1 : tween._ease((time - revealDelay) / (tween._dur - revealDelay));
	    }

	    if (ratio < 0) {
	      ratio = 0;
	    } else if (ratio > 1) {
	      ratio = 1;
	    }

	    if (rightToLeft) {
	      ratio = 1 - ratio;
	    }

	    i = ~~(ratio * l + 0.5);

	    if (ratio) {
	      if (timeDif > speed || timeDif < -speed) {
	        data.setIndex = setIndex = (setIndex + (Math.random() * 19 | 0)) % 20;
	        data.chars = charSet.sets[setIndex];
	        data.prevScrambleTime += timeDif;
	      }

	      endText = chars;
	    } else {
	      endText = original.join(delimiter);
	    }

	    r = tween._from ? ratio : 1 - ratio;
	    position = length + (tweenLength ? tween._from ? r * r * r : 1 - r * r * r : 1) * lengthDif;

	    if (rightToLeft) {
	      if (ratio === 1 && (tween._from || tween.data === "isFromStart")) {
	        startText = "";
	        endText = original.join(delimiter);
	      } else {
	        str = text.slice(i).join(delimiter);

	        if (charsHaveEmoji) {
	          startText = emojiSafeSplit(endText).slice(0, position - (textHasEmoji ? emojiSafeSplit(str) : str).length + 0.5 | 0).join("");
	        } else {
	          startText = endText.substr(0, position - (textHasEmoji ? emojiSafeSplit(str) : str).length + 0.5 | 0);
	        }

	        endText = str;
	      }
	    } else {
	      startText = text.slice(0, i).join(delimiter);
	      i2 = (textHasEmoji ? emojiSafeSplit(startText) : startText).length;

	      if (charsHaveEmoji) {
	        endText = emojiSafeSplit(endText).slice(i2, position + 0.5 | 0).join("");
	      } else {
	        endText = endText.substr(i2, position - i2 + 0.5 | 0);
	      }
	    }

	    if (hasClass) {
	      startClass = rightToLeft ? oldClass : newClass;
	      endClass = rightToLeft ? newClass : oldClass;
	      applyNew = startClass && i !== 0;
	      applyOld = endClass && i !== l;
	      str = (applyNew ? "<span class='" + startClass + "'>" : "") + startText + (applyNew ? "</span>" : "") + (applyOld ? "<span class='" + endClass + "'>" : "") + delimiter + endText + (applyOld ? "</span>" : "");
	    } else {
	      str = startText + delimiter + endText;
	    }

	    target[prop] = fillChar === "&nbsp;" && ~str.indexOf("  ") ? str.split("  ").join("&nbsp;&nbsp;") : str;
	  }
	};
	ScrambleTextPlugin.emojiSafeSplit = emojiSafeSplit;
	ScrambleTextPlugin.getText = getText;
	_getGSAP() && gsap.registerPlugin(ScrambleTextPlugin);

	exports.ScrambleTextPlugin = ScrambleTextPlugin;
	exports.default = ScrambleTextPlugin;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

	var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
	function getText(e) {
	  var type = e.nodeType,
	      result = "";

	  if (type === 1 || type === 9 || type === 11) {
	    if (typeof e.textContent === "string") {
	      return e.textContent;
	    } else {
	      for (e = e.firstChild; e; e = e.nextSibling) {
	        result += getText(e);
	      }
	    }
	  } else if (type === 3 || type === 4) {
	    return e.nodeValue;
	  }

	  return result;
	}

	/*!
	 * SplitText: 3.12.5
	 * https://gsap.com
	 *
	 * @license Copyright 2008-2024, GreenSock. All rights reserved.
	 * Subject to the terms at https://gsap.com/standard-license or for
	 * Club GSAP members, the agreement issued with that membership.
	 * @author: Jack Doyle, jack@greensock.com
	*/

	var _doc,
	    _win,
	    _coreInitted,
	    gsap,
	    _context,
	    _toArray,
	    _stripExp = /(?:\r|\n|\t\t)/g,
	    _multipleSpacesExp = /(?:\s\s+)/g,
	    _nonBreakingSpace = String.fromCharCode(160),
	    _initCore = function _initCore(core) {
	  _doc = document;
	  _win = window;
	  gsap = gsap || core || _win.gsap || console.warn("Please gsap.registerPlugin(SplitText)");

	  if (gsap) {
	    _toArray = gsap.utils.toArray;

	    _context = gsap.core.context || function () {};

	    _coreInitted = 1;
	  }
	},
	    _getComputedStyle = function _getComputedStyle(element) {
	  return _win.getComputedStyle(element);
	},
	    _isAbsolute = function _isAbsolute(vars) {
	  return vars.position === "absolute" || vars.absolute === true;
	},
	    _findSpecialChars = function _findSpecialChars(text, chars) {
	  var i = chars.length,
	      s;

	  while (--i > -1) {
	    s = chars[i];

	    if (text.substr(0, s.length) === s) {
	      return s.length;
	    }
	  }
	},
	    _divStart = " style='position:relative;display:inline-block;'",
	    _cssClassFunc = function _cssClassFunc(cssClass, tag) {
	  if (cssClass === void 0) {
	    cssClass = "";
	  }

	  var iterate = ~cssClass.indexOf("++"),
	      num = 1;

	  if (iterate) {
	    cssClass = cssClass.split("++").join("");
	  }

	  return function () {
	    return "<" + tag + _divStart + (cssClass ? " class='" + cssClass + (iterate ? num++ : "") + "'>" : ">");
	  };
	},
	    _swapText = function _swapText(element, oldText, newText) {
	  var type = element.nodeType;

	  if (type === 1 || type === 9 || type === 11) {
	    for (element = element.firstChild; element; element = element.nextSibling) {
	      _swapText(element, oldText, newText);
	    }
	  } else if (type === 3 || type === 4) {
	    element.nodeValue = element.nodeValue.split(oldText).join(newText);
	  }
	},
	    _pushReversed = function _pushReversed(a, merge) {
	  var i = merge.length;

	  while (--i > -1) {
	    a.push(merge[i]);
	  }
	},
	    _isBeforeWordDelimiter = function _isBeforeWordDelimiter(e, root, wordDelimiter) {
	  var next;

	  while (e && e !== root) {
	    next = e._next || e.nextSibling;

	    if (next) {
	      return next.textContent.charAt(0) === wordDelimiter;
	    }

	    e = e.parentNode || e._parent;
	  }
	},
	    _deWordify = function _deWordify(e) {
	  var children = _toArray(e.childNodes),
	      l = children.length,
	      i,
	      child;

	  for (i = 0; i < l; i++) {
	    child = children[i];

	    if (child._isSplit) {
	      _deWordify(child);
	    } else {
	      if (i && child.previousSibling && child.previousSibling.nodeType === 3) {
	        child.previousSibling.nodeValue += child.nodeType === 3 ? child.nodeValue : child.firstChild.nodeValue;
	        e.removeChild(child);
	      } else if (child.nodeType !== 3) {
	        e.insertBefore(child.firstChild, child);
	        e.removeChild(child);
	      }
	    }
	  }
	},
	    _getStyleAsNumber = function _getStyleAsNumber(name, computedStyle) {
	  return parseFloat(computedStyle[name]) || 0;
	},
	    _setPositionsAfterSplit = function _setPositionsAfterSplit(element, vars, allChars, allWords, allLines, origWidth, origHeight) {
	  var cs = _getComputedStyle(element),
	      paddingLeft = _getStyleAsNumber("paddingLeft", cs),
	      lineOffsetY = -999,
	      borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs),
	      borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs),
	      padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs),
	      padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs),
	      lineThreshold = _getStyleAsNumber("fontSize", cs) * (vars.lineThreshold || 0.2),
	      textAlign = cs.textAlign,
	      charArray = [],
	      wordArray = [],
	      lineArray = [],
	      wordDelimiter = vars.wordDelimiter || " ",
	      tag = vars.tag ? vars.tag : vars.span ? "span" : "div",
	      types = vars.type || vars.split || "chars,words,lines",
	      lines = allLines && ~types.indexOf("lines") ? [] : null,
	      words = ~types.indexOf("words"),
	      chars = ~types.indexOf("chars"),
	      absolute = _isAbsolute(vars),
	      linesClass = vars.linesClass,
	      iterateLine = ~(linesClass || "").indexOf("++"),
	      spaceNodesToRemove = [],
	      isFlex = cs.display === "flex",
	      prevInlineDisplay = element.style.display,
	      i,
	      j,
	      l,
	      node,
	      nodes,
	      isChild,
	      curLine,
	      addWordSpaces,
	      style,
	      lineNode,
	      lineWidth,
	      offset;

	  iterateLine && (linesClass = linesClass.split("++").join(""));
	  isFlex && (element.style.display = "block");
	  j = element.getElementsByTagName("*");
	  l = j.length;
	  nodes = [];

	  for (i = 0; i < l; i++) {
	    nodes[i] = j[i];
	  }

	  if (lines || absolute) {
	    for (i = 0; i < l; i++) {
	      node = nodes[i];
	      isChild = node.parentNode === element;

	      if (isChild || absolute || chars && !words) {
	        offset = node.offsetTop;

	        if (lines && isChild && Math.abs(offset - lineOffsetY) > lineThreshold && (node.nodeName !== "BR" || i === 0)) {
	          curLine = [];
	          lines.push(curLine);
	          lineOffsetY = offset;
	        }

	        if (absolute) {
	          node._x = node.offsetLeft;
	          node._y = offset;
	          node._w = node.offsetWidth;
	          node._h = node.offsetHeight;
	        }

	        if (lines) {
	          if (node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) {
	            curLine.push(node);
	            node._x -= paddingLeft;

	            if (_isBeforeWordDelimiter(node, element, wordDelimiter)) {
	              node._wordEnd = true;
	            }
	          }

	          if (node.nodeName === "BR" && (node.nextSibling && node.nextSibling.nodeName === "BR" || i === 0)) {
	            lines.push([]);
	          }
	        }
	      }
	    }
	  }

	  for (i = 0; i < l; i++) {
	    node = nodes[i];
	    isChild = node.parentNode === element;

	    if (node.nodeName === "BR") {
	      if (lines || absolute) {
	        node.parentNode && node.parentNode.removeChild(node);
	        nodes.splice(i--, 1);
	        l--;
	      } else if (!words) {
	        element.appendChild(node);
	      }

	      continue;
	    }

	    if (absolute) {
	      style = node.style;

	      if (!words && !isChild) {
	        node._x += node.parentNode._x;
	        node._y += node.parentNode._y;
	      }

	      style.left = node._x + "px";
	      style.top = node._y + "px";
	      style.position = "absolute";
	      style.display = "block";
	      style.width = node._w + 1 + "px";
	      style.height = node._h + "px";
	    }

	    if (!words && chars) {
	      if (node._isSplit) {
	        node._next = j = node.nextSibling;
	        node.parentNode.appendChild(node);

	        while (j && j.nodeType === 3 && j.textContent === " ") {
	          node._next = j.nextSibling;
	          node.parentNode.appendChild(j);
	          j = j.nextSibling;
	        }
	      } else if (node.parentNode._isSplit) {
	        node._parent = node.parentNode;

	        if (!node.previousSibling && node.firstChild) {
	          node.firstChild._isFirst = true;
	        }

	        if (node.nextSibling && node.nextSibling.textContent === " " && !node.nextSibling.nextSibling) {
	          spaceNodesToRemove.push(node.nextSibling);
	        }

	        node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling;
	        node.parentNode.removeChild(node);
	        nodes.splice(i--, 1);
	        l--;
	      } else if (!isChild) {
	        offset = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter);
	        node.parentNode._parent && node.parentNode._parent.appendChild(node);
	        offset && node.parentNode.appendChild(_doc.createTextNode(" "));

	        if (tag === "span") {
	          node.style.display = "inline";
	        }

	        charArray.push(node);
	      }
	    } else if (node.parentNode._isSplit && !node._isSplit && node.innerHTML !== "") {
	      wordArray.push(node);
	    } else if (chars && !node._isSplit) {
	      if (tag === "span") {
	        node.style.display = "inline";
	      }

	      charArray.push(node);
	    }
	  }

	  i = spaceNodesToRemove.length;

	  while (--i > -1) {
	    spaceNodesToRemove[i].parentNode.removeChild(spaceNodesToRemove[i]);
	  }

	  if (lines) {
	    if (absolute) {
	      lineNode = _doc.createElement(tag);
	      element.appendChild(lineNode);
	      lineWidth = lineNode.offsetWidth + "px";
	      offset = lineNode.offsetParent === element ? 0 : element.offsetLeft;
	      element.removeChild(lineNode);
	    }

	    style = element.style.cssText;
	    element.style.cssText = "display:none;";

	    while (element.firstChild) {
	      element.removeChild(element.firstChild);
	    }

	    addWordSpaces = wordDelimiter === " " && (!absolute || !words && !chars);

	    for (i = 0; i < lines.length; i++) {
	      curLine = lines[i];
	      lineNode = _doc.createElement(tag);
	      lineNode.style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;");

	      if (linesClass) {
	        lineNode.className = linesClass + (iterateLine ? i + 1 : "");
	      }

	      lineArray.push(lineNode);
	      l = curLine.length;

	      for (j = 0; j < l; j++) {
	        if (curLine[j].nodeName !== "BR") {
	          node = curLine[j];
	          lineNode.appendChild(node);
	          addWordSpaces && node._wordEnd && lineNode.appendChild(_doc.createTextNode(" "));

	          if (absolute) {
	            if (j === 0) {
	              lineNode.style.top = node._y + "px";
	              lineNode.style.left = paddingLeft + offset + "px";
	            }

	            node.style.top = "0px";

	            if (offset) {
	              node.style.left = node._x - offset + "px";
	            }
	          }
	        }
	      }

	      if (l === 0) {
	        lineNode.innerHTML = "&nbsp;";
	      } else if (!words && !chars) {
	        _deWordify(lineNode);

	        _swapText(lineNode, String.fromCharCode(160), " ");
	      }

	      if (absolute) {
	        lineNode.style.width = lineWidth;
	        lineNode.style.height = node._h + "px";
	      }

	      element.appendChild(lineNode);
	    }

	    element.style.cssText = style;
	  }

	  if (absolute) {
	    if (origHeight > element.clientHeight) {
	      element.style.height = origHeight - padTopAndBottom + "px";

	      if (element.clientHeight < origHeight) {
	        element.style.height = origHeight + borderTopAndBottom + "px";
	      }
	    }

	    if (origWidth > element.clientWidth) {
	      element.style.width = origWidth - padLeftAndRight + "px";

	      if (element.clientWidth < origWidth) {
	        element.style.width = origWidth + borderLeftAndRight + "px";
	      }
	    }
	  }

	  isFlex && (prevInlineDisplay ? element.style.display = prevInlineDisplay : element.style.removeProperty("display"));

	  _pushReversed(allChars, charArray);

	  words && _pushReversed(allWords, wordArray);

	  _pushReversed(allLines, lineArray);
	},
	    _splitRawText = function _splitRawText(element, vars, wordStart, charStart) {
	  var tag = vars.tag ? vars.tag : vars.span ? "span" : "div",
	      types = vars.type || vars.split || "chars,words,lines",
	      chars = ~types.indexOf("chars"),
	      absolute = _isAbsolute(vars),
	      wordDelimiter = vars.wordDelimiter || " ",
	      isWordDelimiter = function isWordDelimiter(_char) {
	    return _char === wordDelimiter || _char === _nonBreakingSpace && wordDelimiter === " ";
	  },
	      space = wordDelimiter !== " " ? "" : absolute ? "&#173; " : " ",
	      wordEnd = "</" + tag + ">",
	      wordIsOpen = 1,
	      specialChars = vars.specialChars ? typeof vars.specialChars === "function" ? vars.specialChars : _findSpecialChars : null,
	      text,
	      splitText,
	      i,
	      j,
	      l,
	      character,
	      hasTagStart,
	      testResult,
	      container = _doc.createElement("div"),
	      parent = element.parentNode;

	  parent.insertBefore(container, element);
	  container.textContent = element.nodeValue;
	  parent.removeChild(element);
	  element = container;
	  text = getText(element);
	  hasTagStart = text.indexOf("<") !== -1;

	  if (vars.reduceWhiteSpace !== false) {
	    text = text.replace(_multipleSpacesExp, " ").replace(_stripExp, "");
	  }

	  if (hasTagStart) {
	    text = text.split("<").join("{{LT}}");
	  }

	  l = text.length;
	  splitText = (text.charAt(0) === " " ? space : "") + wordStart();

	  for (i = 0; i < l; i++) {
	    character = text.charAt(i);

	    if (specialChars && (testResult = specialChars(text.substr(i), vars.specialChars))) {
	      character = text.substr(i, testResult || 1);
	      splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
	      i += testResult - 1;
	    } else if (isWordDelimiter(character) && !isWordDelimiter(text.charAt(i - 1)) && i) {
	      splitText += wordIsOpen ? wordEnd : "";
	      wordIsOpen = 0;

	      while (isWordDelimiter(text.charAt(i + 1))) {
	        splitText += space;
	        i++;
	      }

	      if (i === l - 1) {
	        splitText += space;
	      } else if (text.charAt(i + 1) !== ")") {
	        splitText += space + wordStart();
	        wordIsOpen = 1;
	      }
	    } else if (character === "{" && text.substr(i, 6) === "{{LT}}") {
	      splitText += chars ? charStart() + "{{LT}}" + "</" + tag + ">" : "{{LT}}";
	      i += 5;
	    } else if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {
	      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;
	      splitText += chars && character !== " " ? charStart() + text.substr(i, j) + "</" + tag + ">" : text.substr(i, j);
	      i += j - 1;
	    } else {
	      splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;
	    }
	  }

	  element.outerHTML = splitText + (wordIsOpen ? wordEnd : "");
	  hasTagStart && _swapText(parent, "{{LT}}", "<");
	},
	    _split = function _split(element, vars, wordStart, charStart) {
	  var children = _toArray(element.childNodes),
	      l = children.length,
	      absolute = _isAbsolute(vars),
	      i,
	      child;

	  if (element.nodeType !== 3 || l > 1) {
	    vars.absolute = false;

	    for (i = 0; i < l; i++) {
	      child = children[i];
	      child._next = child._isFirst = child._parent = child._wordEnd = null;

	      if (child.nodeType !== 3 || /\S+/.test(child.nodeValue)) {
	        if (absolute && child.nodeType !== 3 && _getComputedStyle(child).display === "inline") {
	          child.style.display = "inline-block";
	          child.style.position = "relative";
	        }

	        child._isSplit = true;

	        _split(child, vars, wordStart, charStart);
	      }
	    }

	    vars.absolute = absolute;
	    element._isSplit = true;
	    return;
	  }

	  _splitRawText(element, vars, wordStart, charStart);
	};

	var SplitText = function () {
	  function SplitText(element, vars) {
	    _coreInitted || _initCore();
	    this.elements = _toArray(element);
	    this.chars = [];
	    this.words = [];
	    this.lines = [];
	    this._originals = [];
	    this.vars = vars || {};

	    _context(this);

	     this.split(vars);
	  }

	  var _proto = SplitText.prototype;

	  _proto.split = function split(vars) {
	    this.isSplit && this.revert();
	    this.vars = vars = vars || this.vars;
	    this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;

	    var i = this.elements.length,
	        tag = vars.tag ? vars.tag : vars.span ? "span" : "div",
	        wordStart = _cssClassFunc(vars.wordsClass, tag),
	        charStart = _cssClassFunc(vars.charsClass, tag),
	        origHeight,
	        origWidth,
	        e;

	    while (--i > -1) {
	      e = this.elements[i];
	      this._originals[i] = {
	        html: e.innerHTML,
	        style: e.getAttribute("style")
	      };
	      origHeight = e.clientHeight;
	      origWidth = e.clientWidth;

	      _split(e, vars, wordStart, charStart);

	      _setPositionsAfterSplit(e, vars, this.chars, this.words, this.lines, origWidth, origHeight);
	    }

	    this.chars.reverse();
	    this.words.reverse();
	    this.lines.reverse();
	    this.isSplit = true;
	    return this;
	  };

	  _proto.revert = function revert() {
	    var originals = this._originals;

	    if (!originals) {
	      throw "revert() call wasn't scoped properly.";
	    }

	    this.elements.forEach(function (e, i) {
	      e.innerHTML = originals[i].html;
	      e.setAttribute("style", originals[i].style);
	    });
	    this.chars = [];
	    this.words = [];
	    this.lines = [];
	    this.isSplit = false;
	    return this;
	  };

	  SplitText.create = function create(element, vars) {
	    return new SplitText(element, vars);
	  };

	  return SplitText;
	}();
	SplitText.version = "3.12.5";
	SplitText.register = _initCore;

	exports.SplitText = SplitText;
	exports.default = SplitText;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

$(document).ready(function () {
    console.log('READY TO RUMBLE');
    var subNavIsOpen = false;
    var mobileNavIsOpen = false;
    

    const lenis = new Lenis({
        duration: 1,
        easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)), // https://www.desmos.com/calculator/brs54l4xou
        direction: 'vertical', // vertical, horizontal
        gestureDirection: 'vertical', // vertical, horizontal, both
        smooth: true,
        // mouseMultiplier: 1,
        smoothTouch: false,
        // touchMultiplier: 2,
        infinite: false,
        prevent: (node) => node.className === 'woocommerce-MyAccount-navigation',
    });
      
    requestAnimationFrame(raf);

    barba.use(barbaPrefetch);

    // Initialize Barba
    barba.init({
        preventRunning: true,
        prevent: ({ el }) => el.classList && el.classList.contains('added_to_cart'),
        transitions: [
            {
                name: 'fade',
                leave({current, next, trigger}) {
                    console.log('GLOBAL LEAVE');

                    return new Promise(resolve => {
                         const leavingAnim = gsap.timeline({
                             onComplete(){
                                 resolve();
                             }
                         });
     
                         leavingAnim .to('.curtain', {duration: .75, autoAlpha: 1, ease: Expo.easeInOut})
                                     .set(current.container, { autoAlpha: 0, display: 'none'});
                     });
                },
                enter({current, next, trigger}) {
                    console.log('GLOBAL ENTER');

                    return new Promise(resolve => {
                         
                         const enterAnim = gsap.timeline({
                             onComplete(){
                                 resolve();
                             }
                         });
     
                         enterAnim   .fromTo(next.container, 0, {autoAlpha: 0}, {autoAlpha: 1, ease: Expo.easeInOut})
                                     .to('.curtain', {duration: .75, autoAlpha: 0, ease: Expo.easeInOut});
                     });
                },
                once(){
                    topbar();
                    nav();
                    btn();
                    productList3d();
                    dropdowns();
                    mediaList();
                    customAddToCart();
                    blockTextNMedia();
                    blockFullMedia();
                    blockTextWithNavigation();
                    homeSliderBottle();
                    preventSamePageReload();
                    preventBarbaOnSomeLinks();
                },
                afterEnter(){
                    console.log('GLOBAL AFTER ENTER');
                    topbar();
                    btn();
                    productList3d();
                    dropdowns();
                    mediaList();
                    customAddToCart();
                    blockTextNMedia();
                    blockFullMedia();
                    blockTextWithNavigation();
                    homeSliderBottle();
                    preventSamePageReload();
                    preventBarbaOnSomeLinks();

                },
                beforeLeave(){
                    $('.topbar a').removeClass('is-active');
                    $('.topbar__sub').removeClass('topbar__sub--is-active');
                    $('.topbar').removeClass('topbar--is-hidden');
                },
                beforeEnter(){
                    window.scrollTo(0, 0);
                    killAllScrollTrigger();
                    preventSamePageReload();
                }

            }
        ],
        views: [{
            namespace: 'shop',
            afterEnter(){
                console.log('AFTER ENTER SHOP');
                catList();
                productListMedia();
            },
        },{
            namespace: 'single-product',
            afterEnter(){
                console.log('AFTER ENTER Single Product');
                singleProductImages();
            }
        },{
            namespace: 'cart',
            afterEnter(){
                console.log('AFTER ENTER CART');
                $('a').attr('data-barba-prevent', true);
            }
        },{
            namespace: 'checkout',
            afterEnter(){
                console.log('AFTER ENTER Checkout');
                $('a').attr('data-barba-prevent', true);
            }
        },{
            namespace: 'account',
            afterEnter(){
                console.log('AFTER ENTER Account');
                $('a').attr('data-barba-prevent', true);
            }
        },
        {
            namespace: 'checkout',
            afterEnter(){
                $('a').attr('data-barba-prevent', true);
                // preventBarbaOnSomeLinks();
            }
        }]
    });

    // topbar();
    // nav();
    // btn();
    // homeSliderBottle();
    // blockFullMedia();
    // blockTextNMedia();
    // productListMedia();
    // catList();
    // productList3d();
    // mediaList();
    // customAddToCart();
    // singleProductImages();
    // dropdowns();
    // blockTextWithNavigation();
    // preventBarbaOnSomeLinks();

    

    function raf(time) {
        lenis.raf(time)
        requestAnimationFrame(raf)
    }

    function topbar() {
        
        ScrollTrigger.create({
            trigger: 'body',
            start: 'top top',
            end: 'bottom bottom',
            invalidateOnRefresh: true,
            refreshPriority: -1000,
            onUpdate: (self) => {
                if(self.scroll() >= window.innerHeight / 2){
                    if (!subNavIsOpen && !mobileNavIsOpen) {
                        if (self.direction === -1) { // scrolling Up
                            $('.topbar').removeClass('topbar--is-hidden');
                        } else { // scrolling Down
                            $('.topbar').addClass('topbar--is-hidden');
                            $('[data-nav]').removeClass('is-active');
                            $('.topbar__sub').removeClass('topbar__sub--is-active');
                        }
                    }
                } else {
                    $('.topbar').removeClass('topbar--is-hidden');
                    $('[data-nav]').removeClass('is-active');
                    $('.topbar__sub').removeClass('topbar__sub--is-active');
                }
            }
        });
    };

    function nav() {
        $('[data-nav]').on('mouseenter, mousemove', (e)=>{
            var thisSubNav = $(e.target).data('nav');
            var thisSubNavEl = $('[data-parent-nav="'+ thisSubNav +'"]');
    
            $('.topbar__sub').removeClass('topbar__sub--is-active');
            $(e.target).addClass('is-active');
            thisSubNavEl.addClass('topbar__sub--is-active');
            subNavIsOpen = true;
        });

        $('.topbar__sub').on('mouseleave', (e)=>{
            $('[data-nav]').removeClass('is-active');
            $('.topbar__sub').removeClass('topbar__sub--is-active');
            subNavIsOpen = false;
        });

        $('[data-nav]').on('mouseleave', (e)=>{
            console.log(e.relatedTarget);
            if(e.relatedTarget.className == 'topbar__main' || e.relatedTarget.className == 'nav-list'){
                $('[data-nav]').removeClass('is-active');
                $('.topbar__sub').removeClass('topbar__sub--is-active');
                subNavIsOpen = false;
            }
        });
    };
    
    function dropdowns() {};

    function btn(){
        var $btn = $('.btn');
        
        $btn.on('mouseenter', function(){
            var $this = $(this);
            var thisText = $this.data('text');
            gsap.to($(this).find('span'), {duration: .5, scrambleText:{text:thisText, chars:'0123456789'}});
        });
        
        // var mainNavItemWidth = $('.topbar__main .nav-list a').outerWidth(true);

        // $('.topbar__main .nav-list a').each(function(){
        //     var mainNavItemWidth = $(this).outerWidth(true);
        //     $(this).css('width', mainNavItemWidth + 'px')
        // });

        // $('.nav-list a').on('mouseenter', function(){
        //     var $this = $(this);
        //     var thisText = $this.attr('title');
        //     gsap.to($this, {duration: .5, scrambleText:{text:thisText, chars:'0123456789'}});
        // });

    };

    function homeSliderBottle() {
        var modelContainer = document.getElementById('model-container');
        var modelUrl = $('.bottle-screen').data('model');
        var cursorPos = { y: 0, x: 0 };
        var perfumeNumber = ['741', '852', '963'];
        var perfumeColor = [0x00ff, 0xaa00ee, 0xff0000];
        var currentPerfumeIndex = 0;
        var rotationSpeed = 0.01;
        var isAnimating = false;
    
        if (modelContainer == null) {
            return;
        };
    
        var prevNextWave = gsap.timeline({
            paused: true,
            onComplete: () => {
                prevNextWave.restart().pause();
                isAnimating = false;
                gsap.set('.number', { clearProps: 'all' });
                gsap.set('.bottle-screen__bg', { autoAlpha: 0 });
            },
            onStart: () => {
                isAnimating = true;
                gsap.set('.bottle-screen__bg', { autoAlpha: 0.5 });
            }
        });
    
        prevNextWave.to('.bottle-screen__number', {
            autoAlpha: .5,
            scale: 1.2,
            duration: .2,
            stagger: {
                amount: .25,
                from: 'center',
                grid: 'auto',
                ease: 'power2.inOut',
            }
        })
        .to('.bottle-screen__number', {
            autoAlpha: 0,
            scale: 1,
            duration: .2,
            stagger: {
                amount: .25,
                from: 'center',
                grid: 'auto',
                ease: 'power2.inOut',
            }
        });
    
        // Create the bottleScene
        const bottleScene = new THREE.Scene();
    
        // Create a camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
    
        // Create the renderer with alpha to enable transparency
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
    
        // Add the renderer to the HTML
        modelContainer.appendChild(renderer.domElement);
    
        // Add ambient light for general illumination
        const ambientLight = new THREE.AmbientLight(perfumeColor[0], 0.5);
        bottleScene.add(ambientLight);
    
        // Add directional light to simulate sunlight
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0.2, 1, 10).normalize();
        bottleScene.add(directionalLight);
    
        // Add point lights to highlight shininess
        const pointLight1 = new THREE.PointLight(perfumeColor[0], 1);
        pointLight1.position.set(2, 3, 2);
        bottleScene.add(pointLight1);
    
        const pointLight2 = new THREE.PointLight(perfumeColor[0], 1);
        pointLight2.position.set(-2, -3, -2);
        bottleScene.add(pointLight2);
    
        let object = null;
        const shinyMaterial = new THREE.MeshPhongMaterial({
            color: 0x000000,
            shininess: 100,
        });
    
        // Load a GLTF model
        const gltfLoader = new THREE.GLTFLoader();
        gltfLoader.load(modelUrl, function (gltf) {
            object = gltf.scene;
            
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.material = shinyMaterial;
                }
            });
    
            bottleScene.add(object);
            object.scale.set(1.5, 1.5, 1.5);
        }, undefined, function (error) {
            console.error(error);
        });
    
        // Render the bottleScene
        function animate() {
            requestAnimationFrame(animate);
    
            // Check if the object is loaded and rotate it
            if (object) {
                object.rotation.y += rotationSpeed;
                object.rotation.x = cursorPos.y / 1000;
                object.rotation.z = cursorPos.x / 1500;
            }
    
            renderer.render(bottleScene, camera);
        }
        animate();
    
        // Handle window resize
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    
        let scrollTriggerBottle = gsap.timeline({
            scrollTrigger: {
                trigger: '.bottle-screen',
                start: 'top bottom',
                end: 'bottom top',
                scrub: true,
            }
        });
    
        scrollTriggerBottle.from('#model-container', { yPercent: 20, ease: 'none' })
                           .to('#model-container', { yPercent: -20, ease: 'none' });
    
        let stBottleBgIn = gsap.timeline({
            scrollTrigger: {
                trigger: '.bottle-screen',
                start: 'top 75%',
                end: 'top 60%',
                scrub: true,
            }
        });
    
        let stBottleBgOut = gsap.timeline({
            scrollTrigger: {
                trigger: '.bottle-screen',
                start: 'bottom 35%',
                end: 'bottom 10%',
                scrub: true,
                onEnter: (self) => {
                    $('.bottle-screen__ctas').addClass('bottle-screen__ctas--is-hidden');
                },
                onLeaveBack: (self) => {
                    $('.bottle-screen__ctas').removeClass('bottle-screen__ctas--is-hidden');
                }
            }
        });
    
        stBottleBgIn.to('.bottle-screen', { '--bg-opacity': 1, ease: 'none' });
        stBottleBgOut.to('.bottle-screen', { '--bg-opacity': 0, ease: 'none' });
    
        let stopTimeout;
    
        const cursorStopped = () => {
            console.log('Cursor has stopped moving.');
            gsap.to('.bottle-screen__bg', { autoAlpha: 0, duration: .2 });
            isAnimating = false;
        };
    
        Observer.create({
            target: '.bottle-screen',
            type: 'pointer',
            onMove: (self) => {
                const velocityX = Math.abs(self.velocityX);
                const velocityY = Math.abs(self.velocityY);
                const velocity = velocityX + velocityY;
                const yPosPercent = self.y - (window.innerHeight / 2);
                const xPosPercent = self.x - (window.innerWidth / 2);
    
                let mappedVelocity = gsap.utils.pipe(
                    gsap.utils.clamp(0, 2500),
                    gsap.utils.mapRange(0, 2500, 0, .5)
                );
    
                gsap.to(cursorPos, { y: yPosPercent, duration: 2, ease: 'power4.Out' });
                gsap.to(cursorPos, { x: xPosPercent, duration: 2, ease: 'power4.Out' });
                gsap.to('.bottle-screen__bg', { autoAlpha: mappedVelocity(velocity), duration: .2 });
    
                isAnimating = true;
    
                clearTimeout(stopTimeout);
                stopTimeout = setTimeout(cursorStopped, 200);
            }
        });
    
        $('.bottle-screen__fg').on('mousemove mouseenter', function (e) {
            var curPosX = e.pageX - $(this).offset().left;
            var curPosY = e.pageY - $(this).offset().top;
            var curPosXPercent = (curPosX / $(this).outerWidth()) * 100;
            var curPosYPercent = (curPosY / $(this).outerHeight()) * 100;
            var maxDistance = $(this).innerWidth() * Math.sqrt(2);
    
            $('.bottle-screen__number').each(function () {
                var thisHalfW = $(this)[0].clientWidth / 2;
                var thisHalfH = $(this)[0].clientHeight / 2;
                var thisLeft = $(this)[0].offsetLeft;
                var thisTop = $(this)[0].offsetTop;
                var thisXCenter = thisLeft + thisHalfW;
                var thisYCenter = thisTop + thisHalfH;
                var distance = getDistance(curPosX, curPosY, thisXCenter, thisYCenter);
                var opacity = gsap.utils.mapRange(0, maxDistance, 1, -7, distance);
                var scale = gsap.utils.mapRange(0, maxDistance, .5, 0, distance);
    
                gsap.to($(this), {
                    autoAlpha: opacity,
                    duration: .2,
                    ease: 'expo.inout',
                });
            });
        });
    
        $('.prev-next--next').on('click', function () {
            getNextOrPrev('next');
        });
    
        $('.prev-next--prev').on('click', function () {
            getNextOrPrev('prev');
        });
    
        document.onkeydown = function (e) {
            switch (e.keyCode) {
                case 37:
                    getNextOrPrev('prev');
                    break;
                case 39:
                    getNextOrPrev('next');
                    break;
            }
        };
    
        function getDistance(x1, y1, x2, y2) {
            let y = x2 - x1;
            let x = y2 - y1;
            return Math.sqrt(x * x + y * y);
        }
    
        function getNextOrPrev(nextOrPrev) {
            if (isAnimating) {
                return;
            }
    
            prevNextWave.play();
    
            if (nextOrPrev == 'next') {
                currentPerfumeIndex = (currentPerfumeIndex + 1) % products.length;
    
                gsap.to('.bottle-screen__current-number', {
                    duration: 1,
                    scrambleText: { text: products[currentPerfumeIndex].productTitle, chars: '0123456789' }
                });
                gsap.to(object.rotation, { y: '+=3.14', duration: 1 });
                $('.bottle-screen__ctas a').attr('href', products[currentPerfumeIndex].permalink);
    
                gsap.to('.bottle-screen', { '--color-1': products[currentPerfumeIndex].colors[0] });
                gsap.to('.bottle-screen', { '--color-3': products[currentPerfumeIndex].colors[2], delay: .1 });
                gsap.to('.bottle-screen', { '--color-2': products[currentPerfumeIndex].colors[1], delay: .2 });
                gsap.to('.bottle-screen', { '--color-1': products[currentPerfumeIndex].colors[0], delay: .3 });
    
                rotationSpeed = 0.01;
            } else {
                currentPerfumeIndex = (currentPerfumeIndex - 1 + products.length) % products.length;
    
                gsap.to('.bottle-screen__current-number', {
                    duration: 1,
                    scrambleText: { text: products[currentPerfumeIndex].productTitle, chars: '0123456789' }
                });
                gsap.to(object.rotation, { y: '-=3.14', duration: 1 });
                $('.bottle-screen__ctas a').attr('href', products[currentPerfumeIndex].permalink);
    
                gsap.to('.bottle-screen', { '--color-1': products[currentPerfumeIndex].colors[0] });
                gsap.to('.bottle-screen', { '--color-2': products[currentPerfumeIndex].colors[1], delay: .1 });
                gsap.to('.bottle-screen', { '--color-3': products[currentPerfumeIndex].colors[2], delay: .2 });
                gsap.to('.bottle-screen', { '--color-4': products[currentPerfumeIndex].colors[3], delay: .3 });
    
                rotationSpeed = -0.01;
            }
        };
    }
    

    function blockFullMedia(){
        var $blockFullMedia = $('.block--full-media');

        $blockFullMedia.each(function(){
            var $this = $(this);
            var $thisMedia = $this.find('.media');
            var $thisText = $this.find('.block--full-media__text');
            var hasVid = $this.find('video').length;
            var animationType = $(this).hasClass('block--full-media--wave') ? 'wave' : 'numeric';
            var isHeader = $(this).hasClass('header');

            if(!isHeader){
                if(animationType == 'wave'){
                    var $thisTextSplit = new SplitText($thisText, {type: 'chars'});

                    let textAnimIn = gsap.timeline({
                        scrollTrigger: {
                            // markers: true,
                            trigger: $thisText,
                            endTrigger: $this,
                            start: 'top bottom', // when the top of the trigger hits the top of the viewport
                            end: 'bottom bottom', // end after scrolling 500px beyond the start
                            scrub: true,
                        }
                    });

                    textAnimIn.from($thisTextSplit.chars, {autoAlpha: 0, 'font-weight': 100, xPercent: 25, yPercent: 25, stagger: .1, easing: 'none'});
                } else {
                    $textLine = $thisText.find('span');
                    let textScrambleIn = gsap.timeline({
                        scrollTrigger: {
                            // markers: true,
                            trigger: $thisText,
                            endTrigger: $this,
                            start: 'top bottom', // when the top of the trigger hits the top of the viewport
                            end: 'bottom bottom', // end after scrolling 500px beyond the start
                            scrub: true,
                        }
                    });

                    $textLine.each(function(){
                        textScrambleIn.to($(this), {scrambleText:{text:$(this)[0].textContent, chars:' 0123456789'}}, );
                    });
                    
                };
            };


            let imgParallax = gsap.timeline({
                scrollTrigger: {
                    onEnter: function(){
                        if(hasVid){
                            console.log('VIDEO PLAYED')
                            $this.find('video')[0].play();
                        }
                    },
                    onLeave: function(){
                        if(hasVid){
                            console.log('VIDEO PAUSED')
                            $this.find('video')[0].pause();
                        }
                    },
                    onEnterBack: function(){
                        if(hasVid){
                            console.log('VIDEO PLAYED')
                            $this.find('video')[0].play();
                        }
                    },
                    onLeaveBack: function(){
                        if(hasVid){
                            console.log('VIDEO PAUSED')
                            $this.find('video')[0].pause();
                        }
                    },
                    // markers: true,
                    trigger: $this,
                    start: 'top bottom',
                    start: ()=>{ !isHeader ? 'top bottom' : 'top top' },
                    end: 'bottom top',
                    scrub: .01,
                }
            });
            
            if(!isHeader){
                let imgBlurIn = gsap.timeline({
                    scrollTrigger: {
                        // markers: true,
                        trigger: $this,
                        start: 'top bottom',
                        end: 'top 60%',
                        scrub: .01,
                    }
                });

                imgBlurIn.from($this, {'--blur': 40, '--brightness': .25, ease: 'none'});
            };



            let imgBlurOut = gsap.timeline({
                scrollTrigger: {
                    // markers: true,
                    trigger: $this,
                    start: 'bottom 40%',
                    end: 'bottom top',
                    scrub: .01,
                }
            });

            imgParallax.to($thisMedia, {yPercent: 20, ease: 'none'});
            
            imgBlurOut.to($this, {'--blur': 40, '--brightness': .25, ease: 'none'});

        });
    };

    function blockTextNMedia(){
        var $blockTextNMedia = $('.block--text-n-media');

        $blockTextNMedia.each(function(){
            var $this = $(this);
            var $thisMedia = $this.find('.media');
            var $thisText = $this.find('h2');
            var $thisTextSplit = new SplitText($thisText, {type: 'chars'});
            var hasVid = $this.find('video').length;

            let imgParallax = gsap.timeline({
                scrollTrigger: {
                    onEnter: function(){
                        if(hasVid){
                            console.log('VIDEO PLAYED')
                            $this.find('video')[0].play();
                        }
                    },
                    onLeave: function(){
                        if(hasVid){
                            console.log('VIDEO PAUSED')
                            $this.find('video')[0].pause();
                        }
                    },
                    onEnterBack: function(){
                        if(hasVid){
                            console.log('VIDEO PLAYED')
                            $this.find('video')[0].play();
                        }
                    },
                    onLeaveBack: function(){
                        if(hasVid){
                            console.log('VIDEO PAUSED')
                            $this.find('video')[0].pause();
                        }
                    },
                    // markers: true,
                    trigger: $this,
                    start: 'top bottom',
                    end: 'bottom top',
                    scrub: .01,
                }
            });
            
            let imgBlurIn = gsap.timeline({
                scrollTrigger: {
                    // markers: true,
                    trigger: $this,
                    start: 'top bottom',
                    end: 'top 60%',
                    scrub: .01,
                }
            });

            let imgBlurOut = gsap.timeline({
                scrollTrigger: {
                    // markers: true,
                    trigger: $this,
                    start: 'bottom 40%',
                    end: 'bottom top',
                    scrub: .01,
                }
            });

            let textAnimIn = gsap.timeline({
                scrollTrigger: {
                    // markers: true,
                    trigger: $thisText,
                    endTrigger: $this,
                    start: 'top bottom', // when the top of the trigger hits the top of the viewport
                    end: 'bottom bottom', // end after scrolling 500px beyond the start
                    scrub: true,
                }
            });

            imgParallax.to($thisMedia, {yPercent: 20, ease: 'none'});
            imgBlurIn.to($this, {'--blur': 0, '--brightness': 1, ease: 'none'});
            imgBlurOut.to($this, {'--blur': 40, '--brightness': .5, ease: 'none'});
            textAnimIn.from($thisTextSplit.chars, {autoAlpha: 0, 'font-weight': 100, xPercent: 25, yPercent: 25, stagger: .1, easing: 'none'});
        });
    };

    function productListMedia(){
        var productListImg = $('.product-list__image');
        var productListMedia = productListImg.find('.media');

        let imgParallax = gsap.timeline({
            scrollTrigger: {
                // markers: true,
                trigger: productListImg,
                start: 'top bottom',
                end: 'bottom top',
                scrub: .01,
            }
        });
        
        let imgBlurIn = gsap.timeline({
            scrollTrigger: {
                // markers: true,
                trigger: productListImg,
                start: 'top bottom',
                end: 'top 80%',
                scrub: .01,
            }
        });

        let imgBlurOut = gsap.timeline({
            scrollTrigger: {
                // markers: true,
                trigger: productListImg,
                start: 'bottom 20%',
                end: 'bottom top',
                scrub: .01,
            }
        });

        imgParallax.to(productListMedia, {yPercent: 20, ease: 'none'});
        imgBlurIn.to(productListImg, {'--blur': 0, '--brightness': 1, ease: 'none'});
        imgBlurOut.to(productListImg, {'--blur': 40, '--brightness': .5, ease: 'none'});
    };

    function catList(){
        $('.cat-item').each(function(){
            var $this = $(this);
            var thisTitle = $(this).find('.cat-item__title');
            var thisTitleSplit = new SplitText(thisTitle, {type: 'chars'});
            
            var enterVPAnim = gsap.timeline({
            scrollTrigger: {
                onLeave: function(){$this.addClass('cat-item--ready')},
                onEnterBack: function(){$this.removeClass('cat-item--ready')},
                trigger: $(this),
                start: 'top bottom', // when the top of the trigger hits the top of the viewport
                end: 'bottom 80%', // end after scrolling 500px beyond the start
                scrub: true, // smooth scrubbing, takes 1 second to "catch up" to the scrollbar
                }
            });
            
            var leaveVPAnim = gsap.timeline({
                onStart: function(){$(this).removeClass('.cat-item--ready')},
            scrollTrigger: {
                        // markers: true,
                        onEnter: function(){$this.removeClass('cat-item--ready')},
                        onLeaveBack: function(){$this.addClass('cat-item--ready')},
                trigger: $(this),
                start: 'top 5%', // when the top of the trigger hits the top of the viewport
                end: 'top -15%', // end after scrolling 500px beyond the start
                scrub: true, // smooth scrubbing, takes 1 second to "catch up" to the scrollbar
                    }
            });
            
            enterVPAnim.from(thisTitleSplit.chars, {autoAlpha: 0, 'font-weight': 100, xPercent: 25, yPercent: 25, stagger: .1, easing: 'none'});
            leaveVPAnim.to(thisTitleSplit.chars, {autoAlpha: 0, 'font-weight': 100, yPercent: -25, stagger: .1, easing: 'none'});
        });
        
        $('.cat-list--v1').on('mouseenter, mousemove', function(e){
            var element = $(this);
            var offset = element.offset();
            var width = element.width();
            var posX = e.pageX - offset.left;
            var posXPercent = (posX / width) * 100;
            
            const imgPosMap = gsap.utils.mapRange(0, 100, 50, -50, posXPercent);
            
            gsap.to($(this), {'--posX': posX + 'px', duration: 2, ease: 'power4.out'});
            gsap.to($('.cat-item__details__media'), {'--x': imgPosMap + 'px', duration: 2, ease: 'power4.out'});
        });
        
        $('.cat-list--v1 .cat-item__link').on('mouseenter, mousemove', function(e){
            // console.log('ENTER')
            // var thisItem = $(this).parents('.cat-item');
            var element = $(e.target).parents('.cat-item');
            var thisDetail = element.find('.cat-item__details');
            var thisDetailImg = thisDetail.find('.cat-item__details__media img');
            var offset = element.offset();
            // var width = element.width();
            var height = element.height();
        
            // var posX = e.pageX - offset.left;
            var posY = e.pageY - offset.top;
        
            // var posXPercent = (posX / width) * 100;
            var posYPercent = (posY / height) * 100;
            const imgPosMap = gsap.utils.mapRange(0, 100, 25, -25, posYPercent);
            console.log()
            
            gsap.to(thisDetail, {'--posY': posY + 'px', duration: 2, ease: 'power4.out'});
            gsap.to(thisDetailImg, {'--y': imgPosMap + 'px', duration: 2, ease: 'power4.out'});
        
            
        });
    };

    function productList3d() {
        $('.product-item').each(function () {
            var thisItemIsHovered = false;
            var this3DContainer = $(this).find('.product-item__3d');
            var model3d = this3DContainer.data('model');
    
            $(this).find('a').on('mouseenter mouseover', function () {
                thisItemIsHovered = true;
            });
    
            $(this).find('a').on('mouseleave', function () {
                thisItemIsHovered = false;
            });
    
            // Create the scene
            const scene = new THREE.Scene();
    
            // Create a camera
            const camera = new THREE.PerspectiveCamera(75, this3DContainer[0].clientWidth / this3DContainer[0].clientHeight);
            camera.position.z = 5;
    
            // Create the renderer with alpha to enable transparency
            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(this3DContainer[0].clientWidth, this3DContainer[0].clientHeight);
            renderer.setClearColor(0x000000, 0);
    
            // Add the renderer to the HTML
            this3DContainer[0].appendChild(renderer.domElement);
    
            // Add ambient light for general illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
    
            // Add directional light to simulate sunlight
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0.2, 1, 10).normalize();
            scene.add(directionalLight);
    
            // Add point lights to highlight the shininess
            const pointLight1 = new THREE.PointLight(0xffffff, 1);
            pointLight1.position.set(2, 3, 2);
            scene.add(pointLight1);
    
            const pointLight2 = new THREE.PointLight(0xffffff, 1);
            pointLight2.position.set(-2, -3, -2);
            scene.add(pointLight2);
    
            let object = null;
    
            // Load a GLTF model
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load(model3d, function (gltf) {
                // Create a shiny material
                const shinyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    shininess: 100,
                });
    
                // Apply the shiny material to the model
                gltf.scene.traverse(function (child) {
                    if (child.isMesh) {
                        child.material = shinyMaterial;
                    }
                });
    
                // Add the loaded object to the scene
                scene.add(gltf.scene);
                object = gltf.scene;
                object.scale.set(1.4, 1.4, 1.4);
            }, undefined, function (error) {
                console.error(error);
            });
    
            // Render the scene
            function animate() {
                requestAnimationFrame(animate);
    
                // Check if the object is loaded and rotate it
                if (object && thisItemIsHovered) {
                    object.rotation.y += 0.01;
                }
    
                renderer.render(scene, camera);
            }
            animate();
    
            // Handle window resize
            window.addEventListener('resize', function () {
                camera.aspect = this3DContainer[0].clientWidth / this3DContainer[0].clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(this3DContainer[0].clientWidth, this3DContainer[0].clientHeight);
            });
        });
    
        $('.product-item__media').each(function () {
            var thisModel = $(this).find('.product-item__3d');
            let scrollTriggerBottle = gsap.timeline({
                scrollTrigger: {
                    trigger: $(this),
                    start: 'top bottom',
                    end: 'bottom top',
                    scrub: .001,
                }
            });
    
            scrollTriggerBottle.from(thisModel, { yPercent: 20, ease: 'none' })
                .to(thisModel, { yPercent: -20, ease: 'none' });
        });
    }
    

    function mediaList(){
        $('.media-list').each(function(e){
            var $this = $(this);
            var items = $this.find('li');
            var img = $this.find('img');

            let staggerItems = gsap.timeline({
                scrollTrigger: {
                    // markers: true,
                    trigger: $this,
                    start: 'top bottom',
                    end: 'top center',
                    scrub: .01,
                }
            });

            staggerItems.from(items, {yPercent: 25, stagger: .15, ease: 'none'}, 'sameTime')
                        .to(items, {'--blur': '0px', '--brightness': 1, stagger: .15, ease: 'none'}, 'sameTime')
                        .to(img, {yPercent: 16.66, stagger: .15, ease: 'none'}, 'sameTime');

        });
    };

    function singleProductImages(){
        $('.single-product__thumbnails__media').on('click', function(e){
            var thisIndex = $(this).data('index');
            $('.single-product__current__media').removeClass('single-product__current__media--is-active');
            $('[data-related="'+ thisIndex +'"]').addClass('single-product__current__media--is-active');
        });
    };

    function dropdowns(){
        $('.dropdown__trigger').on('click', function(){
            var isOpen = $(this).parent('.dropdown').hasClass('dropdown--is-open');

            if(isOpen){
                $(this).parent('.dropdown').removeClass('dropdown--is-open');
            } else {
                $(this).parent('.dropdown').addClass('dropdown--is-open');
            }
        });
    };

    function customAddToCart(){
        $('body').on('click', '.single_add_to_cart_button', function(e) {
            e.preventDefault();
    
            var $thisbutton = $(this),
                thisButtonText = $thisbutton.text();
                product_id = $thisbutton.val(), // Assuming the button value is the product ID
                quantity = $thisbutton.closest('form.cart').find('input.qty').val() || 1;
    
            var data = {
                action: 'custom_add_to_cart',
                product_id: product_id,
                quantity: quantity,
                nonce: custom_ajax_object.nonce
            };
            
            $thisbutton.addClass('no-touch');

            $.post(custom_ajax_object.ajax_url, data, function(response) {
                console.log('Full response:', response); // Log the full response
    
                if (response && response.fragments) {
                    // If the response contains fragments, consider it successful
                    $(document.body).trigger('added_to_cart', [response.fragments, response.cart_hash, $thisbutton]);
                    $thisbutton.text('Product added to cart!');
                    
                    setTimeout(function(){
                        $thisbutton.removeClass('no-touch');
                        $thisbutton.text(thisButtonText);
                    }, 2000);

                } else {
                    alert('Failed to add product to cart.');
                }
            }).fail(function(xhr, status, error) {
                console.error('AJAX error:', status, error); // Log any AJAX errors
                alert('AJAX error: ' + error);
            });
        });
    };

    function blockTextWithNavigation(){
        var $link = $('.text-with-navigation__nav a');

        $link.on('click', function(e){
            e.preventDefault();
            var thisHref = $(this).attr('href');
            var offset = getComputedStyle(document.documentElement).getPropertyValue('--topBarH');

            console.log(offset);

            lenis.scrollTo(thisHref, {
				offset: -parseFloat(offset),
				// onComplete: ()=>{
				// 	gsap.to('.slides', {autoAlpha: 1});
				// 	// console.log( scrollTriggerID );
				// }
			});

        });
    };

    function preventBarbaOnSomeLinks(){
        $('a[href*="cart"], a[href*="checkout"], a[href*="my-account"], .add_to_cart_button').each(function() {
            $(this).attr('data-barba-prevent', true);
        });
    };




    function killAllScrollTrigger() {

        let triggers = ScrollTrigger.getAll();
        triggers.forEach(trigger => {
            trigger.kill();
        });

    };

    function preventSamePageReload() {
        var links = document.querySelectorAll('a[href]');
        var cbk = function (e) {
            if (e.currentTarget.href === window.location.href) {
                e.preventDefault();
                e.stopPropagation();

                // if (!navIsClosed) {
                //     closeNavTl.play();
                // }
            }
        };

        for (var i = 0; i < links.length; i++) {
            links[i].addEventListener('click', cbk);
        }
    };

    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    };

});